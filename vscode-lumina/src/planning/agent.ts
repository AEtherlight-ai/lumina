/**
 * Collaborative Planning Agent - AI-assisted sprint planning
 *
 * DESIGN DECISION: Conversational agent guides user through sprint creation
 * WHY: Sprint planning is complex, AI can suggest tasks, dependencies, estimates
 *
 * REASONING CHAIN:
 * 1. User: "I want to add OAuth2 authentication"
 * 2. Agent: "I'll help create a sprint. What database are you using?"
 * 3. User: "PostgreSQL"
 * 4. Agent generates draft:
 *    - DB-001: Create users/sessions tables (2 hours)
 *    - API-001: OAuth2 endpoints (4 hours, depends on DB-001)
 *    - UI-001: Login page (3 hours)
 *    - TEST-001: Integration tests (3 hours, depends on API-001, UI-001)
 * 5. User reviews, modifies, approves
 * 6. Result: Complete sprint plan in minutes, not hours
 *
 * PATTERN: Pattern-AI-PLANNING-001 (Conversational Sprint Planning)
 * RELATED: AS-018 (Collaborative Planning Agent)
 */

import { SprintPlan, Task, AgentType, TaskId, ApprovalGate } from '../sprint_parser/types';

/**
 * Planning conversation state
 */
export enum PlanningState {
    /** Initial state */
    IDLE = 'IDLE',
    /** Gathering requirements */
    GATHERING_REQUIREMENTS = 'GATHERING_REQUIREMENTS',
    /** Generating draft */
    GENERATING_DRAFT = 'GENERATING_DRAFT',
    /** User reviewing */
    REVIEWING = 'REVIEWING',
    /** User editing */
    EDITING = 'EDITING',
    /** Validated and ready */
    READY = 'READY',
}

/**
 * Planning conversation message
 */
export interface PlanningMessage {
    /** Message role */
    role: 'user' | 'agent' | 'system';
    /** Message content */
    content: string;
    /** Timestamp */
    timestamp: string;
}

/**
 * Planning requirements (gathered from user)
 */
export interface PlanningRequirements {
    /** Feature description */
    feature: string;
    /** Technology stack (database, framework, etc.) */
    techStack: string[];
    /** Estimated timeline (optional) */
    estimatedTimeline?: string;
    /** Priority (high, medium, low) */
    priority?: string;
    /** Dependencies on existing code (optional) */
    dependencies?: string[];
}

/**
 * Draft sprint plan (generated by agent)
 */
export interface DraftSprintPlan {
    /** Sprint name */
    name: string;
    /** Sprint description */
    description: string;
    /** Tasks */
    tasks: Task[];
    /** Approval gates */
    approvalGates?: ApprovalGate[];
    /** Agent reasoning for task breakdown */
    reasoning: string;
}

/**
 * Collaborative planning agent
 *
 * DESIGN DECISION: Stateful conversation with multi-turn dialogue
 * WHY: Sprint planning requires context, agent remembers previous answers
 */
export class PlanningAgent {
    private state: PlanningState = PlanningState.IDLE;
    private conversation: PlanningMessage[] = [];
    private requirements: Partial<PlanningRequirements> = {};
    private draftPlan: DraftSprintPlan | null = null;

    /**
     * Start planning session
     */
    start(initialPrompt: string): PlanningMessage {
        this.state = PlanningState.GATHERING_REQUIREMENTS;
        this.conversation = [];

        // User's initial message
        this.addMessage('user', initialPrompt);

        // Agent's first response
        const response = this.generateGatheringResponse();
        this.addMessage('agent', response);

        return this.conversation[this.conversation.length - 1];
    }

    /**
     * Send user message
     */
    sendMessage(content: string): PlanningMessage {
        this.addMessage('user', content);

        // Process message based on state
        let response: string;

        switch (this.state) {
            case PlanningState.GATHERING_REQUIREMENTS:
                response = this.processRequirementsMessage(content);
                break;

            case PlanningState.REVIEWING:
                response = this.processReviewMessage(content);
                break;

            case PlanningState.EDITING:
                response = this.processEditMessage(content);
                break;

            default:
                response = 'Sorry, I\'m not sure how to help with that right now.';
        }

        this.addMessage('agent', response);
        return this.conversation[this.conversation.length - 1];
    }

    /**
     * Add message to conversation
     */
    private addMessage(role: 'user' | 'agent' | 'system', content: string): void {
        this.conversation.push({
            role,
            content,
            timestamp: new Date().toISOString(),
        });
    }

    /**
     * Generate initial gathering response
     *
     * DESIGN DECISION: Ask about tech stack first
     * WHY: Determines which agents needed (Database vs NoSQL, etc.)
     */
    private generateGatheringResponse(): string {
        return `Great! I'll help you create a sprint plan. To generate the best tasks, I need to understand your tech stack.\n\nWhat technologies are you using? (e.g., PostgreSQL, React, Node.js, Docker)`;
    }

    /**
     * Process requirements gathering message
     *
     * DESIGN DECISION: Extract tech stack, feature details from conversation
     * WHY: Determines task breakdown (OAuth2 + PostgreSQL = specific tasks)
     */
    private processRequirementsMessage(content: string): string {
        // Parse tech stack from message (simple keyword extraction)
        const techStack = this.extractTechStack(content);

        if (techStack.length > 0) {
            this.requirements.techStack = techStack;

            // If we have enough info, generate draft
            if (this.hasEnoughRequirements()) {
                this.state = PlanningState.GENERATING_DRAFT;
                this.generateDraft();
                this.state = PlanningState.REVIEWING;

                return this.formatDraftForReview();
            } else {
                return 'Got it! Any other technologies or constraints I should know about?';
            }
        }

        return 'I didn\'t catch that. Could you list the technologies you\'re using? (e.g., PostgreSQL, React, Node.js)';
    }

    /**
     * Extract tech stack from user message
     *
     * DESIGN DECISION: Simple keyword matching
     * WHY: Full NLP overkill, keywords sufficient for MVP
     *
     * FUTURE: Integrate with LLM for better extraction
     */
    private extractTechStack(message: string): string[] {
        const keywords: { [key: string]: string } = {
            'postgres': 'PostgreSQL',
            'postgresql': 'PostgreSQL',
            'mysql': 'MySQL',
            'mongo': 'MongoDB',
            'mongodb': 'MongoDB',
            'react': 'React',
            'vue': 'Vue',
            'angular': 'Angular',
            'node': 'Node.js',
            'nodejs': 'Node.js',
            'express': 'Express',
            'docker': 'Docker',
            'kubernetes': 'Kubernetes',
            'k8s': 'Kubernetes',
            'redis': 'Redis',
        };

        const found: string[] = [];
        const lower = message.toLowerCase();

        Object.keys(keywords).forEach(keyword => {
            if (lower.includes(keyword)) {
                const tech = keywords[keyword];
                if (!found.includes(tech)) {
                    found.push(tech);
                }
            }
        });

        return found;
    }

    /**
     * Check if we have enough requirements to generate draft
     */
    private hasEnoughRequirements(): boolean {
        return (this.requirements.techStack?.length || 0) >= 2;
    }

    /**
     * Generate draft sprint plan
     *
     * DESIGN DECISION: Rule-based task generation
     * WHY: Predictable, testable, doesn't require LLM API
     *
     * FUTURE: Integrate LLM for more sophisticated generation
     */
    private generateDraft(): void {
        const feature = this.getFeatureFromConversation();
        const techStack = this.requirements.techStack || [];

        // Generate tasks based on feature + tech stack
        const tasks: Task[] = [];
        let taskCounter = 1;

        // Determine if database task needed
        const hasDatabase = techStack.some(tech =>
            ['PostgreSQL', 'MySQL', 'MongoDB'].includes(tech)
        );

        if (hasDatabase) {
            tasks.push({
                id: `DB-00${taskCounter++}` as TaskId,
                agent: AgentType.Database,
                description: `Create database schema for ${feature}`,
                estimated_duration: '2 hours',
                dependencies: [],
            });
        }

        // API task (depends on DB if exists)
        tasks.push({
            id: `API-00${taskCounter++}` as TaskId,
            agent: AgentType.API,
            description: `Implement API endpoints for ${feature}`,
            estimated_duration: '4 hours',
            dependencies: hasDatabase ? ['DB-001' as TaskId] : [],
        });

        // UI task (parallel with API if no DB dependency)
        const hasUI = techStack.some(tech =>
            ['React', 'Vue', 'Angular'].includes(tech)
        );

        if (hasUI) {
            tasks.push({
                id: `UI-00${taskCounter++}` as TaskId,
                agent: AgentType.UI,
                description: `Create UI components for ${feature}`,
                estimated_duration: '3 hours',
                dependencies: [],
            });
        }

        // Test task (depends on API + UI)
        const testDeps: TaskId[] = [];
        if (hasDatabase) testDeps.push('DB-001' as TaskId);
        testDeps.push(`API-00${hasDatabase ? '2' : '1'}` as TaskId);
        if (hasUI) testDeps.push(`UI-00${hasDatabase ? '3' : '2'}` as TaskId);

        tasks.push({
            id: `TEST-00${taskCounter++}` as TaskId,
            agent: AgentType.Test,
            description: `Write integration tests for ${feature}`,
            estimated_duration: '3 hours',
            dependencies: testDeps,
        });

        // Documentation task (parallel with everything else)
        tasks.push({
            id: `DOCS-00${taskCounter++}` as TaskId,
            agent: AgentType.Docs,
            description: `Document ${feature} implementation`,
            estimated_duration: '1 hour',
            dependencies: [],
        });

        this.draftPlan = {
            name: `Implement ${feature}`,
            description: `Sprint to implement ${feature} using ${techStack.join(', ')}`,
            tasks,
            reasoning: this.generateReasoning(feature, techStack, tasks),
        };
    }

    /**
     * Get feature name from conversation
     */
    private getFeatureFromConversation(): string {
        // Extract from first user message
        const firstMessage = this.conversation.find(m => m.role === 'user');
        if (!firstMessage) {
            return 'Feature';
        }

        // Simple extraction (first few words)
        const words = firstMessage.content.split(' ').slice(0, 5).join(' ');
        return words || 'Feature';
    }

    /**
     * Generate reasoning for task breakdown
     */
    private generateReasoning(feature: string, techStack: string[], tasks: Task[]): string {
        let reasoning = `Task Breakdown Reasoning:\n\n`;

        reasoning += `1. Feature: ${feature}\n`;
        reasoning += `2. Tech Stack: ${techStack.join(', ')}\n`;
        reasoning += `3. Generated ${tasks.length} tasks:\n`;

        tasks.forEach(task => {
            reasoning += `   - ${task.id}: ${task.description} (${task.agent})\n`;
            if (task.dependencies.length > 0) {
                reasoning += `     Dependencies: ${task.dependencies.join(', ')}\n`;
            }
        });

        reasoning += `\n4. Parallel Execution Opportunities:\n`;
        const parallelTasks = tasks.filter(t => t.dependencies.length === 0);
        reasoning += `   - ${parallelTasks.map(t => t.id).join(', ')} can run in parallel\n`;

        return reasoning;
    }

    /**
     * Format draft for review
     */
    private formatDraftForReview(): string {
        if (!this.draftPlan) {
            return 'Error: No draft plan generated.';
        }

        let response = `Great! Here's a draft sprint plan:\n\n`;
        response += `**${this.draftPlan.name}**\n`;
        response += `${this.draftPlan.description}\n\n`;
        response += `**Tasks:**\n`;

        this.draftPlan.tasks.forEach(task => {
            response += `- ${task.id}: ${task.description} (${task.agent}, ${task.estimatedDuration})\n`;
            if (task.dependencies.length > 0) {
                response += `  Dependencies: ${task.dependencies.join(', ')}\n`;
            }
        });

        response += `\n**Reasoning:**\n${this.draftPlan.reasoning}\n\n`;
        response += `What do you think? (Reply: "looks good", "change <task>", or "add <task>")`;

        return response;
    }

    /**
     * Process review message
     */
    private processReviewMessage(content: string): string {
        const lower = content.toLowerCase();

        if (lower.includes('looks good') || lower.includes('approve') || lower.includes('accept')) {
            this.state = PlanningState.READY;
            return 'Excellent! Sprint plan is ready. Use "lumina.executeSprint" command to start execution.';
        }

        if (lower.includes('change') || lower.includes('modify')) {
            this.state = PlanningState.EDITING;
            return 'Sure! Which task would you like to change? (e.g., "Change DB-001 duration to 3 hours")';
        }

        if (lower.includes('add')) {
            this.state = PlanningState.EDITING;
            return 'Sure! What task would you like to add? (e.g., "Add infrastructure task for Docker setup")';
        }

        return 'I didn\'t understand that. You can say "looks good", "change <task>", or "add <task>".';
    }

    /**
     * Process edit message
     */
    private processEditMessage(content: string): string {
        // TODO: Implement task editing logic
        // For MVP, just acknowledge and return to reviewing

        this.state = PlanningState.REVIEWING;
        return 'Changes applied. Here\'s the updated plan:\n\n' + this.formatDraftForReview();
    }

    /**
     * Get current state
     */
    getState(): PlanningState {
        return this.state;
    }

    /**
     * Get conversation history
     */
    getConversation(): PlanningMessage[] {
        return [...this.conversation];
    }

    /**
     * Get draft plan
     */
    getDraftPlan(): DraftSprintPlan | null {
        return this.draftPlan;
    }

    /**
     * Convert draft to SprintPlan
     */
    toSprintPlan(): SprintPlan | null {
        if (!this.draftPlan || this.state !== PlanningState.READY) {
            return null;
        }

        // Calculate total duration from tasks
        const totalDuration = this.draftPlan.tasks.reduce((total, task) => {
            const match = task.estimated_duration.match(/(\d+)\s*hour/i);
            return total + (match ? parseInt(match[1]) : 0);
        }, 0);

        return {
            name: this.draftPlan.name,
            description: this.draftPlan.description,
            tasks: this.draftPlan.tasks,
            total_estimated_duration: `${totalDuration} hours`,
            metadata: {
                version: '1.0',
                author: 'Planning Agent',
            },
            approvalGates: this.draftPlan.approvalGates || [],
        };
    }
}
