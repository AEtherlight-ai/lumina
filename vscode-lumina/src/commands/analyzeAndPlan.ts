/**
 * Analyze and Plan Command
 *
 * DESIGN DECISION: Full pipeline orchestration via SkillOrchestrator
 * WHY: Users need one-click sprint analysis + planning
 *
 * REASONING CHAIN:
 * 1. User runs command: aetherlight.analyzeAndPlan
 * 2. Prompt for sprint file (default: ACTIVE_SPRINT.toml)
 * 3. Initialize SkillOrchestrator with all dependencies
 * 4. Run full pipeline: load ‚Üí score ‚Üí assign ‚Üí gather ‚Üí validate ‚Üí generate
 * 5. Show progress with notifications
 * 6. Display results (tasks processed, duration, errors)
 * 7. Performance: <2min incremental, <5min full
 *
 * PATTERN: Pattern-ORCHESTRATION-001 (Smart Skill Chaining)
 * PATTERN: Pattern-INCREMENTAL-001 (Smart Gap Filling)
 * RELATED: MID-008 (Skill Orchestrator), MID-011 (Integration)
 *
 * @module commands/analyzeAndPlan
 */

import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { SkillOrchestrator, OrchestratorConfig, PipelineResult } from '../services/SkillOrchestrator';
import { MultiFormatParser } from '../services/MultiFormatParser';
import { ConfidenceScorer } from '../services/ConfidenceScorer';
import { PatternLibrary } from '../services/PatternLibrary';
import { AgentRegistry } from '../services/AgentRegistry';
import { ContextGatherer } from '../services/ContextGatherer';

/**
 * Run full analyze and plan pipeline
 *
 * DESIGN DECISION: Single command orchestrates entire workflow
 * WHY: User gets sprint analysis with agent assignment + context gathering in one click
 */
export async function analyzeAndPlan(): Promise<void> {
	try {
		// 1. Find workspace root
		const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
		if (!workspaceRoot) {
			// MID-023: Enhanced error message with context and action
			const action = await vscode.window.showErrorMessage(
				'‚ùå No Workspace Folder Open\n\n' +
				'Why this matters: √ÜtherLight needs a workspace to locate your sprint files, agents, and patterns.\n\n' +
				'What to do: Open a folder containing your project.',
				'Open Folder',
				'Learn More'
			);

			if (action === 'Open Folder') {
				await vscode.commands.executeCommand('vscode.openFolder');
			} else if (action === 'Learn More') {
				vscode.env.openExternal(vscode.Uri.parse('https://docs.aetherlight.dev/getting-started'));
			}
			return;
		}

		// 2. Prompt for sprint file or use default
		const defaultSprintPath = path.join(workspaceRoot, 'internal', 'sprints', 'ACTIVE_SPRINT.toml');

		const useDefault = await vscode.window.showQuickPick(['Yes', 'No'], {
			placeHolder: `Use default sprint file? (internal/sprints/ACTIVE_SPRINT.toml)`,
			canPickMany: false
		});

		let sprintPath = defaultSprintPath;

		if (useDefault === 'No') {
			// Let user select a sprint file
			const selectedFile = await vscode.window.showOpenDialog({
				canSelectMany: false,
				canSelectFiles: true,
				canSelectFolders: false,
				defaultUri: vscode.Uri.file(path.join(workspaceRoot, 'internal', 'sprints')),
				filters: {
					'TOML Files': ['toml']
				},
				openLabel: 'Select Sprint File'
			});

			if (!selectedFile || selectedFile.length === 0) {
				return; // User cancelled
			}

			sprintPath = selectedFile[0].fsPath;
		} else if (useDefault === undefined) {
			return; // User cancelled
		}

		// 3. Verify sprint file exists
		if (!fs.existsSync(sprintPath)) {
			const create = await vscode.window.showWarningMessage(
				`Sprint file not found: ${sprintPath}`,
				'Create Empty Sprint',
				'Cancel'
			);

			if (create !== 'Create Empty Sprint') {
				return;
			}

			// Create empty sprint structure
			const emptySprintContent = `# Empty Sprint - Generated by √ÜtherLight

[meta]
sprint_name = "New Sprint"
version = "0.1.0"
created = "${new Date().toISOString().split('T')[0]}"
status = "active"
`;
			fs.mkdirSync(path.dirname(sprintPath), { recursive: true });
			fs.writeFileSync(sprintPath, emptySprintContent, 'utf8');
		}

		// 4. Initialize all middleware components
		const patternsPath = path.join(workspaceRoot, 'docs', 'patterns');
		const agentsPath = path.join(workspaceRoot, 'internal', 'agents');

		const parser = new MultiFormatParser();
		const scorer = new ConfidenceScorer(workspaceRoot);
		const patternLibrary = new PatternLibrary();
		const agentRegistry = new AgentRegistry(agentsPath);

		// Load pattern library and agent registry
		await vscode.window.withProgress({
			location: vscode.ProgressLocation.Notification,
			title: 'Initializing Middleware',
			cancellable: false
		}, async (progress) => {
			progress.report({ message: 'Loading pattern library...' });
			await patternLibrary.loadPatterns(patternsPath);

			progress.report({ message: 'Loading agent registry...' });
			await agentRegistry.initialize();
		});

		// MID-019: Warn if default agent is being used (registry was empty)
		const agents = agentRegistry.getAllAgents();
		if (agents.length === 1 && agents[0].id === 'general-agent' && agents[0].filePath === '<default>') {
			const action = await vscode.window.showWarningMessage(
				'‚ö†Ô∏è Using default "general-agent" - No specialized agents found.\n\n' +
				'For better performance, create specialized agents for your tasks (e.g., api-agent, ui-agent, infrastructure-agent).',
				'Create Agent',
				'Continue'
			);

			if (action === 'Create Agent') {
				// Run Create Agent command
				await vscode.commands.executeCommand('aetherlight.createAgent');
				return; // Exit - user will run Analyze & Plan again after creating agent
			}
			// If "Continue" or dismissed, proceed with default agent
		}

		// Create context gatherer after pattern library is loaded
		const contextGatherer = new ContextGatherer(patternLibrary, workspaceRoot);

		// 5. Create orchestrator config
		const config: OrchestratorConfig = {
			parser,
			scorer,
			patternLibrary,
			agentRegistry,
			contextGatherer,
			projectRoot: workspaceRoot
		};

		const orchestrator = new SkillOrchestrator(config);

		// 6. Run pipeline with progress
		const result = await vscode.window.withProgress({
			location: vscode.ProgressLocation.Notification,
			title: 'Analyze and Plan Pipeline',
			cancellable: false
		}, async (progress) => {
			progress.report({ message: 'Loading sprint...' });
			await new Promise(resolve => setTimeout(resolve, 500));

			progress.report({ message: 'Scoring confidence...' });
			await new Promise(resolve => setTimeout(resolve, 500));

			progress.report({ message: 'Assigning agents...' });
			await new Promise(resolve => setTimeout(resolve, 500));

			progress.report({ message: 'Gathering context...' });
			await new Promise(resolve => setTimeout(resolve, 500));

			progress.report({ message: 'Validating...' });

			return await orchestrator.runAnalyzeAndPlan(sprintPath);
		});

		// 7. Show detailed results (MID-021)
		if (result.success) {
			const durationSeconds = (result.duration / 1000).toFixed(2);

			// Build detailed results items for QuickPick
			const items: vscode.QuickPickItem[] = [];

			// Summary
			items.push({
				label: '$(check) Pipeline Completed Successfully',
				description: `${durationSeconds}s`,
				detail: `${result.tasksProcessed} tasks processed | ${result.newTasks} new | ${result.updatedTasks} updated`
			});

			items.push({ label: '', kind: vscode.QuickPickItemKind.Separator });

			// Confidence breakdown
			if (result.confidenceBreakdown) {
				const cb = result.confidenceBreakdown;
				items.push({
					label: '$(graph) Confidence Distribution',
					description: `Avg: ${(cb.average * 100).toFixed(0)}%`,
					detail: `üü¢ High: ${cb.high} | üü° Medium: ${cb.medium} | üî¥ Low: ${cb.low}`
				});
			}

			// Agent assignments
			if (result.agentAssignments && result.agentAssignments.length > 0) {
				items.push({ label: '', kind: vscode.QuickPickItemKind.Separator });
				items.push({
					label: '$(person) Agent Assignments',
					description: `${result.agentAssignments.length} tasks assigned`,
					detail: 'Click to view all assignments'
				});

				// Show top 3 assignments
				result.agentAssignments.slice(0, 3).forEach(assignment => {
					items.push({
						label: `  ${assignment.taskId}: ${assignment.taskName}`,
						description: `‚Üí ${assignment.agentName}`,
						detail: `Score: ${assignment.matchScore.toFixed(2)} | ${assignment.matchReason}`
					});
				});

				if (result.agentAssignments.length > 3) {
					items.push({
						label: `  ... and ${result.agentAssignments.length - 3} more`,
						description: '',
						detail: ''
					});
				}
			}

			// Pattern discoveries
			if (result.patternDiscoveries && result.patternDiscoveries.length > 0) {
				items.push({ label: '', kind: vscode.QuickPickItemKind.Separator });
				items.push({
					label: '$(symbol-namespace) Patterns Discovered',
					description: `${result.patternDiscoveries.length} patterns matched`,
					detail: 'Patterns matched to tasks'
				});

				result.patternDiscoveries.slice(0, 3).forEach(pattern => {
					items.push({
						label: `  ${pattern.patternId}`,
						description: `${pattern.taskIds.length} tasks`,
						detail: `Relevance: ${(pattern.relevanceScore * 100).toFixed(0)}%`
					});
				});
			}

			// Files discovered
			if (result.filesDiscovered && result.filesDiscovered.length > 0) {
				items.push({ label: '', kind: vscode.QuickPickItemKind.Separator });
				items.push({
					label: '$(file-code) Files Discovered',
					description: `${result.filesDiscovered.length} files`,
					detail: 'Context files gathered for tasks'
				});
			}

			// Validation results
			if (result.validationResults && result.validationResults.length > 0) {
				items.push({ label: '', kind: vscode.QuickPickItemKind.Separator });
				items.push({
					label: '$(check-all) Validation Results',
					description: `${result.validationResults.length} checks`,
					detail: result.validationResults.join(' | ')
				});
			}

			// Actions
			items.push({ label: '', kind: vscode.QuickPickItemKind.Separator });
			items.push({
				label: '$(file-text) Open Sprint File',
				description: path.basename(sprintPath),
				detail: 'View updated sprint file'
			});

			// Show QuickPick
			const selected = await vscode.window.showQuickPick(items, {
				title: '‚ú® Analyze & Plan Results',
				placeHolder: 'Select an action or press ESC to close',
				canPickMany: false
			});

			if (selected && selected.label.includes('Open Sprint File')) {
				const doc = await vscode.workspace.openTextDocument(sprintPath);
				await vscode.window.showTextDocument(doc);
			}
		} else {
			// MID-023: Enhanced error message with context and actions
			let actionButtons: string[] = [];
			let explanation = '';

			// Provide specific guidance based on error type
			if (result.error?.includes('Agent validation failed')) {
				explanation = 'One or more tasks reference agents that don\'t exist in internal/agents/.\n\n' +
					'Why this matters: Tasks need valid agent assignments to be processed.';
				actionButtons = ['Create Agent', 'View Logs'];
			} else if (result.error?.includes('Dependency validation failed')) {
				explanation = 'Circular dependencies detected between tasks.\n\n' +
					'Why this matters: Tasks with circular dependencies cannot be completed.';
				actionButtons = ['Open Sprint File', 'View Logs'];
			} else {
				explanation = 'An unexpected error occurred during pipeline execution.\n\n' +
					'Why this matters: The sprint analysis could not be completed.';
				actionButtons = ['View Logs', 'Retry'];
			}

			const action = await vscode.window.showErrorMessage(
				`‚ùå Pipeline Failed\n\n${explanation}\n\nError: ${result.error}`,
				...actionButtons
			);

			if (action === 'Create Agent') {
				await vscode.commands.executeCommand('aetherlight.createAgent');
			} else if (action === 'Open Sprint File') {
				const doc = await vscode.workspace.openTextDocument(sprintPath);
				await vscode.window.showTextDocument(doc);
			} else if (action === 'View Logs') {
				const logger = (await import('../services/MiddlewareLogger')).MiddlewareLogger.getInstance();
				logger.show();
			} else if (action === 'Retry') {
				await analyzeAndPlan();
			}
		}

	} catch (error: any) {
		// Handle TOML parse errors specially (MID-018)
		if (error.details?.file && error.details?.line) {
			// TOML parse error with line number - show helpful message with action buttons
			const action = await vscode.window.showErrorMessage(
				`‚ùå TOML Parse Error at line ${error.details.line}\n\n${error.details.message}\n\nFile: ${path.basename(error.details.file)}`,
				'Open File',
				'Validate TOML'
			);

			if (action === 'Open File') {
				// Open file and jump to error line
				const doc = await vscode.workspace.openTextDocument(error.details.file);
				const editor = await vscode.window.showTextDocument(doc);

				// Jump to error line (line numbers are 0-indexed in VS Code API)
				const line = Math.max(0, error.details.line - 1);
				const position = new vscode.Position(line, error.details.column || 0);
				editor.selection = new vscode.Selection(position, position);
				editor.revealRange(new vscode.Range(position, position), vscode.TextEditorRevealType.InCenter);
			} else if (action === 'Validate TOML') {
				// Open TOML validator in browser
				vscode.env.openExternal(vscode.Uri.parse('https://www.toml-lint.com/'));
			}
		} else {
			// Generic error (MID-023: Enhanced with actions)
			const action = await vscode.window.showErrorMessage(
				`‚ùå Analyze & Plan Failed\n\n` +
				`An unexpected error occurred: ${error.message}\n\n` +
				`Why this matters: The sprint analysis could not be completed. This may be due to:\n` +
				`‚Ä¢ Invalid sprint file structure\n` +
				`‚Ä¢ Missing dependencies\n` +
				`‚Ä¢ Permission issues`,
				'View Logs',
				'Report Issue'
			);

			if (action === 'View Logs') {
				const logger = (await import('../services/MiddlewareLogger')).MiddlewareLogger.getInstance();
				logger.show();
			} else if (action === 'Report Issue') {
				vscode.env.openExternal(vscode.Uri.parse('https://github.com/anthropics/aetherlight/issues/new'));
			}
		}
	}
}

/**
 * Register analyze and plan command
 *
 * DESIGN DECISION: Register as aetherlight.analyzeAndPlan
 * WHY: Consistent with other aetherlight.* commands
 */
export function registerAnalyzeAndPlanCommand(context: vscode.ExtensionContext): void {
	const disposable = vscode.commands.registerCommand('aetherlight.analyzeAndPlan', analyzeAndPlan);
	context.subscriptions.push(disposable);
}
