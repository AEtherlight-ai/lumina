# Enhanced Prompt: ENHANCE-001.3 - Complex Context Builders

**Task ID:** ENHANCE-001.3
**Sprint:** 17.1-BUGS
**Phase:** ai-enhancement-normalization
**Agent:** infrastructure-agent
**Template Version:** MVP-003-PromptEnhancer-TaskTemplate-v1.4.3
**Estimated Time:** 4-5 hours
**Estimated Lines:** 400

---

## Executive Summary

Implement 2 complex context builders (TaskContextBuilder, CodeAnalyzerContextBuilder) that implement the IContextBuilder interface. These builders gather comprehensive context with advanced features like temporal drift detection, dependency validation, workspace analysis, and complexity metrics.

**Complexity Level:** HIGH - These builders coordinate multiple subsystems (TOML, git, file system, pattern library).

**Key Deliverables:**
1. TaskContextBuilder (~200 lines) - TOML loading, dependency validation, temporal drift detection, file/pattern validation
2. CodeAnalyzerContextBuilder (~200 lines) - Workspace analysis, 30-day git history, complexity metrics, semantic pattern search
3. Integration with universal handler from ENHANCE-001.1
4. Unit tests (90% coverage) with extensive mocking

---

## Step 0: MANDATORY Pre-Task Analysis (Pattern-TASK-ANALYSIS-001)

**YOU MUST COMPLETE THIS ANALYSIS OUT LOUD BEFORE PROCEEDING.**

### 1. What is the EXACT task?
Implement 2 complex context builders that transform sprint tasks and code analysis requests into normalized EnhancementContext. Each builder must:
- Implement IContextBuilder interface (build method)
- Return EnhancementContext with all 5 required fields
- Gather extensive context (TOML data, git history, files, patterns, workspace structure)
- Perform validation (dependencies, temporal drift, file existence, pattern applicability)
- Work with the universal handler from ENHANCE-001.1

### 2. What are the explicit acceptance criteria?
**TaskContextBuilder:**
- ‚úÖ Loads task from TOML via SprintLoader
- ‚úÖ Validates all dependencies (checks status: completed vs pending)
- ‚úÖ Detects temporal drift (git diff since task created)
- ‚úÖ Validates files_to_modify exist in workspace
- ‚úÖ Validates patterns still apply to current codebase
- ‚úÖ Finds related tasks (overlapping files)
- ‚úÖ Returns EnhancementContext with high confidence if validation passes

**CodeAnalyzerContextBuilder:**
- ‚úÖ Analyzes workspace structure (languages, frameworks, directories)
- ‚úÖ Analyzes git history (last 30 days of commits)
- ‚úÖ Calculates complexity metrics (LOC, file count)
- ‚úÖ Performs semantic pattern search (5-10 relevant patterns)
- ‚úÖ Identifies user focus areas (performance, security, etc.)
- ‚úÖ Returns EnhancementContext with workspace insights

**Both:**
- ‚úÖ Integration tests: Button ‚Üí Builder ‚Üí AIEnhancementService ‚Üí Text Area
- ‚úÖ 90% test coverage

### 3. What files will I need to read/modify/create?
**READ (understand existing systems):**
- `vscode-lumina/src/interfaces/IContextBuilder.ts` (interface contract)
- `vscode-lumina/src/types/EnhancementContext.ts` (return type)
- `vscode-lumina/src/commands/SprintLoader.ts` (TOML loading logic)
- `vscode-lumina/src/services/PromptEnhancer.ts` (workspace analysis patterns)
- `vscode-lumina/src/services/TaskPromptExporter.ts` (current task enhancement logic)

**CREATE (new implementations):**
- `vscode-lumina/src/services/enhancement/TaskContextBuilder.ts`
- `vscode-lumina/src/services/enhancement/CodeAnalyzerContextBuilder.ts`
- `vscode-lumina/test/unit/services/enhancement/TaskContextBuilder.test.ts`
- `vscode-lumina/test/unit/services/enhancement/CodeAnalyzerContextBuilder.test.ts`

**MODIFY (wire up to universal handler):**
- `vscode-lumina/src/commands/voicePanel.ts` (update startNextTask and analyzeCodeEnhance handlers)

### 4. What dependencies exist?
- **Depends on:** ENHANCE-001.2 (simple builders validated architecture)
- **Uses:** SprintLoader (TOML loading), PromptEnhancer (workspace analysis), TemplateTaskBuilder (template creation)
- **Blocks:** ENHANCE-001.4 (Sprint Planner waits for complex builders)
- **Zero runtime npm dependencies** (Pattern-PUBLISH-003)

### 5. What could go wrong?
- TOML parsing fails (malformed sprint file) ‚Üí Return error with clear message
- Task ID not found in sprint ‚Üí Return error "Task {id} not found"
- Git commands fail (no git, empty repo) ‚Üí Provide context without git data
- Files don't exist (renamed/deleted) ‚Üí Report in validation warnings
- Patterns no longer apply ‚Üí Report in validation warnings
- Workspace analysis slow (large codebase) ‚Üí Implement timeout and partial results
- Complexity calculation expensive ‚Üí Use sampling for large codebases

### 6. What patterns/protocols apply?
- ‚úÖ Pattern-TASK-ANALYSIS-001 (this step)
- ‚úÖ Pattern-CODE-001 (announce before writing code)
- ‚úÖ Pattern-GIT-001 (git status check)
- ‚úÖ Pattern-TDD-001 (tests FIRST - RED ‚Üí GREEN ‚Üí REFACTOR)
- ‚úÖ Pattern-TRACKING-001 (TodoWrite for progress)
- ‚úÖ Pattern-COMPLETION-001 (post-completion documentation)
- ‚úÖ Pattern-STRATEGY-001 (strategy pattern for pluggable builders)

### 7. How will I verify success?
- All tests pass (90% coverage)
- Integration test: Start This Task ‚Üí TaskContextBuilder ‚Üí AI ‚Üí Enhanced prompt with dependency status
- Integration test: Code Analyzer ‚Üí CodeAnalyzerContextBuilder ‚Üí AI ‚Üí Enhanced prompt with workspace insights
- Temporal drift detection identifies commits since task created
- File validation catches missing files
- Complexity metrics accurate
- TypeScript compiles with no errors
- Performance < 2 seconds

### 8. Estimated time: 4-5 hours

---

## Step 1: Git Status Check (Pattern-GIT-001)

**Check current branch and uncommitted changes:**
```bash
git status
```

**Verify on correct branch:** `feature/v0.17.2-bug-fixes`

---

## Step 2: TDD - Write Tests FIRST (RED Phase)

Following Pattern-TDD-001, write tests BEFORE implementation. This is MANDATORY for infrastructure tasks.

### Test 1: TaskContextBuilder Tests

**File:** `vscode-lumina/test/unit/services/enhancement/TaskContextBuilder.test.ts`

**Test Cases:**
1. ‚úÖ `should implement IContextBuilder interface`
2. ‚úÖ `should load task from TOML via SprintLoader`
3. ‚úÖ `should return EnhancementContext with all required fields`
4. ‚úÖ `should set type to 'task'`
5. ‚úÖ `should validate all dependencies (check completed status)`
6. ‚úÖ `should detect temporal drift (git diff since task created)`
7. ‚úÖ `should validate files_to_modify exist`
8. ‚úÖ `should validate patterns still apply`
9. ‚úÖ `should find related tasks (overlapping files)`
10. ‚úÖ `should set confidence HIGH when all validations pass`
11. ‚úÖ `should set confidence MEDIUM when some validations fail`
12. ‚úÖ `should set confidence LOW when many validations fail`
13. ‚úÖ `should handle task not found error`
14. ‚úÖ `should handle git command failures gracefully`
15. ‚úÖ `should populate specificContext with dependency status`

**Mock Setup:**
```typescript
// Mock SprintLoader
jest.mock('../../../src/commands/SprintLoader', () => ({
  SprintLoader: jest.fn().mockImplementation(() => ({
    loadSprintTasks: jest.fn().mockResolvedValue([mockTask]),
    getTask: jest.fn().mockResolvedValue(mockTask)
  }))
}));

// Mock task data
const mockTask: SprintTask = {
  id: 'TEST-001',
  name: 'Implement user authentication',
  description: 'Add JWT authentication',
  phase: 'implementation',
  status: 'pending',
  agent: 'developer',
  dependencies: ['TEST-000'],
  files_to_modify: ['src/auth.ts', 'src/middleware.ts'],
  patterns: ['Pattern-AUTH-001', 'Pattern-TDD-001'],
  estimated_time: '2h'
};

// Mock git commands
jest.mock('child_process', () => ({
  execSync: jest.fn((cmd: string) => {
    if (cmd.includes('git log')) {
      return Buffer.from('abc123|feat: Add login endpoint|2025-11-10');
    }
    if (cmd.includes('git diff')) {
      return Buffer.from('src/auth.ts modified');
    }
    return Buffer.from('');
  })
}));
```

### Test 2: CodeAnalyzerContextBuilder Tests

**File:** `vscode-lumina/test/unit/services/enhancement/CodeAnalyzerContextBuilder.test.ts`

**Test Cases:**
1. ‚úÖ `should implement IContextBuilder interface`
2. ‚úÖ `should return EnhancementContext with all required fields`
3. ‚úÖ `should set type to 'code_analyzer'`
4. ‚úÖ `should analyze workspace structure (languages, frameworks)`
5. ‚úÖ `should analyze git history (last 30 days)`
6. ‚úÖ `should calculate complexity metrics (LOC, file count)`
7. ‚úÖ `should perform semantic pattern search`
8. ‚úÖ `should identify user focus areas from input`
9. ‚úÖ `should handle empty workspace gracefully`
10. ‚úÖ `should handle git command failures gracefully`
11. ‚úÖ `should timeout long-running operations (>2s)`
12. ‚úÖ `should populate specificContext with workspace insights`

**Mock Setup:**
```typescript
// Mock workspace
jest.mock('vscode', () => ({
  workspace: {
    workspaceFolders: [{
      uri: { fsPath: '/test/workspace' }
    }],
    findFiles: jest.fn().mockResolvedValue([
      { fsPath: '/test/workspace/src/index.ts' },
      { fsPath: '/test/workspace/src/auth.ts' }
    ])
  }
}));

// Mock git history
jest.mock('child_process', () => ({
  execSync: jest.fn((cmd: string) => {
    if (cmd.includes('git log')) {
      return Buffer.from('abc123|feat: Add auth|2025-11-10\nxyz789|fix: Login bug|2025-11-12');
    }
    return Buffer.from('');
  })
}));
```

**Run tests to confirm RED phase:**
```bash
cd vscode-lumina && npm test
```

**Expected Result:** All tests FAIL (no implementation yet) ‚úÖ

---

## Step 3: Create TaskContextBuilder (GREEN Phase)

**File:** `vscode-lumina/src/services/enhancement/TaskContextBuilder.ts`

**Implementation Strategy:**

### Core Architecture:
```typescript
export class TaskContextBuilder implements IContextBuilder {
  private sprintLoader: SprintLoader;
  private workspaceRoot: string;

  constructor(context: vscode.ExtensionContext) {
    this.sprintLoader = new SprintLoader(context);
    this.workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || '';
  }

  async build(input: { taskId: string }): Promise<EnhancementContext> {
    // Step 1: Load task from TOML
    const task = await this.loadTask(input.taskId);

    // Step 2: Validate dependencies
    const dependencyStatus = await this.validateDependencies(task.dependencies);

    // Step 3: Detect temporal drift
    const temporalDrift = await this.detectTemporalDrift(task);

    // Step 4: Validate files
    const fileValidation = await this.validateFiles(task.files_to_modify);

    // Step 5: Validate patterns
    const patternValidation = await this.validatePatterns(task.patterns);

    // Step 6: Find related tasks
    const relatedTasks = await this.findRelatedTasks(task);

    // Step 7: Calculate confidence
    const confidence = this.calculateConfidence(
      dependencyStatus,
      temporalDrift,
      fileValidation,
      patternValidation
    );

    // Step 8: Build EnhancementContext
    return this.buildContext(task, {
      dependencyStatus,
      temporalDrift,
      fileValidation,
      patternValidation,
      relatedTasks,
      confidence
    });
  }
}
```

### Key Methods:

**1. Load Task:**
```typescript
private async loadTask(taskId: string): Promise<SprintTask> {
  const tasks = await this.sprintLoader.loadSprintTasks();
  const task = tasks.find(t => t.id === taskId);

  if (!task) {
    throw new Error(`Task ${taskId} not found in active sprint`);
  }

  return task;
}
```

**2. Validate Dependencies:**
```typescript
private async validateDependencies(dependencies: string[]): Promise<DependencyStatus> {
  const allTasks = await this.sprintLoader.loadSprintTasks();
  const status: DependencyStatus = {
    total: dependencies.length,
    completed: 0,
    pending: 0,
    missing: [],
    blocking: []
  };

  for (const depId of dependencies) {
    const depTask = allTasks.find(t => t.id === depId);

    if (!depTask) {
      status.missing.push(depId);
    } else if (depTask.status === 'completed') {
      status.completed++;
    } else {
      status.pending++;
      status.blocking.push(depId);
    }
  }

  return status;
}
```

**3. Detect Temporal Drift:**
```typescript
private async detectTemporalDrift(task: SprintTask): Promise<TemporalDriftAnalysis> {
  // Get task creation date (from git or task field)
  const taskCreatedDate = this.getTaskCreationDate(task);

  // Run git log since task created
  const gitCommand = `git log --since="${taskCreatedDate}" --format="%H|%s|%ai" -- ${task.files_to_modify?.join(' ')}`;

  try {
    const output = execSync(gitCommand, {
      cwd: this.workspaceRoot,
      encoding: 'utf-8'
    });

    const commits = this.parseGitLog(output);

    return {
      commitsSinceCreation: commits.length,
      filesModified: this.extractModifiedFiles(commits),
      potentialConflicts: this.detectConflicts(commits, task.files_to_modify),
      driftLevel: commits.length > 5 ? 'high' : commits.length > 2 ? 'medium' : 'low'
    };
  } catch (error) {
    console.warn('[TaskContextBuilder] Git temporal drift detection failed:', error);
    return {
      commitsSinceCreation: 0,
      filesModified: [],
      potentialConflicts: [],
      driftLevel: 'unknown'
    };
  }
}
```

**4. Validate Files:**
```typescript
private async validateFiles(files: string[] | undefined): Promise<FileValidation> {
  if (!files || files.length === 0) {
    return { allExist: true, existing: [], missing: [], renamed: [] };
  }

  const validation: FileValidation = {
    allExist: true,
    existing: [],
    missing: [],
    renamed: []
  };

  for (const file of files) {
    const filePath = path.join(this.workspaceRoot, file);

    if (fs.existsSync(filePath)) {
      validation.existing.push(file);
    } else {
      validation.missing.push(file);
      validation.allExist = false;

      // Try to detect renamed files
      const renamed = await this.detectRenamedFile(file);
      if (renamed) {
        validation.renamed.push({ old: file, new: renamed });
      }
    }
  }

  return validation;
}
```

**5. Validate Patterns:**
```typescript
private async validatePatterns(patterns: string[] | undefined): Promise<PatternValidation> {
  if (!patterns || patterns.length === 0) {
    return { allApply: true, applicable: [], notApplicable: [] };
  }

  const validation: PatternValidation = {
    allApply: true,
    applicable: [],
    notApplicable: []
  };

  // Search codebase for pattern references
  for (const pattern of patterns) {
    const patternFiles = await vscode.workspace.findFiles(
      `**/*.{ts,js,md}`,
      '**/node_modules/**'
    );

    let found = false;
    for (const file of patternFiles) {
      const content = fs.readFileSync(file.fsPath, 'utf-8');
      if (content.includes(pattern)) {
        found = true;
        break;
      }
    }

    if (found) {
      validation.applicable.push(pattern);
    } else {
      validation.notApplicable.push(pattern);
      validation.allApply = false;
    }
  }

  return validation;
}
```

**6. Calculate Confidence:**
```typescript
private calculateConfidence(
  deps: DependencyStatus,
  drift: TemporalDriftAnalysis,
  files: FileValidation,
  patterns: PatternValidation
): ConfidenceScore {
  let score = 100;

  // Reduce confidence for blocking dependencies
  score -= deps.blocking.length * 10;

  // Reduce confidence for temporal drift
  if (drift.driftLevel === 'high') score -= 20;
  else if (drift.driftLevel === 'medium') score -= 10;

  // Reduce confidence for missing files
  score -= files.missing.length * 15;

  // Reduce confidence for non-applicable patterns
  score -= patterns.notApplicable.length * 5;

  score = Math.max(0, Math.min(100, score));

  return {
    score,
    level: score >= 70 ? 'high' : score >= 40 ? 'medium' : 'low'
  };
}
```

---

## Step 4: Create CodeAnalyzerContextBuilder (GREEN Phase)

**File:** `vscode-lumina/src/services/enhancement/CodeAnalyzerContextBuilder.ts`

**Implementation Strategy:**

### Core Architecture:
```typescript
export class CodeAnalyzerContextBuilder implements IContextBuilder {
  private workspaceRoot: string;

  constructor(context: vscode.ExtensionContext) {
    this.workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || '';
  }

  async build(input: { focusAreas?: string[] }): Promise<EnhancementContext> {
    // Step 1: Analyze workspace structure
    const workspaceAnalysis = await this.analyzeWorkspace();

    // Step 2: Analyze git history (30 days)
    const gitHistory = await this.analyzeGitHistory(30);

    // Step 3: Calculate complexity metrics
    const complexity = await this.calculateComplexity();

    // Step 4: Semantic pattern search
    const patterns = await this.searchPatterns(input.focusAreas);

    // Step 5: Calculate confidence
    const confidence = this.calculateConfidence(workspaceAnalysis, gitHistory);

    // Step 6: Build EnhancementContext
    return this.buildContext({
      workspaceAnalysis,
      gitHistory,
      complexity,
      patterns,
      focusAreas: input.focusAreas || [],
      confidence
    });
  }
}
```

### Key Methods:

**1. Analyze Workspace:**
```typescript
private async analyzeWorkspace(): Promise<WorkspaceAnalysis> {
  const files = await vscode.workspace.findFiles(
    '**/*',
    '**/node_modules/**',
    1000
  );

  const languages = new Set<string>();
  const frameworks = new Set<string>();
  const directories = new Set<string>();

  // Detect languages from extensions
  files.forEach(file => {
    const ext = path.extname(file.fsPath);
    const langMap: Record<string, string> = {
      '.ts': 'TypeScript',
      '.tsx': 'TypeScript/React',
      '.js': 'JavaScript',
      '.jsx': 'JavaScript/React',
      '.py': 'Python',
      '.rs': 'Rust'
    };
    if (langMap[ext]) languages.add(langMap[ext]);

    // Track directories
    const dir = path.dirname(file.fsPath).split(path.sep).pop();
    if (dir) directories.add(dir);
  });

  // Detect frameworks from package.json
  const packageJsonPath = path.join(this.workspaceRoot, 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
    const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };

    if (deps['react']) frameworks.add('React');
    if (deps['vue']) frameworks.add('Vue');
    if (deps['express']) frameworks.add('Express');
    if (deps['vscode']) frameworks.add('VS Code Extension');
  }

  return {
    languages: Array.from(languages),
    frameworks: Array.from(frameworks),
    directories: Array.from(directories),
    fileCount: files.length
  };
}
```

**2. Analyze Git History:**
```typescript
private async analyzeGitHistory(days: number): Promise<GitHistoryAnalysis> {
  const since = new Date();
  since.setDate(since.getDate() - days);
  const sinceStr = since.toISOString().split('T')[0];

  const gitCommand = `git log --since="${sinceStr}" --format="%H|%an|%s|%ai" --numstat`;

  try {
    const output = execSync(gitCommand, {
      cwd: this.workspaceRoot,
      encoding: 'utf-8'
    });

    const commits = this.parseGitLogWithStats(output);
    const contributors = new Set(commits.map(c => c.author));
    const filesChanged = new Set<string>();

    commits.forEach(c => {
      c.filesChanged.forEach(f => filesChanged.add(f));
    });

    return {
      totalCommits: commits.length,
      contributors: Array.from(contributors),
      filesChanged: Array.from(filesChanged),
      commits: commits.slice(0, 10) // Top 10 recent
    };
  } catch (error) {
    console.warn('[CodeAnalyzerContextBuilder] Git history analysis failed:', error);
    return {
      totalCommits: 0,
      contributors: [],
      filesChanged: [],
      commits: []
    };
  }
}
```

**3. Calculate Complexity:**
```typescript
private async calculateComplexity(): Promise<ComplexityMetrics> {
  const files = await vscode.workspace.findFiles(
    '**/*.{ts,js,tsx,jsx}',
    '**/node_modules/**',
    500
  );

  let totalLOC = 0;
  const fileSizes: { file: string; loc: number }[] = [];

  for (const file of files) {
    try {
      const content = fs.readFileSync(file.fsPath, 'utf-8');
      const loc = content.split('\n').filter(line => line.trim().length > 0).length;
      totalLOC += loc;

      fileSizes.push({
        file: path.relative(this.workspaceRoot, file.fsPath),
        loc
      });
    } catch (error) {
      // Skip unreadable files
    }
  }

  // Sort by size descending
  fileSizes.sort((a, b) => b.loc - a.loc);

  return {
    totalLOC,
    averageLOCPerFile: Math.round(totalLOC / files.length),
    largestFiles: fileSizes.slice(0, 10),
    fileCount: files.length,
    complexityLevel: totalLOC > 10000 ? 'high' : totalLOC > 5000 ? 'medium' : 'low'
  };
}
```

**4. Semantic Pattern Search:**
```typescript
private async searchPatterns(focusAreas?: string[]): Promise<string[]> {
  // Map focus areas to pattern categories
  const patternMap: Record<string, string[]> = {
    'performance': ['Pattern-PERF-001', 'Pattern-CACHE-001', 'Pattern-OPTIMIZE-001'],
    'security': ['Pattern-SECURITY-001', 'Pattern-AUTH-001', 'Pattern-VALIDATION-001'],
    'testing': ['Pattern-TDD-001', 'Pattern-INTEGRATION-001', 'Pattern-E2E-001'],
    'architecture': ['Pattern-STRATEGY-001', 'Pattern-FACTORY-001', 'Pattern-OBSERVER-001']
  };

  const patterns = new Set<string>();

  if (focusAreas && focusAreas.length > 0) {
    focusAreas.forEach(area => {
      const areaPatterns = patternMap[area.toLowerCase()];
      if (areaPatterns) {
        areaPatterns.forEach(p => patterns.add(p));
      }
    });
  }

  // Also search for patterns already used in codebase
  const files = await vscode.workspace.findFiles(
    '**/*.{ts,js,md}',
    '**/node_modules/**',
    100
  );

  for (const file of files) {
    try {
      const content = fs.readFileSync(file.fsPath, 'utf-8');
      const matches = content.match(/Pattern-[A-Z]+-\d+/g);
      if (matches) {
        matches.forEach(p => patterns.add(p));
      }
    } catch (error) {
      // Skip unreadable files
    }
  }

  return Array.from(patterns).slice(0, 10); // Top 10
}
```

---

## Step 5: Wire Up to Universal Handler (GREEN Phase)

**File:** `vscode-lumina/src/commands/voicePanel.ts`

**Update Start This Task Handler (case 'startNextTask'):**

```typescript
// Find around line 746
case 'startNextTask':
  {
    const nextTask = this.taskStarter.findNextReadyTask(this.sprintTasks);
    if (!nextTask) {
      vscode.window.showWarningMessage('No ready tasks available.');
      break;
    }

    try {
      // NEW: Use TaskContextBuilder with universal handler
      const { TaskContextBuilder } = await import('../services/enhancement/TaskContextBuilder');
      const taskBuilder = new TaskContextBuilder(this._context);

      await this.handleEnhancement(
        'Task',
        { taskId: nextTask.id },
        taskBuilder,
        webview
      );
    } catch (error) {
      console.error('[√ÜtherLight] Task enhancement failed:', error);
      vscode.window.showErrorMessage(`Failed to enhance task: ${(error as Error).message}`);
    }
  }
  break;
```

**Update Code Analyzer Handler (case 'analyzeCodeEnhance'):**

```typescript
// Find around line 1192
case 'analyzeCodeEnhance':
  try {
    // NEW: Use CodeAnalyzerContextBuilder with universal handler
    const { CodeAnalyzerContextBuilder } = await import('../services/enhancement/CodeAnalyzerContextBuilder');
    const analyzerBuilder = new CodeAnalyzerContextBuilder(this._context);

    await this.handleEnhancement(
      'Code Analyzer',
      { focusAreas: message.focusAreas || [] },
      analyzerBuilder,
      webview
    );
  } catch (error) {
    console.error('[√ÜtherLight] Code analyzer enhancement failed:', error);
    vscode.window.showErrorMessage(`Failed to enhance code analyzer: ${(error as Error).message}`);
  }
  break;
```

---

## Step 6: Verify Tests Pass (GREEN Phase Complete)

**Run tests:**
```bash
cd vscode-lumina && npm run compile
cd vscode-lumina && npm test
```

**Expected Results:**
- ‚úÖ All TaskContextBuilder tests pass (15 tests)
- ‚úÖ All CodeAnalyzerContextBuilder tests pass (12 tests)
- ‚úÖ Integration tests pass (2 end-to-end flows)
- ‚úÖ Coverage ‚â• 90%

---

## Step 7: REFACTOR Phase (Optimize Performance)

**Performance Target:** Context building < 2 seconds

**Optimization Strategies:**

1. **Parallel Operations:**
```typescript
// Run independent operations in parallel
const [deps, drift, files, patterns] = await Promise.all([
  this.validateDependencies(task.dependencies),
  this.detectTemporalDrift(task),
  this.validateFiles(task.files_to_modify),
  this.validatePatterns(task.patterns)
]);
```

2. **Git Operation Caching:**
```typescript
private gitCache: Map<string, any> = new Map();

private async cachedGitOperation(key: string, operation: () => Promise<any>): Promise<any> {
  if (this.gitCache.has(key)) {
    return this.gitCache.get(key);
  }

  const result = await operation();
  this.gitCache.set(key, result);
  return result;
}
```

3. **File Operation Batching:**
```typescript
// Check all files in single operation
const fileChecks = files.map(f => ({
  file: f,
  exists: fs.existsSync(path.join(this.workspaceRoot, f))
}));
```

4. **Timeout Protection:**
```typescript
private async withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T | null> {
  const timeoutPromise = new Promise<null>((resolve) => {
    setTimeout(() => resolve(null), timeoutMs);
  });

  return Promise.race([promise, timeoutPromise]);
}
```

---

## Step 8: Integration Testing (Manual Validation)

**Test in VS Code Extension Host (F5):**

### Test 1: Task Enhancement
1. Open Voice Panel
2. Click "Start Next Task"
3. **Verify:** Loading notification
4. **Verify:** Enhanced prompt includes:
   - Dependency status (completed/pending/blocking)
   - Temporal drift warnings if applicable
   - File validation results
   - Pattern applicability
   - Related tasks
5. **Verify:** Confidence score accurate
6. **Verify:** Performance < 2 seconds

### Test 2: Code Analyzer Enhancement
1. Navigate to Code Analyzer section
2. Select focus areas: "Performance", "Security"
3. Click "Enhance"
4. **Verify:** Enhanced prompt includes:
   - Workspace structure (languages, frameworks)
   - Git history (30 days)
   - Complexity metrics
   - Relevant patterns (PERF, SECURITY)
5. **Verify:** Performance < 2 seconds

---

## Step N-2: Update Sprint TOML Completion Notes (BEFORE Commit)

Add completion_notes to ENHANCE-001.3, mark as completed, add completion date.

---

## Step N-1: Commit Changes

```bash
git add vscode-lumina/src/services/enhancement/
git add vscode-lumina/test/unit/services/enhancement/
git add vscode-lumina/src/commands/voicePanel.ts
git add internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml

git commit -m "feat(ENHANCE-001.3): Implement complex context builders (Task, Code Analyzer)

2 Complex Context Builders:
- TaskContextBuilder (TOML loading, dependency validation, temporal drift)
- CodeAnalyzerContextBuilder (workspace analysis, git history, complexity)

Key Features:
- Temporal drift detection (commits since task created)
- Dependency validation (blocking vs completed)
- File validation (existence + renamed file detection)
- Pattern validation (applicability check)
- Workspace analysis (languages, frameworks, structure)
- Complexity metrics (LOC, file count, large files)
- 30-day git history analysis

Performance:
- Parallel operations (Promise.all for independent tasks)
- Git caching (avoid repeated commands)
- Timeout protection (2s max)
- Both builders < 2s ‚úÖ

Tests (TDD):
- 27 test cases (15 + 12)
- 92% average coverage
- Extensive mocking (SprintLoader, git, fs)

Integration:
- Updated startNextTask handler
- Updated analyzeCodeEnhance handler
- Both use universal handler from ENHANCE-001.1

Patterns: Pattern-TDD-001, Pattern-STRATEGY-001, Pattern-CODE-001

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

---

## Key Reminders

### ‚ö†Ô∏è CRITICAL - Complexity Management:
These builders are COMPLEX. Break down into small, testable methods. Each method should do ONE thing.

### ‚ö†Ô∏è CRITICAL - Error Handling:
Never throw errors that break the flow. Always provide context with warnings. User should get enhanced prompt even if some context gathering fails.

### ‚ö†Ô∏è CRITICAL - Performance:
Use `Promise.all()` aggressively. Git operations are slow - run them in parallel. Cache results. Implement timeouts.

### ‚ö†Ô∏è CRITICAL - Temporal Drift:
This is a KEY feature. If task created 2 weeks ago and files modified since, AI must know. Prevents working on stale specifications.

---

## Success Criteria Checklist

- [ ] TaskContextBuilder loads tasks from TOML
- [ ] Dependency validation works (blocking deps detected)
- [ ] Temporal drift detection works (commits since task created)
- [ ] File validation catches missing files
- [ ] Pattern validation confirms applicability
- [ ] CodeAnalyzerContextBuilder analyzes workspace
- [ ] Git history includes 30 days of commits
- [ ] Complexity metrics accurate
- [ ] Semantic pattern search returns relevant patterns
- [ ] All tests pass (90%+ coverage)
- [ ] Performance < 2 seconds
- [ ] Integration tests successful
- [ ] Sprint TOML updated

---

**END OF ENHANCED PROMPT**

Follow step-by-step. Use TodoWrite for tracking. Good luck! üöÄ
