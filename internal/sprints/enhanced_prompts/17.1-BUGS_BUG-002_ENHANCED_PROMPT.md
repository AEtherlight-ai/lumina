# Enhanced Task Prompt: BUG-002

**Generated**: 2025-01-12
**Sprint**: ACTIVE_SPRINT_17.1_BUGS
**Task ID**: BUG-002
**Status**: pending
**Agent**: tauri-desktop-agent
**Enhanced Prompt**: internal/sprints/enhanced_prompts/BUG-002_ENHANCED_PROMPT.md
**Template**: MVP-003-PromptEnhancer-TaskTemplate-v1.4.2

---

## ‚ö†Ô∏è MANDATORY: Pre-Task Analysis (Pattern-TASK-ANALYSIS-001)

**STOP. Before reading ANY code or writing ANY solution, complete this 8-step analysis OUT LOUD:**

### 8-Step Pre-Task Analysis

1. ‚úÖ **Understand the Problem**
   - What is broken? Desktop app has no license activation flow - users cannot enter license keys
   - What are the symptoms? First-time users see "License key not configured" error with no way to fix it

2. ‚úÖ **Identify Root Cause**
   - Why is it broken? License validation system was never implemented - only field exists in settings
   - Is this a symptom of a deeper problem? No - this is a missing feature, not a bug

3. ‚úÖ **Define Success Criteria**
   - How do I know when it's fixed? First launch shows activation dialog, valid keys activate successfully, user_id/device_id/tier stored
   - What does "done" look like? Users can activate desktop app with dashboard license key and start using voice capture

4. ‚úÖ **List Dependencies**
   - What other tasks/files/systems does this affect?
     - ‚úÖ BUG-002A: TranscriptionResponse token migration (completed)
     - ‚úÖ BUG-002B: Bearer authentication (completed)
     - ‚úÖ BUG-002C: License format validation (completed - false bug)
     - ‚úÖ BUG-003: AppSettings fields (completed - user_id, device_id, tier fields added)
   - What needs to be done first? All dependencies complete ‚úÖ
   - What does this unblock? Full desktop app activation flow, user onboarding

5. ‚úÖ **Estimate Complexity**
   - Simple fix (< 1 hour) or complex refactor (> 4 hours)? Complex implementation (6-8 hours, 400 lines)
   - Single file or multi-file change? Multi-file (auth.rs new file, main.rs updates, LicenseActivationDialog.tsx new file, Cargo.toml dependencies)

6. ‚úÖ **Choose Approach**
   - What's the best way to solve this?
     1. Create auth.rs module for license validation logic
     2. Add device fingerprint generation (OS + CPU + MAC hash)
     3. Implement validate_license_key() calling POST /api/license/validate
     4. Add activate_license() Tauri command
     5. Create frontend LicenseActivationDialog.tsx
     6. Add first-launch detection in main.rs
     7. Write comprehensive tests (TDD approach)
   - Are there alternative approaches? Could embed validation in main.rs, but separate module is cleaner
   - Why is this one best? Modularity, testability, separation of concerns

7. ‚úÖ **Identify Risks**
   - What could go wrong?
     - Device fingerprint might not be consistent across reboots
     - Network failures during validation
     - MAC address retrieval might fail on some systems
     - License key already activated on another device (403 error)
     - Invalid license key format (404 error)
   - What are the edge cases?
     - User has no network connection
     - API endpoint down (500 error)
     - Settings.json corrupted
     - License key copy-paste with extra whitespace

8. ‚úÖ **Plan Testing**
   - How will I validate this works?
     - Unit tests for device_fingerprint generation
     - Unit tests for license validation (mock API)
     - Integration tests with test license keys (CD7W-AJDK-RLQT-LUFA free tier, W7HD-X79Q-CQJ9-XW13 pro tier)
     - Manual testing: First launch ‚Üí activation dialog ‚Üí enter key ‚Üí activate ‚Üí verify settings.json
   - What tests need to be written? 8 unit tests (see test_requirements), 2 integration tests

### Code Workflow Announcement (Pattern-CODE-001)

**Before starting Step 1 (Implementation), announce OUT LOUD:**

"I am about to start coding for task BUG-002. I have completed:
‚úÖ Pattern-TASK-ANALYSIS-001 (8-step pre-task analysis - see above)
‚úÖ Ready to proceed with Pattern-GIT-001 (Git status check)
‚úÖ Ready to proceed with Pattern-TDD-001 (Write tests FIRST)
‚úÖ Ready to proceed with Pattern-TRACKING-001 (TodoWrite tracking)

I am now proceeding with implementation."

### Edge Case Handling

**MUST complete this section if:**
- ‚úÖ New feature ‚Üí MUST complete analysis + announcement + write test first

**This is a major new feature (license activation flow) - analysis + announcement + TDD required.**

---

## Task Overview

**Name**: Implement license validation flow on first launch

**Why**:
Missing Implementation: Desktop app has license_key field but no validation flow.

Current Behavior:
- User installs desktop app
- App launches without prompting for license key
- User presses hotkey ‚Üí Error: "License key not configured"
- User has no way to enter license key (no activation UI)

Expected Behavior (from documentation):
- First launch ‚Üí Check if license_key exists in settings
- If empty ‚Üí Show license key prompt (blocking UI)
- User enters license key from dashboard
- App calls POST /api/license/validate with device_fingerprint
- On success ‚Üí Store license_key + user_id + device_id + tier
- App continues to main interface

Impact: Users cannot activate desktop app, voice capture unusable.
Severity: CRITICAL - Desktop app completely non-functional for new users.

**Current State (BROKEN)**:
- File: `products/lumina-desktop/src-tauri/src/main.rs`
- Issue: AppSettings has license_key field but no activation flow
- Problem: First launch doesn't check for empty license_key or prompt user

**Required State (CORRECT)**:
- Files to create:
  - `products/lumina-desktop/src-tauri/src/auth.rs` (validation module)
  - `products/lumina-desktop/src/components/LicenseActivationDialog.tsx` (frontend UI)
- Files to modify:
  - `products/lumina-desktop/src-tauri/src/main.rs` (add startup logic)
  - `products/lumina-desktop/src-tauri/Cargo.toml` (add dependencies)
- Implementation:
  - generate_device_fingerprint() function (OS + CPU + MAC hash)
  - validate_license_key() function (calls POST /api/license/validate)
  - activate_license() Tauri command (frontend ‚Üí backend bridge)
  - First-launch detection in main()
  - LicenseActivationDialog component with input field

**Impact**:
- CRITICAL: Enables first-time users to activate desktop app
- UNBLOCKS: User onboarding flow
- ENABLES: Voice capture functionality for new users
- FIXES: "License key not configured" error with resolution path

**Severity**: CRITICAL (desktop app completely non-functional for new users)

---

## Context Gathered

### Git Status
- **Branch**: feature/v0.17.2-bug-fixes
- **Status**: Clean (as of last check)
- **Ready for**: BUG-002 implementation

### Sprint TOML
- **File**: `internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml`
- **Task Entry**: Lines 158-315
- **Management**: Use `/sprint-task-lifecycle` skill or manually update status field

### API Contract (Reference)

**License Validation API** (POST /api/license/validate):
```
Endpoint: POST /api/license/validate
Location: website/app/api/license/validate/route.ts
```

**Request Payload**:
```json
{
  "license_key": "XXXX-XXXX-XXXX-XXXX",
  "device_fingerprint": "sha256_hash_of_os_cpu_mac"
}
```

**Response (200 OK)**:
```json
{
  "valid": true,
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "device_id": "660e8400-e29b-41d4-a716-446655440001",
  "tier": "pro",
  "storage_limit_mb": 10000,
  "user_name": "John Doe",
  "message": "Device activated successfully"
}
```

**Error Responses**:
- 400: Missing required fields (license_key or device_fingerprint)
- 404: Invalid license key (key not found in database)
- 403: Already activated on another device (can only activate 1 device per key)
- 500: Server error (database or network issue)

### Dependencies (All Complete ‚úÖ)

1. **BUG-002A** (completed 2025-01-12) - TranscriptionResponse token migration
   - File: products/lumina-desktop/src-tauri/src/transcription.rs:33-41
   - Commit: 835ba2d
   - Status: ‚úÖ Token fields added to success responses

2. **BUG-002B** (completed 2025-11-11) - Bearer authentication
   - File: products/lumina-desktop/src-tauri/src/transcription.rs:177, 267
   - Commit: 88dbbba
   - Status: ‚úÖ Authorization header already correct (false bug report)

3. **BUG-002C** (completed 2025-11-12) - License format validation
   - Status: ‚úÖ False bug report - no validation exists (API validates)

4. **BUG-003** (completed 2025-11-12) - AppSettings fields
   - File: products/lumina-desktop/src-tauri/src/main.rs:86-121
   - Commit: 9afdb91
   - Status: ‚úÖ user_id, device_id, tier fields added to AppSettings struct

### Related Files

1. `products/lumina-desktop/src-tauri/src/auth.rs` - NEW FILE (**MUST CREATE**)
   - Will contain: generate_device_fingerprint(), validate_license_key()
   - Purpose: License validation logic module

2. `products/lumina-desktop/src-tauri/src/main.rs` - EXISTING FILE (**MUST UPDATE**)
   - Add: activate_license() Tauri command
   - Add: First-launch detection in main()
   - Lines to modify: ~50 lines (add command, startup logic)

3. `products/lumina-desktop/src/components/LicenseActivationDialog.tsx` - NEW FILE (**MUST CREATE**)
   - Will contain: Frontend activation UI with license key input
   - Purpose: User-facing activation dialog

4. `products/lumina-desktop/src-tauri/Cargo.toml` - EXISTING FILE (**MUST UPDATE**)
   - Add dependencies: sha2 (for hashing), mac_address (for device fingerprint)

5. `products/lumina-desktop/src-tauri/tests/auth_validation.rs` - NEW FILE (**MUST CREATE - TDD**)
   - Unit tests for license validation
   - Tests: validate_license_key() success, 404, 403, 400 cases

6. `products/lumina-desktop/src-tauri/tests/device_fingerprint.rs` - NEW FILE (**MUST CREATE - TDD**)
   - Unit tests for device fingerprint generation
   - Tests: consistency, OS inclusion, MAC inclusion

### Patterns Referenced

**MANDATORY Patterns**:
- **Pattern-TASK-ANALYSIS-001**: 8-step pre-task analysis (completed in Section 0)
- **Pattern-CODE-001**: Code workflow + announcement (completed in Section 0)
- **Pattern-TDD-001**: Test-driven development (write tests FIRST)
- **Pattern-TRACKING-001**: Task tracking + Sprint TOML lifecycle
- **Pattern-GIT-001**: Git workflow integration
- **Pattern-VALIDATION-001**: Pre-flight checklist enforcement
- **Pattern-COMPLETION-001**: Post-completion documentation (Section 12)

---

## Pre-Flight Checklist

**STOP. Complete Pattern-VALIDATION-001 checklist OUT LOUD:**

### Before Creating auth.rs:

1. ‚úÖ **Did I check if auth.rs already exists?**
   - If NO ‚Üí Glob for **/auth.rs first
   - Expected: Should NOT exist (new file)

2. ‚úÖ **Did I verify dependencies are not runtime npm dependencies?**
   - If NO ‚Üí Check Pattern-PUBLISH-003 whitelist
   - Expected: sha2 and mac_address are Rust crates (allowed)

3. ‚úÖ **Did I read the API contract documentation?**
   - If NO ‚Üí Check website/app/api/license/validate/route.ts
   - Expected: POST endpoint with license_key + device_fingerprint payload

4. ‚úÖ **Did I verify AppSettings has user_id, device_id, tier fields?**
   - If NO ‚Üí Read main.rs:86-121 to confirm BUG-003 completion
   - Expected: ‚úÖ BUG-003 completed (fields exist)

**If you answered NO to ANY question, STOP and complete it NOW.**

**Full Checklist**: Pattern-VALIDATION-001 (4 categories, 15+ questions in CLAUDE.md)

**Automated Validation**: Pre-commit hooks will run `cargo check` automatically

---

## Implementation Steps (TDD Approach)

**Patterns**: Pattern-TDD-001 (RED ‚Üí GREEN ‚Üí REFACTOR), Pattern-GIT-001 (Git workflow), Pattern-TRACKING-001 (Sprint TOML lifecycle)

**REMINDER**: If you haven't completed Section 0 (Pre-Task Analysis + Code Workflow Announcement), STOP and complete it NOW.

**Total Estimated Time**: 6-8 hours (400 lines of code)

**Implementation Order**: Tests FIRST (TDD), then implementation

---

### Step 0: Git Status + Sprint TOML Update (2 min)

**Update Sprint Status**:
```bash
/sprint-task-lifecycle start BUG-002
```

**Fallback** (if skill unavailable): Edit ACTIVE_SPRINT_17.1_BUGS.toml line 161: `status = "in_progress"`

**Check Git Status**:
```bash
git status
git branch --show-current
```

**Expected**:
- Branch: feature/v0.17.2-bug-fixes
- Status: Clean working tree
- Sprint TOML: BUG-002 status = "in_progress"

---

### Step 1: Add Rust Dependencies (5 min)

**Goal**: Add sha2 and mac_address crates to Cargo.toml

**Action**:
```bash
# Read current dependencies
Read products/lumina-desktop/src-tauri/Cargo.toml

# Add dependencies
Edit products/lumina-desktop/src-tauri/Cargo.toml
```

**Add to [dependencies] section**:
```toml
sha2 = "0.10"           # SHA-256 hashing for device fingerprint
mac_address = "1.1"     # MAC address retrieval for device fingerprint
```

**Validation**:
```bash
cd products/lumina-desktop/src-tauri
cargo check
```

**Expected**: Compiles successfully, downloads new dependencies

---

### Step 2: Write Device Fingerprint Tests (15 min - TDD RED Phase)

**Goal**: Write tests FIRST before implementing generate_device_fingerprint()

**Action**:
```bash
# Create test file
Write products/lumina-desktop/src-tauri/tests/device_fingerprint.rs
```

**Test Content**:
```rust
use lumina_desktop::auth::generate_device_fingerprint;

#[test]
fn test_fingerprint_consistency() {
    // Same device ‚Üí same fingerprint
    let fp1 = generate_device_fingerprint().unwrap();
    let fp2 = generate_device_fingerprint().unwrap();
    assert_eq!(fp1, fp2, "Fingerprint should be consistent");
}

#[test]
fn test_fingerprint_includes_os() {
    let fp = generate_device_fingerprint().unwrap();
    assert!(!fp.is_empty(), "Fingerprint should not be empty");
    assert!(fp.len() == 64, "SHA-256 fingerprint should be 64 hex chars");
}

#[test]
fn test_fingerprint_includes_mac() {
    let fp = generate_device_fingerprint().unwrap();
    // Fingerprint should be deterministic based on OS + CPU + MAC
    // If MAC changes, fingerprint changes
    assert!(fp.len() > 0);
}
```

**Run Tests (Expected: RED - tests fail, generate_device_fingerprint() doesn't exist yet)**:
```bash
cd products/lumina-desktop/src-tauri
cargo test device_fingerprint
```

**Expected Output**: Compilation error (auth module doesn't exist yet)

---

### Step 3: Create auth.rs Module (30 min - TDD GREEN Phase)

**Goal**: Implement generate_device_fingerprint() to pass tests

**Action**:
```bash
# Create auth module
Write products/lumina-desktop/src-tauri/src/auth.rs
```

**Module Content**:
```rust
//! License validation and device fingerprint module
//!
//! REASONING CHAIN:
//! 1. User activates desktop app with license key from dashboard
//! 2. Desktop app generates device_fingerprint (unique per device)
//! 3. Desktop app calls POST /api/license/validate with license_key + device_fingerprint
//! 4. API validates license key and associates it with device_fingerprint
//! 5. API returns user_id, device_id, tier (stored in AppSettings)
//! 6. Subsequent launches check if license_key exists (skip activation prompt)
//!
//! Device Fingerprint Components:
//! - OS name + version (std::env::consts::OS, sys_info::os_release)
//! - CPU architecture (std::env::consts::ARCH)
//! - MAC address (mac_address::get_mac_address)
//! - SHA-256 hash for privacy (don't send raw MAC address to server)

use anyhow::{Context, Result};
use mac_address::get_mac_address;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

/// Generate device fingerprint for license activation
///
/// Fingerprint is SHA-256 hash of:
/// - OS name (Windows, macOS, Linux)
/// - CPU architecture (x86_64, aarch64)
/// - MAC address (first network adapter)
///
/// Returns 64-character hex string (SHA-256 hash)
pub fn generate_device_fingerprint() -> Result<String> {
    // Get OS name
    let os = std::env::consts::OS; // "windows", "macos", "linux"

    // Get CPU architecture
    let arch = std::env::consts::ARCH; // "x86_64", "aarch64", etc.

    // Get MAC address (first network adapter)
    let mac = get_mac_address()
        .context("Failed to get MAC address")?
        .ok_or_else(|| anyhow::anyhow!("No MAC address found"))?;

    // Combine components
    let components = format!("{}:{}:{:?}", os, arch, mac);

    // Hash with SHA-256 (privacy: don't send raw MAC address to server)
    let mut hasher = Sha256::new();
    hasher.update(components.as_bytes());
    let hash = hasher.finalize();

    // Convert to hex string
    let fingerprint = format!("{:x}", hash);

    Ok(fingerprint)
}

/// License validation API request payload
#[derive(Debug, Serialize)]
struct LicenseValidationRequest {
    license_key: String,
    device_fingerprint: String,
}

/// License validation API response (200 OK)
#[derive(Debug, Deserialize)]
pub struct LicenseValidationResponse {
    pub valid: bool,
    pub user_id: String,
    pub device_id: String,
    pub tier: String,
    pub storage_limit_mb: u64,
    pub user_name: String,
    pub message: String,
}

/// Validate license key with server API
///
/// Calls POST /api/license/validate with license_key + device_fingerprint
///
/// Returns LicenseValidationResponse on success (200 OK)
/// Returns error on failure (400, 403, 404, 500)
pub async fn validate_license_key(
    license_key: &str,
    api_url: &str,
) -> Result<LicenseValidationResponse> {
    // Validate license key format: XXXX-XXXX-XXXX-XXXX
    if license_key.is_empty() {
        anyhow::bail!("License key is empty");
    }

    // Generate device fingerprint
    let device_fingerprint = generate_device_fingerprint()
        .context("Failed to generate device fingerprint")?;

    // Build API endpoint
    let endpoint = format!("{}/api/license/validate", api_url);

    // Build request payload
    let payload = LicenseValidationRequest {
        license_key: license_key.to_string(),
        device_fingerprint,
    };

    // Send POST request
    let client = reqwest::Client::new();
    let response = client
        .post(&endpoint)
        .json(&payload)
        .send()
        .await
        .context("Failed to send license validation request")?;

    // Check status code
    let status = response.status();

    if status.is_success() {
        // Parse success response
        let validation_response: LicenseValidationResponse = response
            .json()
            .await
            .context("Failed to parse license validation response")?;

        Ok(validation_response)
    } else {
        // Parse error message
        let error_text = response.text().await.unwrap_or_default();

        match status.as_u16() {
            400 => anyhow::bail!("Invalid request: {}", error_text),
            404 => anyhow::bail!("Invalid license key: Key not found in database. Please check your license key and try again."),
            403 => anyhow::bail!("License already activated on another device. Each license can only be used on one device. Please deactivate your other device or contact support."),
            500 => anyhow::bail!("Server error: {}. Please try again later.", error_text),
            _ => anyhow::bail!("Validation failed ({}): {}", status, error_text),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fingerprint_consistency() {
        let fp1 = generate_device_fingerprint().unwrap();
        let fp2 = generate_device_fingerprint().unwrap();
        assert_eq!(fp1, fp2, "Fingerprint should be consistent");
    }

    #[test]
    fn test_fingerprint_length() {
        let fp = generate_device_fingerprint().unwrap();
        assert_eq!(fp.len(), 64, "SHA-256 fingerprint should be 64 hex chars");
    }

    #[test]
    fn test_fingerprint_not_empty() {
        let fp = generate_device_fingerprint().unwrap();
        assert!(!fp.is_empty(), "Fingerprint should not be empty");
    }
}
```

**Update main.rs to include auth module**:
```bash
# Add at top of main.rs
Read products/lumina-desktop/src-tauri/src/main.rs:1-20

Edit products/lumina-desktop/src-tauri/src/main.rs
# Add after other mod declarations:
mod auth;
```

**Run Tests (Expected: GREEN - tests pass)**:
```bash
cd products/lumina-desktop/src-tauri
cargo test auth::tests
```

**Expected Output**: All 3 tests pass ‚úÖ

---

### Step 4: Add activate_license() Tauri Command (30 min)

**Goal**: Create Tauri command for frontend to call license validation

**Action**:
```bash
# Add to main.rs
Edit products/lumina-desktop/src-tauri/src/main.rs
```

**Add Tauri Command** (after existing commands):
```rust
/// Activate device with license key
///
/// Called from frontend LicenseActivationDialog
/// Validates license key with server API
/// Stores user_id, device_id, tier in AppSettings on success
///
/// Returns success message or error
#[tauri::command]
async fn activate_license(license_key: String) -> Result<String, String> {
    println!("üîë Activating license key: {}...", &license_key[..4]);

    // Load current settings
    let mut settings = get_settings().map_err(|e| format!("Failed to load settings: {}", e))?;

    // Get API URL from settings
    let api_url = settings.global_network_api_endpoint.clone();

    // Validate license key with server
    let validation_response = auth::validate_license_key(&license_key, &api_url)
        .await
        .map_err(|e| format!("License validation failed: {}", e))?;

    // Store license key and validation response in settings
    settings.license_key = license_key.trim().to_string();
    settings.user_id = Some(validation_response.user_id.clone());
    settings.device_id = Some(validation_response.device_id.clone());
    settings.tier = Some(validation_response.tier.clone());

    // Save settings
    save_settings(&settings).map_err(|e| format!("Failed to save settings: {}", e))?;

    println!("‚úÖ License activated successfully");
    println!("   User ID: {}", validation_response.user_id);
    println!("   Device ID: {}", validation_response.device_id);
    println!("   Tier: {}", validation_response.tier);

    Ok(format!("Device activated successfully! Welcome, {}. Your {} tier license is now active.",
        validation_response.user_name,
        validation_response.tier))
}
```

**Register Command in main()** (find Builder::default().invoke_handler(...)):
```rust
// Find invoke_handler and add activate_license
.invoke_handler(tauri::generate_handler![
    // ... existing commands ...
    activate_license,
])
```

**Compile Check**:
```bash
cd products/lumina-desktop/src-tauri
cargo check
```

**Expected**: Compiles successfully ‚úÖ

---

### Step 5: Create LicenseActivationDialog Component (45 min)

**Goal**: Create frontend UI for license activation

**Action**:
```bash
# Create React component
Write products/lumina-desktop/src/components/LicenseActivationDialog.tsx
```

**Component Content**:
```tsx
import React, { useState } from 'react';
import { invoke } from '@tauri-apps/api/tauri';

interface LicenseActivationDialogProps {
  onActivated: () => void;
}

export const LicenseActivationDialog: React.FC<LicenseActivationDialogProps> = ({ onActivated }) => {
  const [licenseKey, setLicenseKey] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [isActivating, setIsActivating] = useState(false);

  const handleActivate = async () => {
    if (!licenseKey.trim()) {
      setError('Please enter a license key');
      return;
    }

    setIsActivating(true);
    setError(null);

    try {
      const result = await invoke<string>('activate_license', { licenseKey: licenseKey.trim() });
      console.log('Activation successful:', result);
      onActivated();
    } catch (err) {
      console.error('Activation failed:', err);
      setError(`Activation failed: ${err}`);
    } finally {
      setIsActivating(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !isActivating) {
      handleActivate();
    }
  };

  return (
    <div style={{
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.8)',
      zIndex: 9999,
    }}>
      <div style={{
        backgroundColor: '#1e1e1e',
        padding: '32px',
        borderRadius: '12px',
        maxWidth: '500px',
        width: '90%',
        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.4)',
      }}>
        <h2 style={{ margin: '0 0 8px 0', color: '#ffffff' }}>Activate √ÜtherLight Desktop</h2>
        <p style={{ margin: '0 0 24px 0', color: '#b0b0b0', fontSize: '14px' }}>
          Enter your license key from the dashboard to activate voice capture
        </p>

        <div style={{ marginBottom: '16px' }}>
          <label style={{ display: 'block', marginBottom: '8px', color: '#ffffff', fontWeight: 600 }}>
            License Key
          </label>
          <input
            type="text"
            placeholder="XXXX-XXXX-XXXX-XXXX"
            value={licenseKey}
            onChange={(e) => {
              setLicenseKey(e.target.value);
              setError(null);
            }}
            onKeyPress={handleKeyPress}
            disabled={isActivating}
            style={{
              width: '100%',
              padding: '12px',
              fontSize: '16px',
              border: error ? '2px solid #ef4444' : '1px solid #444',
              borderRadius: '8px',
              backgroundColor: '#2a2a2a',
              color: '#ffffff',
              outline: 'none',
            }}
            autoFocus
          />
        </div>

        {error && (
          <div style={{
            padding: '12px',
            marginBottom: '16px',
            backgroundColor: '#ef444410',
            border: '1px solid #ef4444',
            borderRadius: '8px',
            color: '#ef4444',
            fontSize: '14px',
          }}>
            {error}
          </div>
        )}

        <button
          onClick={handleActivate}
          disabled={isActivating || !licenseKey.trim()}
          style={{
            width: '100%',
            padding: '14px',
            fontSize: '16px',
            fontWeight: 600,
            border: 'none',
            borderRadius: '8px',
            backgroundColor: isActivating || !licenseKey.trim() ? '#444' : '#3b82f6',
            color: '#ffffff',
            cursor: isActivating || !licenseKey.trim() ? 'not-allowed' : 'pointer',
            transition: 'background-color 0.2s',
          }}
        >
          {isActivating ? 'Activating...' : 'Activate Device'}
        </button>

        <div style={{ marginTop: '24px', padding: '16px', backgroundColor: '#2a2a2a', borderRadius: '8px' }}>
          <p style={{ margin: '0 0 8px 0', color: '#b0b0b0', fontSize: '13px' }}>
            <strong style={{ color: '#ffffff' }}>Don't have a license key?</strong>
          </p>
          <p style={{ margin: 0, fontSize: '13px', color: '#b0b0b0' }}>
            Sign in to your dashboard at{' '}
            <a href="https://aetherlight.ai/dashboard" target="_blank" rel="noopener noreferrer" style={{ color: '#3b82f6' }}>
              aetherlight.ai/dashboard
            </a>
            {' '}to get your free or pro license key.
          </p>
        </div>
      </div>
    </div>
  );
};
```

---

### Step 6: Add First-Launch Detection (30 min)

**Goal**: Check for empty license_key on app startup and show activation dialog

**Action**:
```bash
# Update main.rs main() function
Edit products/lumina-desktop/src-tauri/src/main.rs
```

**Add First-Launch Check** (in main() function, before Builder::default()):
```rust
fn main() {
    // ... existing setup_logging() etc ...

    // Check if license key is configured (first launch detection)
    let settings = match get_settings() {
        Ok(s) => s,
        Err(e) => {
            eprintln!("Failed to load settings: {}", e);
            AppSettings::default()
        }
    };

    if settings.license_key.is_empty() {
        println!("‚ö†Ô∏è  First launch detected: License key not configured");
        println!("   User will be prompted to activate device");
        // Frontend will detect empty license_key and show LicenseActivationDialog
    } else {
        println!("‚úÖ License key configured: {}", &settings.license_key[..4]);
        if let Some(tier) = &settings.tier {
            println!("   Tier: {}", tier);
        }
    }

    // ... rest of main() ...
}
```

**Update App.tsx to Show Activation Dialog**:
```bash
# Modify App.tsx to check for license_key and show LicenseActivationDialog
# This is a frontend change - add logic to check if license_key exists in settings
# If empty ‚Üí show LicenseActivationDialog
# If exists ‚Üí show normal app UI
```

**Implementation Note**: Frontend changes depend on existing App.tsx structure. Key concept:
1. On app load, call `get_settings()` command
2. Check if `license_key` is empty
3. If empty ‚Üí render `<LicenseActivationDialog onActivated={() => reload settings} />`
4. If exists ‚Üí render normal app UI

---

### Step 7: Write License Validation Tests (30 min - TDD)

**Goal**: Write integration tests for validate_license_key()

**Action**:
```bash
# Create test file
Write products/lumina-desktop/src-tauri/tests/auth_validation.rs
```

**Test Content**:
```rust
// Integration tests for license validation
// Note: These tests require mock API server or test API endpoint

#[cfg(test)]
mod tests {
    use lumina_desktop::auth::validate_license_key;

    // Test valid license key (requires test API or mock)
    #[tokio::test]
    #[ignore] // Ignore by default (requires live API)
    async fn test_valid_license_key() {
        let license_key = "CD7W-AJDK-RLQT-LUFA"; // Free tier test key
        let api_url = "https://api.aetherlight.ai";

        let result = validate_license_key(license_key, api_url).await;
        assert!(result.is_ok(), "Valid license key should succeed");

        let response = result.unwrap();
        assert_eq!(response.valid, true);
        assert_eq!(response.tier, "free");
    }

    // Test invalid license key (404)
    #[tokio::test]
    #[ignore] // Ignore by default (requires live API)
    async fn test_invalid_license_key() {
        let license_key = "INVALID-KEY-0000-0000";
        let api_url = "https://api.aetherlight.ai";

        let result = validate_license_key(license_key, api_url).await;
        assert!(result.is_err(), "Invalid license key should fail");

        let error_msg = result.unwrap_err().to_string();
        assert!(error_msg.contains("Invalid license key"), "Error should mention invalid key");
    }

    // Test empty license key
    #[tokio::test]
    async fn test_empty_license_key() {
        let license_key = "";
        let api_url = "https://api.aetherlight.ai";

        let result = validate_license_key(license_key, api_url).await;
        assert!(result.is_err(), "Empty license key should fail");

        let error_msg = result.unwrap_err().to_string();
        assert!(error_msg.contains("empty"), "Error should mention empty key");
    }
}
```

**Run Tests**:
```bash
cd products/lumina-desktop/src-tauri
# Run unit tests (not ignored)
cargo test auth

# Run integration tests (requires API - may fail without test credentials)
cargo test auth_validation -- --ignored
```

---

### Step 8: Manual Testing (30 min)

**Goal**: Test full activation flow manually

**Test Cases**:

1. **First Launch - Empty License Key**:
   ```bash
   # Delete settings.json to simulate first launch
   rm ~/Library/Application\ Support/com.aetherlight.lumina-desktop/settings.json  # macOS
   # OR
   del %APPDATA%\com.aetherlight.lumina-desktop\settings.json  # Windows

   # Launch app
   cargo tauri dev

   # Expected: LicenseActivationDialog appears
   ```

2. **Valid License Key Activation**:
   ```
   - Enter test key: CD7W-AJDK-RLQT-LUFA (free tier)
   - Click "Activate Device"
   - Expected: Success message, dialog closes, app loads normally
   - Verify: Check settings.json has license_key, user_id, device_id, tier
   ```

3. **Invalid License Key**:
   ```
   - Delete settings.json
   - Launch app
   - Enter invalid key: INVALID-0000-0000-0000
   - Click "Activate Device"
   - Expected: Error message "Invalid license key: Key not found in database"
   ```

4. **Already Activated (403)**:
   ```
   - Use same key on different device
   - Expected: Error message "License already activated on another device"
   ```

5. **Subsequent Launch - License Key Exists**:
   ```
   - Close app
   - Relaunch app
   - Expected: NO activation dialog (settings.json has license_key)
   - App loads normally with voice capture functional
   ```

---

### Step 9: Commit Changes (10 min)

**Goal**: Create clean commit with comprehensive message

**Action**:
```bash
# Stage all changes
git add products/lumina-desktop/src-tauri/src/auth.rs
git add products/lumina-desktop/src-tauri/src/main.rs
git add products/lumina-desktop/src-tauri/Cargo.toml
git add products/lumina-desktop/src/components/LicenseActivationDialog.tsx
git add products/lumina-desktop/src-tauri/tests/auth_validation.rs
git add products/lumina-desktop/src-tauri/tests/device_fingerprint.rs

# Check diff
git diff --cached

# Commit
git commit -m "feat(desktop): Implement license validation flow on first launch (BUG-002)

- Add auth.rs module with license validation logic
  - generate_device_fingerprint() (OS + CPU + MAC hash with SHA-256)
  - validate_license_key() (calls POST /api/license/validate)
- Add activate_license() Tauri command (frontend ‚Üí backend bridge)
- Add LicenseActivationDialog.tsx (frontend activation UI)
- Add first-launch detection in main() (check for empty license_key)
- Add error handling for 400, 403, 404, 500 API responses
- Add unit tests for device_fingerprint (3 tests)
- Add integration tests for license_validation (3 tests)
- Add Rust dependencies: sha2, mac_address

Technical Details:
- Files Created: auth.rs (180 lines), LicenseActivationDialog.tsx (150 lines), auth_validation.rs (50 lines), device_fingerprint.rs (20 lines)
- Files Modified: main.rs (+50 lines), Cargo.toml (+2 dependencies)
- Total Lines: ~400 lines
- Test Coverage: 90% (6 tests, infrastructure requirement)
- Breaking Change: No (backward compatible - existing users keep license_key)
- Commit: {COMMIT_HASH}

Testing:
- Unit tests: ‚úÖ Passed (device_fingerprint consistency, length, not empty)
- Integration tests: ‚è∏Ô∏è Requires test API credentials (marked as #[ignore])
- Manual testing: ‚úÖ Passed (first launch ‚Üí activation dialog ‚Üí valid key ‚Üí success)

Error Handling:
- 400: Invalid request ‚Üí Show error + retry
- 404: Invalid license key ‚Üí Clear error message with guidance
- 403: Already activated ‚Üí Show error + contact support link
- 500: Server error ‚Üí Show error + retry later
- Network failure: Show error + check connection

API Contract:
- Endpoint: POST /api/license/validate
- Request: { license_key, device_fingerprint }
- Response (200): { valid, user_id, device_id, tier, storage_limit_mb, user_name, message }
- Errors: 400 (missing fields), 404 (invalid key), 403 (already activated), 500 (server error)

Impact:
- Unblocks: First-time user onboarding
- Fixes: 'License key not configured' error with resolution path
- Enables: Voice capture functionality for new users
- User Experience: Clear activation flow with helpful error messages

Dependencies Completed:
- ‚úÖ BUG-002A: TranscriptionResponse token migration (commit 835ba2d)
- ‚úÖ BUG-002B: Bearer authentication (commit 88dbbba)
- ‚úÖ BUG-002C: License format validation (false bug - API validates)
- ‚úÖ BUG-003: AppSettings fields (commit 9afdb91)

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
```

**Expected**: Clean commit with detailed documentation

---

### Step 10: Update Sprint TOML to Completed (5 min)

**‚ö†Ô∏è CRITICAL**: This step is MANDATORY per Pattern-COMPLETION-001 (v1.4.2 enforcement)

**Action**:
```bash
# Option 1: Use skill (if available)
/sprint-task-lifecycle complete BUG-002

# Option 2: Manual update (if skill unavailable)
# Edit ACTIVE_SPRINT_17.1_BUGS.toml lines 158-161
```

**Update Sprint TOML**:
1. Change `status = "pending"` to `status = "completed"`
2. Add `completed_date = "YYYY-MM-DD"` (today's date)
3. Add `completion_notes = """..."""` (see Section 12 for template)

**‚ö†Ô∏è DO NOT SKIP THIS STEP** - See Section 12 for detailed requirements

---

## Success Criteria

**Task is complete when ALL criteria are met:**

1. ‚úÖ **auth.rs module created** with:
   - generate_device_fingerprint() function (OS + CPU + MAC hash)
   - validate_license_key() function (calls POST /api/license/validate)
   - LicenseValidationResponse struct
   - Error handling for 400, 403, 404, 500

2. ‚úÖ **activate_license() Tauri command** added to main.rs:
   - Calls validate_license_key()
   - Stores user_id, device_id, tier in AppSettings on success
   - Returns success message or error

3. ‚úÖ **LicenseActivationDialog.tsx component** created:
   - License key input field
   - Activate button
   - Error display
   - Loading state
   - Dashboard link

4. ‚úÖ **First-launch detection** in main():
   - Checks if license_key is empty
   - Logs first launch message
   - Frontend shows activation dialog

5. ‚úÖ **Dependencies added** to Cargo.toml:
   - sha2 = "0.10"
   - mac_address = "1.1"

6. ‚úÖ **Tests written and passing**:
   - 3 device_fingerprint unit tests
   - 3 license_validation integration tests (may be #[ignore])
   - All tests pass (cargo test auth)

7. ‚úÖ **Manual testing complete**:
   - First launch ‚Üí activation dialog appears
   - Valid key ‚Üí activation succeeds
   - Invalid key ‚Üí error message shown
   - Already activated ‚Üí 403 error shown
   - Subsequent launch ‚Üí no dialog (license_key exists)

8. ‚úÖ **Git commit created** with comprehensive message

9. ‚úÖ **Sprint TOML updated to completed** (MANDATORY - Section 12)

10. ‚úÖ **Cargo check passes** (no compilation errors)

---

## Validation Commands

**Compile Check**:
```bash
cd products/lumina-desktop/src-tauri
cargo check
```

**Expected**: ‚úÖ Compiles successfully

**Test Check**:
```bash
cd products/lumina-desktop/src-tauri
cargo test auth
```

**Expected**: ‚úÖ All unit tests pass

**Git Status Check**:
```bash
git status
```

**Expected**: Clean working tree (all changes committed)

**Sprint Status Check**:
```bash
grep -A 5 "^\[tasks.BUG-002\]" internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml | grep 'status = "completed"'
```

**Expected**: ‚úÖ Shows `status = "completed"`

---

## Error Handling

### Compilation Errors

**Error**: "cannot find module `auth` in this scope"
**Cause**: Forgot to add `mod auth;` to main.rs
**Fix**: Add `mod auth;` at top of main.rs (after other mod declarations)

**Error**: "sha2 crate not found"
**Cause**: Forgot to add dependencies to Cargo.toml
**Fix**: Add `sha2 = "0.10"` and `mac_address = "1.1"` to [dependencies]

**Error**: "function `generate_device_fingerprint` is private"
**Cause**: Forgot `pub` keyword on function
**Fix**: Add `pub fn generate_device_fingerprint() -> Result<String>`

### Runtime Errors

**Error**: "Failed to get MAC address"
**Cause**: No network adapters found or permission issue
**Fix**:
- Check network adapters are enabled
- On Linux, may require sudo/root permissions
- Fallback: Use only OS + CPU (remove MAC requirement)

**Error**: 404 "Invalid license key"
**Cause**: License key not found in database
**Fix**:
- Verify license key is correct (check dashboard)
- Ensure API endpoint is correct (https://api.aetherlight.ai)
- Check network connection

**Error**: 403 "License already activated"
**Cause**: License key already used on another device
**Fix**:
- Deactivate other device first (dashboard)
- Or contact support for device reset

**Error**: 500 "Server error"
**Cause**: API server issue (database down, etc.)
**Fix**:
- Show user error message with "try again later"
- Log error details for debugging

### Test Failures

**Error**: Device fingerprint inconsistent
**Cause**: MAC address changes between calls (rare)
**Fix**:
- Check MAC address retrieval is deterministic
- May need to select specific network adapter (not first available)

**Error**: Integration tests fail with network error
**Cause**: No internet connection or API down
**Fix**:
- Mark integration tests as `#[ignore]` by default
- Run manually with `cargo test -- --ignored` when testing

---

## Related Documentation

**Patterns**:
- Pattern-TASK-ANALYSIS-001: docs/patterns/Pattern-TASK-ANALYSIS-001.md (8-step analysis)
- Pattern-CODE-001: docs/patterns/Pattern-CODE-001.md (code workflow)
- Pattern-TDD-001: docs/patterns/Pattern-TDD-001.md (test-driven development)
- Pattern-GIT-001: docs/patterns/Pattern-GIT-001.md (git workflow)
- Pattern-TRACKING-001: docs/patterns/Pattern-TRACKING-001.md (sprint TOML lifecycle)
- Pattern-VALIDATION-001: CLAUDE.md (pre-flight checklist)
- Pattern-COMPLETION-001: docs/patterns/Pattern-COMPLETION-001.md (post-completion docs)

**API Documentation**:
- License validation API: website/app/api/license/validate/route.ts (server implementation)
- Request/response format: See "Context Gathered" section above

**Related Tasks**:
- BUG-002A: Migrate TranscriptionResponse struct from USD to tokens (completed ‚úÖ commit 835ba2d)
- BUG-002B: Update token balance API to use Bearer authentication (completed ‚úÖ commit 88dbbba)
- BUG-002C: Update license key format validation (completed ‚úÖ false bug report)
- BUG-003: Add user_id, device_id, tier fields to AppSettings (completed ‚úÖ commit 9afdb91)

**Dependencies**:
- sha2 crate: https://docs.rs/sha2/
- mac_address crate: https://docs.rs/mac_address/
- Tauri commands: https://tauri.app/v1/guides/features/command/

---

## Notes for AI Agent

### Implementation Complexity
- This is a MAJOR task (6-8 hours, 400 lines)
- Multiple files to create (auth.rs, LicenseActivationDialog.tsx, tests)
- Multiple files to modify (main.rs, Cargo.toml, App.tsx)
- TDD required (write tests first)
- Comprehensive error handling required

### Priority Order
1. **FIRST**: Device fingerprint (foundation for validation)
2. **SECOND**: License validation logic (core functionality)
3. **THIRD**: Tauri command (backend ‚Üí frontend bridge)
4. **FOURTH**: Frontend UI (user-facing activation)
5. **FIFTH**: First-launch detection (integration)
6. **SIXTH**: Tests (validation)
7. **SEVENTH**: Manual testing (verification)

### Test Credentials
- Free tier: CD7W-AJDK-RLQT-LUFA
- Pro tier: W7HD-X79Q-CQJ9-XW13
- These keys are in consensus validation document (validated 2025-11-12)

### API Behavior Notes
- License keys can only be activated on ONE device per key
- Device fingerprint is permanent (stored in database)
- Subsequent activations with same key on different devices ‚Üí 403 error
- Users must deactivate old device before activating new device

### Chain of Thought
When implementing, consider:
1. Why SHA-256 for device fingerprint? ‚Üí Privacy (don't send raw MAC to server)
2. Why first-launch detection? ‚Üí UX (only show dialog when needed)
3. Why Tauri command? ‚Üí Bridge between frontend (React) and backend (Rust)
4. Why error handling so detailed? ‚Üí User experience (clear guidance on failures)
5. Why TDD? ‚Üí Confidence that validation logic works before integration

---

## ‚ö†Ô∏è CRITICAL: Post-Completion Documentation (Pattern-COMPLETION-001)

**üõë STOP: This task is NOT complete until ALL documentation below is updated.**

**ENFORCEMENT**: Pattern-COMPLETION-001 requires 100% completion of this section. Skipping ANY item = incomplete task.

---

### 1. Sprint TOML Completion Notes (MANDATORY - DO NOT SKIP)

**‚ö†Ô∏è CRITICAL REQUIREMENT**: Update Sprint TOML status BEFORE considering task complete.

**Step 1: Update Status Field**
```toml
[tasks.BUG-002]
status = "completed"  # Change from "in_progress" or "pending"
completed_date = "YYYY-MM-DD"  # Today's date
```

**Step 2: Add `completion_notes` field to your task in `internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml`:**

```toml
completion_notes = """
Completed YYYY-MM-DD by AI agent (tauri-desktop-agent)

Changes Made:
- Created auth.rs module with license validation logic (180 lines)
- Added generate_device_fingerprint() function (OS + CPU + MAC hash with SHA-256)
- Added validate_license_key() function (calls POST /api/license/validate)
- Added activate_license() Tauri command (frontend ‚Üí backend bridge)
- Created LicenseActivationDialog.tsx component (150 lines)
- Added first-launch detection in main() (check for empty license_key)
- Added error handling for 400, 403, 404, 500 API responses
- Added unit tests for device_fingerprint (3 tests)
- Added integration tests for license_validation (3 tests)
- Added Rust dependencies: sha2 (0.10), mac_address (1.1)

Technical Details:
- Files Created:
  - products/lumina-desktop/src-tauri/src/auth.rs (180 lines)
  - products/lumina-desktop/src/components/LicenseActivationDialog.tsx (150 lines)
  - products/lumina-desktop/src-tauri/tests/auth_validation.rs (50 lines)
  - products/lumina-desktop/src-tauri/tests/device_fingerprint.rs (20 lines)
- Files Modified:
  - products/lumina-desktop/src-tauri/src/main.rs (+50 lines)
  - products/lumina-desktop/src-tauri/Cargo.toml (+2 dependencies)
- Total Lines: ~400 lines
- Test Coverage: 90% (6 tests, all passing)
- Breaking Change: No (backward compatible)
- Commit: {COMMIT_HASH}

Testing:
- Unit tests: ‚úÖ Passed (3 device_fingerprint tests: consistency, length, not empty)
- Integration tests: ‚è∏Ô∏è Marked as #[ignore] (requires live API - tested manually)
- Manual testing: ‚úÖ Passed (all 5 test cases successful)
  1. ‚úÖ First launch ‚Üí activation dialog appears
  2. ‚úÖ Valid key (CD7W-AJDK-RLQT-LUFA) ‚Üí activation succeeds
  3. ‚úÖ Invalid key ‚Üí error message shown
  4. ‚úÖ Already activated ‚Üí 403 error shown
  5. ‚úÖ Subsequent launch ‚Üí no dialog (license_key exists)

Error Handling Verified:
- ‚úÖ 400: Invalid request ‚Üí Clear error message
- ‚úÖ 404: Invalid license key ‚Üí "Key not found" message with guidance
- ‚úÖ 403: Already activated ‚Üí "Deactivate other device" message
- ‚úÖ 500: Server error ‚Üí "Try again later" message
- ‚úÖ Network failure ‚Üí Connection error message

Impact:
- Unblocks: First-time user onboarding flow
- Fixes: "License key not configured" error with clear resolution path
- Enables: Voice capture functionality for new users
- User Experience: Professional activation flow with helpful error messages

API Contract:
- Endpoint: POST /api/license/validate
- Request: { license_key: string, device_fingerprint: string }
- Response (200): { valid: bool, user_id: string, device_id: string, tier: string, storage_limit_mb: u64, user_name: string, message: string }
- Errors: 400 (missing fields), 404 (invalid key), 403 (already activated), 500 (server error)

Dependencies Completed:
- ‚úÖ BUG-002A: TranscriptionResponse token migration (commit 835ba2d)
- ‚úÖ BUG-002B: Bearer authentication (commit 88dbbba - false bug)
- ‚úÖ BUG-002C: License format validation (false bug - API validates)
- ‚úÖ BUG-003: AppSettings fields (commit 9afdb91)

Test Credentials Used:
- Free tier: CD7W-AJDK-RLQT-LUFA ‚úÖ
- Pro tier: W7HD-X79Q-CQJ9-XW13 ‚úÖ
"""
```

**Location**: Add after `completed_date` field in your task section (line ~161)

---

### 2. Testing Document Updates

**Add test case to `docs/TESTING_v0.17.2.md`:**

```markdown
### Test 36: BUG-002 - License Validation Flow on First Launch
**Category**: Desktop Authentication
**Priority**: CRITICAL
**Commit**: {COMMIT_HASH}

**Steps**:
1. Delete settings.json to simulate first launch
2. Launch desktop app (cargo tauri dev)
3. Verify LicenseActivationDialog appears
4. Enter test license key: CD7W-AJDK-RLQT-LUFA
5. Click "Activate Device"
6. Verify success message appears
7. Verify settings.json has license_key, user_id, device_id, tier
8. Close app and relaunch
9. Verify NO activation dialog (license_key exists)

**Expected Result**: ‚úÖ
- First launch shows activation dialog
- Valid key activates successfully
- Settings persisted (user_id, device_id, tier stored)
- Subsequent launches skip activation dialog

**Actual Result**: _____________________________

**Status**: [ ] PASS [ ] FAIL

---

### Test 37: BUG-002 - Invalid License Key Error Handling
**Category**: Desktop Authentication
**Priority**: HIGH
**Commit**: {COMMIT_HASH}

**Steps**:
1. Delete settings.json
2. Launch desktop app
3. Enter invalid key: INVALID-0000-0000-0000
4. Click "Activate Device"
5. Verify error message: "Invalid license key: Key not found in database"

**Expected Result**: ‚úÖ Clear error message with guidance

**Actual Result**: _____________________________

**Status**: [ ] PASS [ ] FAIL

---

### Test 38: BUG-002 - Already Activated (403) Error Handling
**Category**: Desktop Authentication
**Priority**: HIGH
**Commit**: {COMMIT_HASH}

**Steps**:
1. Activate device with test key on Device A
2. Attempt to activate same key on Device B (different device_fingerprint)
3. Verify error message: "License already activated on another device"

**Expected Result**: ‚úÖ Clear error with deactivation guidance

**Actual Result**: _____________________________

**Status**: [ ] PASS [ ] FAIL
```

---

### 3. Pattern Documentation (If Applicable)

**No new patterns created** - BUG-002 follows existing patterns:
- Pattern-CODE-001 (code workflow)
- Pattern-TDD-001 (test-driven development)
- Pattern-GIT-001 (git workflow)
- Pattern-COMPLETION-001 (post-completion docs)

---

### 4. Known Issues Updates (If Applicable)

**This is a feature implementation, not a bug fix.**

**No KNOWN_ISSUES.md update needed** - unless new issues discovered during implementation.

---

**Completion Checklist (MANDATORY):**

üõë **DO NOT mark task as complete until ALL items below are verified:**

- [ ] **Sprint TOML status = "completed"** (MANDATORY - verify with command below)
- [ ] **Sprint TOML has `completed_date` field** (MANDATORY - verify with command below)
- [ ] **Sprint TOML has `completion_notes` field** (MANDATORY - verify with command below)
- [ ] Testing document updated (3 test cases added to TESTING_v0.17.2.md)
- [ ] Pattern documented (**N/A** - no new patterns created)
- [ ] Known issues updated (**N/A** - feature implementation, not bug fix)
- [ ] All unit tests passing (cargo test auth)
- [ ] Integration tests written (may be #[ignore] for live API)
- [ ] Manual testing complete (5 test cases validated)
- [ ] Git commit follows format (Pattern-GIT-001)
- [ ] Code reviewed (self-review for quality)
- [ ] Cargo check passing (no compilation errors)

---

### üîç MANDATORY: Verify Sprint TOML Update

**Before you consider this task complete, run these validation commands:**

```bash
# Check if status is "completed"
grep -A 5 "^\[tasks.BUG-002\]" internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml | grep 'status = "completed"'

# Check if completed_date exists
grep -A 5 "^\[tasks.BUG-002\]" internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml | grep "completed_date"

# Check if completion_notes exists
grep -A 5 "^\[tasks.BUG-002\]" internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml | grep "completion_notes"
```

**Expected Output:**
```
status = "completed"
completed_date = "YYYY-MM-DD"
completion_notes = """
```

**‚ùå If ANY command returns empty**: Sprint TOML is NOT updated. Go back to Step 1 and update it NOW.

**‚úÖ If ALL commands return results**: Sprint TOML is updated correctly. Task is complete.

---

**FINAL WARNING**: Historical audit (BUG-002A, 2025-01-12) found 72% process compliance because agents skipped Sprint TOML updates. BUG-003 audit (2025-01-12) found code complete but Sprint TOML not updated. DO NOT repeat this mistake. Update Sprint TOML BEFORE marking task complete.

---

**Template Version**: MVP-003-PromptEnhancer-TaskTemplate-v1.4.2
**Last Updated**: 2025-01-12
**Enforcement**: 6/6 patterns (100%) with STRENGTHENED Sprint TOML enforcement
