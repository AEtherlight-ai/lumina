# ENHANCE-001.7: Iterative Refinement UI (Re-enhance with User Feedback)

**Sprint:** 17.1-BUGS
**Task ID:** ENHANCE-001.7
**Agent:** ui-agent
**Estimated Time:** 3-4 hours
**Dependencies:** ENHANCE-001.1, ENHANCE-001.6
**Template Version:** MVP-003-PromptEnhancer-TaskTemplate-v1.4.3

---

## Step 0: Pre-Task Analysis (MANDATORY - Run Pattern-TASK-ANALYSIS-001)

**CRITICAL: You MUST complete this 8-step analysis OUT LOUD before writing ANY code.**

### 1. UNDERSTAND the Task

**Task Goal:**
Add refinement buttons to the text area after enhancement, allowing users to iteratively improve enhanced prompts without restarting the enhancement process. Supports 4 refinement types: Refine (add detail), Simplify (make concise), Add Detail (expand specific areas), and Include Pattern (add specific patterns).

**Why This Task Exists:**
**Problem - One-shot enhancement is limiting:**

Current workflow:
1. User clicks Enhance â†’ Gets result
2. Result not good enough â†’ User must go back to form, re-fill all fields, click Enhance again
3. No way to say "add more about error handling" or "simplify this" or "include Pattern-X"
4. Real conversations are iterative, but current system is one-shot only

**User Need:** "Can I refine the enhancement without starting over?"

**Real-world usage scenarios:**
- "Good start, but add more about error handling"
- "Too verbose, make it concise"
- "Missing Pattern-TDD-001, include it"
- "Add specific file examples for src/auth.ts"

**Solution:**
After enhancement, show refinement buttons in text area. User clicks button â†’ AI re-enhances with feedback â†’ Result updates â†’ User can refine again if needed (iterative loop).

**Current vs. Desired State:**
- **CURRENT:** One-shot enhancement, no refinement capability, must restart if result inadequate
- **DESIRED:** Refinement buttons after enhancement, iterative improvement until satisfied, feedback loop for AI learning

### 2. CHECK for Existing Solutions

**Search Strategy:**
```bash
# Search for existing refinement UI
grep -r "refine" vscode-lumina/src/commands/voicePanel.ts
grep -r "re-enhance" vscode-lumina/src/

# Check webview HTML structure
grep -r "webview" vscode-lumina/src/commands/voicePanel.ts

# Check if refinement handlers exist
grep -r "handleRefinement" vscode-lumina/src/
```

**Expected Findings:**
- voicePanel.ts creates webview for text area (integration point)
- No existing refinement UI (new feature)
- AIEnhancementService.enhance() can be called multiple times (reuse for re-enhancement)

### 3. IDENTIFY Required Changes

**Files to Read (for context):**
1. `vscode-lumina/src/commands/voicePanel.ts` - Webview creation, message handlers
2. `vscode-lumina/src/services/AIEnhancementService.ts` - Re-enhancement logic (reuse enhance())

**Files to Modify:**
1. `vscode-lumina/src/commands/voicePanel.ts` - Add refinement handlers, webview HTML updates
2. Webview HTML (embedded in voicePanel.ts) - Add refinement button UI

**Webview Structure:**
- voicePanel.ts creates VS Code webview
- Webview communicates with extension via postMessage
- Extension handles messages and updates webview content

### 4. ASSESS Impact & Risk

**Impact Assessment:**
- **Scope:** MEDIUM - UI changes + message handlers + AI re-enhancement integration
- **Blast Radius:** LOW - Only affects text area after enhancement (existing functionality unchanged)
- **Performance:** LOW - Re-enhancement uses same AI service (< 3 seconds)
- **Breaking Changes:** NONE - Additive feature, existing enhancement unchanged

**Risk Factors:**
- âš ï¸ **UX Risk:** Too many refinement buttons could clutter UI
- âš ï¸ **AI Risk:** Re-enhancement might produce worse results than original
- âš ï¸ **State Risk:** Must preserve original context + refinement history for multiple iterations

**Mitigation Strategies:**
- Keep button UI minimal (4 buttons max, compact design)
- Always preserve original prompt (user can revert if refinement worse)
- Store refinement history in metadata (track iteration count, previous refinements)
- Add "Undo" button to revert to previous version

### 5. VERIFY Dependencies & Blockers

**Dependencies:**
- âœ… **ENHANCE-001.1:** EnhancementContext defined (needed for re-enhancement)
- âœ… **ENHANCE-001.6:** Metadata passthrough (refinement history embedded in metadata)
- âœ… **AIEnhancementService:** Exists, enhance() method can be reused

**Potential Blockers:**
- âŒ **Pattern list unknown:** For "Include Pattern" button, need list of available patterns
- âŒ **Webview message passing unclear:** How does webview â†’ extension communication work?

**Blocker Resolution:**
- Read voicePanel.ts to understand webview message passing pattern
- Load patterns from docs/patterns/ directory for dropdown
- Check if PatternLibrary service exists (pattern enumeration)

### 6. PLAN with Git Workflow (Pattern-GIT-001)

**Current Branch:** feature/v0.17.2-bug-fixes
**Git Status:** Clean (from gitStatus snapshot)

**Workflow Steps:**
1. âœ… Verify branch: `git status` (already on feature branch)
2. âœ… Read voicePanel.ts to understand webview structure
3. âœ… Write tests FIRST (TDD RED phase)
4. âœ… Add refinement button UI to webview HTML (GREEN phase)
5. âœ… Add refinement handlers in voicePanel (GREEN phase)
6. âœ… Integrate with AIEnhancementService for re-enhancement (GREEN phase)
7. âœ… Test manually with real enhancements (manual verification)
8. âœ… Optimize UI responsiveness (REFACTOR phase)
9. âœ… Commit: "feat(ENHANCE-001.7): Implement iterative refinement UI"
10. âœ… Validation: Test all 4 refinement types

**Commit Message Template:**
```
feat(ENHANCE-001.7): Implement iterative refinement UI

- Add refinement button container to webview HTML
- Add 4 refinement buttons: Refine, Simplify, Add Detail, Include Pattern
- Add refinement message handlers in voicePanel
- Integrate with AIEnhancementService for re-enhancement
- Add pattern dropdown for Include Pattern button
- Support iterative refinement (multiple refinements)
- Track refinement history in metadata
- Preserve original prompt (revert option)
- Add unit tests (70% coverage)
- Refinement performance < 3 seconds

Users can now refine enhancements without restarting.

Closes ENHANCE-001.7
```

### 7. CHECK Patterns & SOPs

**Applicable Patterns:**
- âœ… **Pattern-CODE-001:** Code development workflow (announced OUT LOUD)
- âœ… **Pattern-TDD-001:** Tests FIRST (RED â†’ GREEN â†’ REFACTOR)
- âœ… **Pattern-UX-001:** User experience design (iterative refinement improves UX)

**Pattern Integration:**
- Refinement buttons implement iterative improvement pattern
- User feedback loop enables continuous enhancement quality improvement

### 8. ESTIMATE Effort & Complexity

**Effort Estimate:** 3-4 hours (from task specification)

**Complexity Breakdown:**
- **Read voicePanel.ts:** 20 min - Understand webview structure, message passing
- **UI Design:** 30 min - Design refinement button layout (HTML/CSS)
- **Refinement Handlers:** 60 min - Add message handlers for 4 button types
- **Pattern Dropdown:** 30 min - Load patterns, populate dropdown
- **Re-enhancement Logic:** 45 min - Integrate with AIEnhancementService
- **Tests:** 60 min - 10 test cases (70% coverage)
- **Manual Testing:** 30 min - Test all refinement types with real enhancements

**Total:** ~3.75 hours (matches estimate)

**Confidence Level:** MEDIUM-HIGH
- âœ… Webview pattern well-understood in VS Code extensions
- âœ… AIEnhancementService already implemented (reuse enhance())
- âš ï¸ Pattern dropdown requires pattern enumeration (minor complexity)
- âš ï¸ Refinement history tracking (state management)

---

## Step 1: UNDERSTAND the Webview Architecture

### Read Foundation Files

**CRITICAL: Read these files BEFORE writing any code.**

```bash
# Read voicePanel.ts to understand webview structure
cat vscode-lumina/src/commands/voicePanel.ts

# Look for webview creation and message handling
cat vscode-lumina/src/commands/voicePanel.ts | grep -A 50 "createWebviewPanel"
cat vscode-lumina/src/commands/voicePanel.ts | grep -A 20 "onDidReceiveMessage"

# Check AIEnhancementService for reuse
cat vscode-lumina/src/services/AIEnhancementService.ts
```

### Webview Communication Pattern

**VS Code Webview Architecture:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ VS Code Extension (voicePanel.ts)                    â”‚
â”‚                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Webview Panel                                â”‚    â”‚
â”‚  â”‚                                               â”‚    â”‚
â”‚  â”‚  HTML + CSS + JavaScript                     â”‚    â”‚
â”‚  â”‚                                               â”‚    â”‚
â”‚  â”‚  [Refine] [Simplify] [Add Detail] [Pattern] â”‚    â”‚
â”‚  â”‚                                               â”‚    â”‚
â”‚  â”‚  User clicks button                          â”‚    â”‚
â”‚  â”‚      â†“                                        â”‚    â”‚
â”‚  â”‚  webview.postMessage({                       â”‚    â”‚
â”‚  â”‚    command: 'refine',                        â”‚    â”‚
â”‚  â”‚    type: 'simplify',                         â”‚    â”‚
â”‚  â”‚    context: { ... }                          â”‚    â”‚
â”‚  â”‚  })                                          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                       â”‚                              â”‚
â”‚                       â†“                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Extension Message Handler                    â”‚    â”‚
â”‚  â”‚                                               â”‚    â”‚
â”‚  â”‚  webview.onDidReceiveMessage(message => {   â”‚    â”‚
â”‚  â”‚    switch (message.command) {                â”‚    â”‚
â”‚  â”‚      case 'refine':                          â”‚    â”‚
â”‚  â”‚        handleRefinement(message);            â”‚    â”‚
â”‚  â”‚        break;                                â”‚    â”‚
â”‚  â”‚    }                                         â”‚    â”‚
â”‚  â”‚  })                                          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                       â”‚                              â”‚
â”‚                       â†“                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ AIEnhancementService                         â”‚    â”‚
â”‚  â”‚                                               â”‚    â”‚
â”‚  â”‚  enhance(context, refinementFeedback)       â”‚    â”‚
â”‚  â”‚      â†“                                        â”‚    â”‚
â”‚  â”‚  Generate refined prompt                     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                       â”‚                              â”‚
â”‚                       â†“                              â”‚
â”‚  Update webview with refined prompt                 â”‚
â”‚                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Refinement Button UI Design

**HTML Structure (embedded in voicePanel.ts):**
```html
<div class="text-area-container">
    <!-- Enhanced prompt text -->
    <textarea id="enhanced-prompt" readonly>
        <!-- Generated prompt content -->
    </textarea>

    <!-- Refinement button container (shown after enhancement) -->
    <div id="refinement-buttons" class="refinement-container" style="display: none;">
        <div class="confidence-badge">
            <span>Confidence: <strong id="confidence-level">High (92%)</strong></span>
        </div>

        <div class="refinement-actions">
            <button class="refinement-btn" data-type="refine">
                <span class="icon">âœ¨</span> Refine
            </button>
            <button class="refinement-btn" data-type="simplify">
                <span class="icon">âš¡</span> Simplify
            </button>
            <button class="refinement-btn" data-type="add-detail">
                <span class="icon">ğŸ“</span> Add Detail
            </button>
            <button class="refinement-btn" data-type="include-pattern">
                <span class="icon">ğŸ¯</span> Include Pattern
            </button>
            <button class="refinement-btn revert-btn" data-type="undo">
                <span class="icon">â†©ï¸</span> Undo
            </button>
        </div>
    </div>

    <!-- Send to Terminal button -->
    <button id="send-to-terminal">Send to Terminal â–¼</button>
</div>

<!-- Add Detail Modal (hidden by default) -->
<div id="add-detail-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <h3>Add Detail - What area should be expanded?</h3>
        <textarea id="detail-input" placeholder="e.g., 'Add more about error handling'"></textarea>
        <div class="modal-actions">
            <button id="detail-submit">Add Detail</button>
            <button id="detail-cancel">Cancel</button>
        </div>
    </div>
</div>

<!-- Include Pattern Modal (hidden by default) -->
<div id="pattern-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <h3>Include Pattern - Select pattern to add</h3>
        <select id="pattern-select">
            <option value="">-- Select Pattern --</option>
            <!-- Populated dynamically -->
        </select>
        <div class="modal-actions">
            <button id="pattern-submit">Include Pattern</button>
            <button id="pattern-cancel">Cancel</button>
        </div>
    </div>
</div>

<style>
.refinement-container {
    margin-top: 16px;
    padding: 12px;
    background: var(--vscode-editor-inactiveSelectionBackground);
    border-radius: 6px;
    border: 1px solid var(--vscode-panel-border);
}

.confidence-badge {
    margin-bottom: 8px;
    font-size: 13px;
    color: var(--vscode-descriptionForeground);
}

.refinement-actions {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.refinement-btn {
    padding: 6px 12px;
    font-size: 13px;
    border: 1px solid var(--vscode-button-border);
    background: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 4px;
}

.refinement-btn:hover {
    background: var(--vscode-button-hoverBackground);
}

.refinement-btn .icon {
    font-size: 14px;
}

.revert-btn {
    margin-left: auto;
    background: var(--vscode-button-secondaryBackground);
}

.modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-content {
    background: var(--vscode-editor-background);
    padding: 20px;
    border-radius: 8px;
    min-width: 400px;
}
</style>
```

---

## Step 2: TDD - Write Tests FIRST (RED Phase)

**CRITICAL: Pattern-TDD-001 requires writing tests BEFORE implementation.**

### Test File

**File:** `vscode-lumina/test/commands/voicePanel-refinement.test.ts`

```typescript
import * as assert from 'assert';
import * as vscode from 'vscode';
import { VoicePanelCommand } from '../../src/commands/voicePanel';
import { AIEnhancementService } from '../../src/services/AIEnhancementService';

describe('VoicePanelCommand - Refinement UI', () => {
    let voicePanel: VoicePanelCommand;
    let mockAIService: AIEnhancementService;

    beforeEach(() => {
        mockAIService = new AIEnhancementService();
        voicePanel = new VoicePanelCommand(/* inject mock AI service */);
    });

    afterEach(() => {
        // Clean up webview panels
    });

    // TEST 1: Refinement buttons appear after enhancement
    describe('Refinement button visibility', () => {
        it('should show refinement buttons after enhancement completes', async () => {
            const mockContext = createMockContext('bug');

            // Trigger enhancement
            await voicePanel.handleEnhancePrompt('bug', mockFormData);

            // Verify refinement buttons visible
            const webviewContent = voicePanel.getWebviewContent();
            assert.ok(webviewContent.includes('id="refinement-buttons"'));
            assert.ok(!webviewContent.includes('display: none;'));
        });

        it('should NOT show refinement buttons before enhancement', () => {
            const webviewContent = voicePanel.getWebviewContent();
            assert.ok(webviewContent.includes('display: none;'));
        });
    });

    // TEST 2: Refine button (add more detail)
    describe('[Refine] button', () => {
        it('should add detail instruction to AI when clicked', async () => {
            let refinementFeedback: string | undefined;

            // Mock AI service to capture refinement feedback
            mockAIService.enhance = async (context, feedback) => {
                refinementFeedback = feedback;
                return 'Refined prompt with more detail';
            };

            // Simulate enhancement
            await voicePanel.handleEnhancePrompt('bug', mockFormData);

            // Simulate [Refine] button click
            await voicePanel.handleRefinement({
                type: 'refine',
                originalContext: mockContext
            });

            assert.ok(refinementFeedback);
            assert.ok(refinementFeedback.includes('Include more examples'));
            assert.ok(refinementFeedback.includes('guidance'));
        });
    });

    // TEST 3: Simplify button (make concise)
    describe('[Simplify] button', () => {
        it('should add concise instruction to AI when clicked', async () => {
            let refinementFeedback: string | undefined;

            mockAIService.enhance = async (context, feedback) => {
                refinementFeedback = feedback;
                return 'Simplified prompt';
            };

            await voicePanel.handleEnhancePrompt('bug', mockFormData);

            await voicePanel.handleRefinement({
                type: 'simplify',
                originalContext: mockContext
            });

            assert.ok(refinementFeedback);
            assert.ok(refinementFeedback.includes('concise'));
            assert.ok(refinementFeedback.includes('remove verbose'));
        });
    });

    // TEST 4: Add Detail button (with user input)
    describe('[Add Detail] button', () => {
        it('should show input modal when clicked', async () => {
            await voicePanel.handleEnhancePrompt('bug', mockFormData);

            // Simulate [Add Detail] button click
            const modalShown = await voicePanel.handleRefinement({
                type: 'add-detail-modal'
            });

            assert.strictEqual(modalShown, true);
        });

        it('should use user input for refinement', async () => {
            let refinementFeedback: string | undefined;

            mockAIService.enhance = async (context, feedback) => {
                refinementFeedback = feedback;
                return 'Refined with detail';
            };

            await voicePanel.handleEnhancePrompt('bug', mockFormData);

            await voicePanel.handleRefinement({
                type: 'add-detail',
                userInput: 'Add more about error handling in authentication',
                originalContext: mockContext
            });

            assert.ok(refinementFeedback);
            assert.ok(refinementFeedback.includes('error handling'));
            assert.ok(refinementFeedback.includes('authentication'));
        });
    });

    // TEST 5: Include Pattern button (with dropdown)
    describe('[Include Pattern] button', () => {
        it('should show pattern dropdown when clicked', async () => {
            await voicePanel.handleEnhancePrompt('bug', mockFormData);

            const modalShown = await voicePanel.handleRefinement({
                type: 'include-pattern-modal'
            });

            assert.strictEqual(modalShown, true);
        });

        it('should populate pattern dropdown with available patterns', async () => {
            await voicePanel.handleEnhancePrompt('bug', mockFormData);

            const patterns = await voicePanel.getAvailablePatterns();

            assert.ok(patterns.length > 0);
            assert.ok(patterns.some(p => p.includes('Pattern-TDD-001')));
            assert.ok(patterns.some(p => p.includes('Pattern-CODE-001')));
        });

        it('should include selected pattern in refinement', async () => {
            let refinementFeedback: string | undefined;

            mockAIService.enhance = async (context, feedback) => {
                refinementFeedback = feedback;
                return 'Refined with pattern';
            };

            await voicePanel.handleEnhancePrompt('bug', mockFormData);

            await voicePanel.handleRefinement({
                type: 'include-pattern',
                patternId: 'Pattern-TDD-001',
                originalContext: mockContext
            });

            assert.ok(refinementFeedback);
            assert.ok(refinementFeedback.includes('Pattern-TDD-001'));
        });
    });

    // TEST 6: Re-enhancement produces updated prompt
    describe('Re-enhancement', () => {
        it('should trigger AI re-enhancement with feedback', async () => {
            let enhanceCallCount = 0;

            mockAIService.enhance = async (context, feedback) => {
                enhanceCallCount++;
                return feedback ? 'Refined prompt' : 'Original prompt';
            };

            // Initial enhancement
            await voicePanel.handleEnhancePrompt('bug', mockFormData);
            assert.strictEqual(enhanceCallCount, 1);

            // Refinement (re-enhancement)
            await voicePanel.handleRefinement({
                type: 'refine',
                originalContext: mockContext
            });

            assert.strictEqual(enhanceCallCount, 2);
        });

        it('should replace text area content with refined prompt', async () => {
            mockAIService.enhance = async (context, feedback) => {
                return feedback ? 'REFINED PROMPT' : 'ORIGINAL PROMPT';
            };

            await voicePanel.handleEnhancePrompt('bug', mockFormData);
            let webviewContent = voicePanel.getWebviewContent();
            assert.ok(webviewContent.includes('ORIGINAL PROMPT'));

            await voicePanel.handleRefinement({
                type: 'refine',
                originalContext: mockContext
            });

            webviewContent = voicePanel.getWebviewContent();
            assert.ok(webviewContent.includes('REFINED PROMPT'));
        });
    });

    // TEST 7: Iterative refinement (multiple times)
    describe('Iterative refinement', () => {
        it('should allow refinement after refinement (iterative)', async () => {
            let callCount = 0;

            mockAIService.enhance = async () => {
                callCount++;
                return `Prompt iteration ${callCount}`;
            };

            // Initial
            await voicePanel.handleEnhancePrompt('bug', mockFormData);
            assert.strictEqual(callCount, 1);

            // Refinement 1
            await voicePanel.handleRefinement({ type: 'refine', originalContext: mockContext });
            assert.strictEqual(callCount, 2);

            // Refinement 2
            await voicePanel.handleRefinement({ type: 'simplify', originalContext: mockContext });
            assert.strictEqual(callCount, 3);

            // Verify refinement buttons still visible
            const webviewContent = voicePanel.getWebviewContent();
            assert.ok(webviewContent.includes('refinement-buttons'));
        });
    });

    // TEST 8: Undo button
    describe('[Undo] button', () => {
        it('should revert to previous prompt version', async () => {
            mockAIService.enhance = async (context, feedback) => {
                return feedback ? 'REFINED' : 'ORIGINAL';
            };

            await voicePanel.handleEnhancePrompt('bug', mockFormData);
            let content = voicePanel.getWebviewContent();
            assert.ok(content.includes('ORIGINAL'));

            await voicePanel.handleRefinement({ type: 'refine', originalContext: mockContext });
            content = voicePanel.getWebviewContent();
            assert.ok(content.includes('REFINED'));

            // Undo
            await voicePanel.handleRefinement({ type: 'undo' });
            content = voicePanel.getWebviewContent();
            assert.ok(content.includes('ORIGINAL'));
        });
    });

    // TEST 9: Error handling
    describe('Error handling', () => {
        it('should preserve original prompt if refinement fails', async () => {
            mockAIService.enhance = async (context, feedback) => {
                if (feedback) {
                    throw new Error('AI refinement failed');
                }
                return 'ORIGINAL';
            };

            await voicePanel.handleEnhancePrompt('bug', mockFormData);

            // Attempt refinement (will fail)
            await voicePanel.handleRefinement({ type: 'refine', originalContext: mockContext });

            // Verify original prompt preserved
            const content = voicePanel.getWebviewContent();
            assert.ok(content.includes('ORIGINAL'));
        });
    });

    // TEST 10: Metadata updates
    describe('Metadata updates', () => {
        it('should update metadata with refinement history', async () => {
            await voicePanel.handleEnhancePrompt('bug', mockFormData);
            await voicePanel.handleRefinement({ type: 'refine', originalContext: mockContext });
            await voicePanel.handleRefinement({ type: 'simplify', originalContext: mockContext });

            const metadata = voicePanel.getEnhancementMetadata();

            assert.ok(metadata.refinementHistory);
            assert.strictEqual(metadata.refinementHistory.length, 2);
            assert.strictEqual(metadata.refinementHistory[0].type, 'refine');
            assert.strictEqual(metadata.refinementHistory[1].type, 'simplify');
        });
    });
});

// Helper function
function createMockContext(type: string): any {
    return {
        type: type,
        template: { id: 'TEST-001', name: 'Test', /* ... */ },
        metadata: { /* ... */ },
        workspaceContext: { /* ... */ },
        specificContext: {}
    };
}
```

### Run Tests (Expected to FAIL - RED Phase)

```bash
cd vscode-lumina
npm test -- --grep "Refinement UI"
```

**Expected Output:**
```
VoicePanelCommand - Refinement UI
  âŒ should show refinement buttons after enhancement completes
  Error: handleRefinement is not a function

  âŒ should add detail instruction to AI when clicked
  ...

  0 passing (42ms)
  10 failing
```

**Status:** âœ… RED phase complete (tests exist, implementation missing)

---

## Step 3: Implementation - Refinement UI (GREEN Phase)

### File Modifications

**File:** `vscode-lumina/src/commands/voicePanel.ts`

**Add refinement handling methods:**

```typescript
/**
 * Handle prompt refinement
 *
 * Called when user clicks refinement button (Refine, Simplify, Add Detail, Include Pattern)
 * Re-enhances the prompt with user feedback
 *
 * @param message - Refinement message from webview
 */
private async handleRefinement(message: any): Promise<void> {
    try {
        const { type, originalContext, userInput, patternId } = message;

        // Build refinement feedback instruction
        let refinementFeedback = '';

        switch (type) {
            case 'refine':
                refinementFeedback = 'Include more examples and guidance. Add more context and detail to make the prompt more comprehensive.';
                break;

            case 'simplify':
                refinementFeedback = 'Make this prompt concise. Remove verbose sections. Keep only essential information.';
                break;

            case 'add-detail':
                refinementFeedback = `Expand this specific area: ${userInput}. Add more detail and examples.`;
                break;

            case 'include-pattern':
                refinementFeedback = `Include guidance from ${patternId}. Apply this pattern to the prompt.`;
                break;

            case 'undo':
                // Revert to previous version
                this.revertToPreviousPrompt();
                return;

            default:
                throw new Error(`Unknown refinement type: ${type}`);
        }

        // Store current prompt in history (for undo)
        this.pushToPromptHistory(this.currentEnhancedPrompt);

        // Re-enhance with feedback
        console.log(`[VoicePanel] Re-enhancing with feedback: ${refinementFeedback}`);

        const refinedPrompt = await this.aiEnhancementService.enhance(
            originalContext,
            refinementFeedback
        );

        // Update webview with refined prompt
        this.currentEnhancedPrompt = refinedPrompt;
        this.updateTextArea(refinedPrompt);

        // Update metadata with refinement history
        this.updateRefinementHistory({
            type: type,
            feedback: refinementFeedback,
            timestamp: new Date().toISOString()
        });

        vscode.window.showInformationMessage('Prompt refined successfully');

    } catch (error) {
        console.error('[VoicePanel] Refinement failed:', error);
        vscode.window.showErrorMessage(`Refinement failed: ${error.message}`);
    }
}

/**
 * Get available patterns for dropdown
 */
private async getAvailablePatterns(): Promise<string[]> {
    try {
        const fs = require('fs');
        const path = require('path');
        const glob = require('glob');

        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || process.cwd();
        const patternsDir = path.join(workspaceRoot, 'docs', 'patterns');

        // Find all Pattern-*.md files
        const patternFiles = glob.sync(path.join(patternsDir, 'Pattern-*.md'));

        // Extract pattern IDs from filenames
        const patterns = patternFiles.map((file: string) => {
            const basename = path.basename(file, '.md');
            return basename;
        });

        return patterns.sort();

    } catch (error) {
        console.warn('[VoicePanel] Failed to load patterns:', error);
        return [
            'Pattern-CODE-001',
            'Pattern-TDD-001',
            'Pattern-SPRINT-PLAN-001',
            'Pattern-GIT-001'
        ];
    }
}

/**
 * Push current prompt to history (for undo)
 */
private promptHistory: string[] = [];
private currentEnhancedPrompt: string = '';

private pushToPromptHistory(prompt: string): void {
    this.promptHistory.push(prompt);
    // Limit history to last 10 prompts
    if (this.promptHistory.length > 10) {
        this.promptHistory.shift();
    }
}

/**
 * Revert to previous prompt version
 */
private revertToPreviousPrompt(): void {
    if (this.promptHistory.length === 0) {
        vscode.window.showWarningMessage('No previous version to revert to');
        return;
    }

    const previousPrompt = this.promptHistory.pop();
    if (previousPrompt) {
        this.currentEnhancedPrompt = previousPrompt;
        this.updateTextArea(previousPrompt);
        vscode.window.showInformationMessage('Reverted to previous version');
    }
}

/**
 * Update text area with new content
 */
private updateTextArea(content: string): void {
    if (this.webviewPanel) {
        this.webviewPanel.webview.postMessage({
            command: 'updateTextArea',
            content: content
        });
    }
}

/**
 * Update refinement history in metadata
 */
private refinementHistory: Array<{ type: string; feedback: string; timestamp: string }> = [];

private updateRefinementHistory(refinement: { type: string; feedback: string; timestamp: string }): void {
    this.refinementHistory.push(refinement);
}

/**
 * Get enhancement metadata (including refinement history)
 */
getEnhancementMetadata(): any {
    return {
        // ... existing metadata ...
        refinementHistory: this.refinementHistory,
        iterationCount: this.refinementHistory.length
    };
}

/**
 * Update webview HTML to include refinement buttons
 */
private getWebviewHTML(): string {
    return `
    <!DOCTYPE html>
    <html>
    <head>
        <style>
            /* ... existing styles ... */

            .refinement-container {
                margin-top: 16px;
                padding: 12px;
                background: var(--vscode-editor-inactiveSelectionBackground);
                border-radius: 6px;
                border: 1px solid var(--vscode-panel-border);
            }

            .confidence-badge {
                margin-bottom: 8px;
                font-size: 13px;
                color: var(--vscode-descriptionForeground);
            }

            .refinement-actions {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }

            .refinement-btn {
                padding: 6px 12px;
                font-size: 13px;
                border: 1px solid var(--vscode-button-border);
                background: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                border-radius: 4px;
                cursor: pointer;
                display: flex;
                align-items: center;
                gap: 4px;
            }

            .refinement-btn:hover {
                background: var(--vscode-button-hoverBackground);
            }

            .refinement-btn .icon {
                font-size: 14px;
            }

            .revert-btn {
                margin-left: auto;
                background: var(--vscode-button-secondaryBackground);
            }

            .modal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                display: none;
                align-items: center;
                justify-content: center;
            }

            .modal.show {
                display: flex;
            }

            .modal-content {
                background: var(--vscode-editor-background);
                padding: 20px;
                border-radius: 8px;
                min-width: 400px;
                border: 1px solid var(--vscode-panel-border);
            }

            .modal-content h3 {
                margin-top: 0;
            }

            .modal-content textarea {
                width: 100%;
                min-height: 80px;
                margin: 12px 0;
                padding: 8px;
                background: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
                border: 1px solid var(--vscode-input-border);
            }

            .modal-actions {
                display: flex;
                gap: 8px;
                justify-content: flex-end;
            }
        </style>
    </head>
    <body>
        <div class="text-area-container">
            <textarea id="enhanced-prompt" readonly></textarea>

            <!-- Refinement buttons (hidden initially) -->
            <div id="refinement-buttons" class="refinement-container" style="display: none;">
                <div class="confidence-badge">
                    <span>Confidence: <strong id="confidence-level">High (92%)</strong></span>
                </div>

                <div class="refinement-actions">
                    <button class="refinement-btn" onclick="refine()">
                        <span class="icon">âœ¨</span> Refine
                    </button>
                    <button class="refinement-btn" onclick="simplify()">
                        <span class="icon">âš¡</span> Simplify
                    </button>
                    <button class="refinement-btn" onclick="showAddDetailModal()">
                        <span class="icon">ğŸ“</span> Add Detail
                    </button>
                    <button class="refinement-btn" onclick="showPatternModal()">
                        <span class="icon">ğŸ¯</span> Include Pattern
                    </button>
                    <button class="refinement-btn revert-btn" onclick="undo()">
                        <span class="icon">â†©ï¸</span> Undo
                    </button>
                </div>
            </div>

            <button id="send-to-terminal">Send to Terminal â–¼</button>
        </div>

        <!-- Add Detail Modal -->
        <div id="add-detail-modal" class="modal">
            <div class="modal-content">
                <h3>Add Detail - What area should be expanded?</h3>
                <textarea id="detail-input" placeholder="e.g., 'Add more about error handling'"></textarea>
                <div class="modal-actions">
                    <button onclick="submitDetail()">Add Detail</button>
                    <button onclick="hideAddDetailModal()">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Include Pattern Modal -->
        <div id="pattern-modal" class="modal">
            <div class="modal-content">
                <h3>Include Pattern - Select pattern to add</h3>
                <select id="pattern-select">
                    <option value="">-- Select Pattern --</option>
                </select>
                <div class="modal-actions">
                    <button onclick="submitPattern()">Include Pattern</button>
                    <button onclick="hidePatternModal()">Cancel</button>
                </div>
            </div>
        </div>

        <script>
            const vscode = acquireVsCodeApi();
            let originalContext = null;

            // Listen for messages from extension
            window.addEventListener('message', event => {
                const message = event.data;

                switch (message.command) {
                    case 'updateTextArea':
                        document.getElementById('enhanced-prompt').value = message.content;
                        break;

                    case 'showRefinementButtons':
                        document.getElementById('refinement-buttons').style.display = 'block';
                        document.getElementById('confidence-level').textContent = message.confidence;
                        originalContext = message.context;
                        break;

                    case 'populatePatterns':
                        const select = document.getElementById('pattern-select');
                        message.patterns.forEach(pattern => {
                            const option = document.createElement('option');
                            option.value = pattern;
                            option.textContent = pattern;
                            select.appendChild(option);
                        });
                        break;
                }
            });

            // Refinement button handlers
            function refine() {
                vscode.postMessage({
                    command: 'refinement',
                    type: 'refine',
                    originalContext: originalContext
                });
            }

            function simplify() {
                vscode.postMessage({
                    command: 'refinement',
                    type: 'simplify',
                    originalContext: originalContext
                });
            }

            function showAddDetailModal() {
                document.getElementById('add-detail-modal').classList.add('show');
            }

            function hideAddDetailModal() {
                document.getElementById('add-detail-modal').classList.remove('show');
            }

            function submitDetail() {
                const userInput = document.getElementById('detail-input').value;
                if (!userInput) {
                    alert('Please enter what area to expand');
                    return;
                }

                vscode.postMessage({
                    command: 'refinement',
                    type: 'add-detail',
                    userInput: userInput,
                    originalContext: originalContext
                });

                hideAddDetailModal();
                document.getElementById('detail-input').value = '';
            }

            function showPatternModal() {
                document.getElementById('pattern-modal').classList.add('show');

                // Request patterns from extension
                vscode.postMessage({ command: 'getPatterns' });
            }

            function hidePatternModal() {
                document.getElementById('pattern-modal').classList.remove('show');
            }

            function submitPattern() {
                const patternId = document.getElementById('pattern-select').value;
                if (!patternId) {
                    alert('Please select a pattern');
                    return;
                }

                vscode.postMessage({
                    command: 'refinement',
                    type: 'include-pattern',
                    patternId: patternId,
                    originalContext: originalContext
                });

                hidePatternModal();
            }

            function undo() {
                vscode.postMessage({
                    command: 'refinement',
                    type: 'undo'
                });
            }
        </script>
    </body>
    </html>
    `;
}

/**
 * Add message handler for refinement
 */
this.webviewPanel.webview.onDidReceiveMessage(
    async (message) => {
        switch (message.command) {
            case 'refinement':
                await this.handleRefinement(message);
                break;

            case 'getPatterns':
                const patterns = await this.getAvailablePatterns();
                this.webviewPanel?.webview.postMessage({
                    command: 'populatePatterns',
                    patterns: patterns
                });
                break;

            // ... existing message handlers ...
        }
    }
);
```

---

## Step 4: Validation & Testing

### Run Tests (Expected to PASS - GREEN Phase)

```bash
cd vscode-lumina
npm run compile
npm test -- --grep "Refinement UI"
```

**Expected Output:**
```
VoicePanelCommand - Refinement UI
  Refinement button visibility
    âœ“ should show refinement buttons after enhancement completes (78ms)
    âœ“ should NOT show refinement buttons before enhancement (23ms)
  [Refine] button
    âœ“ should add detail instruction to AI when clicked (89ms)
  [Simplify] button
    âœ“ should add concise instruction to AI when clicked (76ms)
  [Add Detail] button
    âœ“ should show input modal when clicked (45ms)
    âœ“ should use user input for refinement (92ms)
  [Include Pattern] button
    âœ“ should show pattern dropdown when clicked (51ms)
    âœ“ should populate pattern dropdown with available patterns (67ms)
    âœ“ should include selected pattern in refinement (83ms)
  Re-enhancement
    âœ“ should trigger AI re-enhancement with feedback (94ms)
    âœ“ should replace text area content with refined prompt (71ms)
  Iterative refinement
    âœ“ should allow refinement after refinement (iterative) (112ms)
  [Undo] button
    âœ“ should revert to previous prompt version (58ms)
  Error handling
    âœ“ should preserve original prompt if refinement fails (49ms)
  Metadata updates
    âœ“ should update metadata with refinement history (73ms)

15 passing (961ms)
```

**Status:** âœ… GREEN phase complete

---

## Step 5: Manual Testing

### Test Refinement Workflow

1. Launch Extension Development Host (F5)
2. Click Ã†therLight icon â†’ Bug Report button
3. Fill form and click "Enhance"
4. **Verify refinement buttons appear** below text area
5. Test each button:

**Test [Refine] button:**
- Click "Refine"
- Verify prompt updates with more detail
- Verify refinement buttons still visible (can refine again)

**Test [Simplify] button:**
- Click "Simplify"
- Verify prompt becomes more concise

**Test [Add Detail] button:**
- Click "Add Detail"
- Modal appears with text input
- Enter "Add more about authentication flow"
- Click "Add Detail"
- Verify prompt expands that specific area

**Test [Include Pattern] button:**
- Click "Include Pattern"
- Modal appears with pattern dropdown
- Select "Pattern-TDD-001"
- Click "Include Pattern"
- Verify prompt includes TDD guidance

**Test [Undo] button:**
- Click "Undo"
- Verify prompt reverts to previous version

**Test iterative refinement:**
- Refine â†’ Simplify â†’ Add Detail â†’ Undo â†’ Refine again
- Verify each iteration works correctly

---

## Step 6: Documentation & Commit

### Update Task Status

**File:** `internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml`

Mark ENHANCE-001.7 as completed:

```toml
[tasks."ENHANCE-001.7"]
status = "completed"
```

### Commit Changes

```bash
git add vscode-lumina/src/commands/voicePanel.ts
git add vscode-lumina/test/commands/voicePanel-refinement.test.ts
git add internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml

git commit -m "feat(ENHANCE-001.7): Implement iterative refinement UI

- Add refinement button container to webview HTML
- Add 4 refinement buttons: Refine, Simplify, Add Detail, Include Pattern
- Add refinement message handlers in voicePanel
- Integrate with AIEnhancementService for re-enhancement
- Add pattern dropdown (loads from docs/patterns/)
- Support iterative refinement (can refine multiple times)
- Add [Undo] button to revert to previous version
- Track refinement history in metadata (iteration count)
- Preserve prompt history (last 10 versions)
- Add modals for Add Detail and Include Pattern inputs
- Add unit tests (70% coverage)
- Refinement performance < 3 seconds

Users can now refine enhancements without restarting:
- [Refine]: Add more examples and guidance
- [Simplify]: Make concise, remove verbose sections
- [Add Detail]: Expand specific user-specified areas
- [Include Pattern]: Add pattern guidance
- [Undo]: Revert to previous version

Closes ENHANCE-001.7"
```

---

## Success Criteria

After ENHANCE-001.7 complete:

âœ… **Users can refine enhancements without restarting**
- Refinement buttons appear after enhancement

âœ… **Iterative improvement until satisfied**
- Can refine multiple times, buttons remain visible

âœ… **4 refinement types work correctly**
- Refine (add detail), Simplify (concise), Add Detail (expand area), Include Pattern (add pattern)

âœ… **Better user experience (no form re-filling)**
- Refine in place, no need to go back to form

âœ… **AI produces better results (user feedback loop)**
- Refinement feedback improves AI output quality

âœ… **Faster workflow (refine in place vs restart)**
- < 3 seconds per refinement

---

## Next Steps

After ENHANCE-001.7 is implemented and tests pass:

1. **ENHANCE-001.8:** Context Preview & Override UI (show context before enhancement)
2. **ENHANCE-001.9:** Progressive Loading UI (streaming enhancement display)

---

## Pattern References

- **Pattern-CODE-001:** Code development workflow
- **Pattern-TDD-001:** Test-driven development (RED â†’ GREEN â†’ REFACTOR)
- **Pattern-UX-001:** User experience design (iterative refinement)
- **Pattern-TASK-ANALYSIS-001:** 8-step pre-task analysis
- **Pattern-GIT-001:** Git workflow integration

---

**Template Version:** MVP-003-PromptEnhancer-TaskTemplate-v1.4.3
**Generated:** 2025-01-13
**For:** ENHANCE-001.7 (Iterative Refinement UI - Re-enhance with User Feedback)
