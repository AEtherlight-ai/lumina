# Enhanced Task Prompt: BUG-004

**Generated**: 2025-01-13
**Sprint**: Sprint 17.1 - Desktop Authentication Bug Fixes
**Task ID**: BUG-004
**Status**: pending
**Agent**: tauri-desktop-agent
**Enhanced Prompt**: internal/sprints/enhanced_prompts/BUG-004_ENHANCED_PROMPT.md
**Template**: MVP-003-PromptEnhancer-TaskTemplate-v1.4.3

---

## ‚ö†Ô∏è MANDATORY: Pre-Task Analysis (Pattern-TASK-ANALYSIS-001)

**STOP. Before reading ANY code or writing ANY solution, complete this 8-step analysis OUT LOUD:**

### 8-Step Pre-Task Analysis

1. ‚úÖ **Understand the Problem**
   - What is broken? Desktop app shows generic errors for 401/402/403 API responses with no actionable resolution
   - What are the symptoms? Users see "Transcription failed: ..." with no guidance on how to fix license/token/activation issues

2. ‚úÖ **Identify Root Cause**
   - Why is it broken? Error handling in transcription.rs doesn't inspect HTTP status codes or parse error payloads
   - Is this a symptom of a deeper problem? Yes - missing error classification system and frontend event emission

3. ‚úÖ **Define Success Criteria**
   - How do I know when it's fixed? Each error type (401/402/403/500) triggers specific, actionable UI response
   - What does "done" look like? Users see clear error messages with action buttons (re-activate, upgrade, retry)

4. ‚úÖ **List Dependencies**
   - What other tasks/files/systems does this affect? BUG-002 (license validation) must be complete first
   - What needs to be done first? BUG-002 provides license activation flow that 401/403 errors will trigger
   - What does this unblock? BUG-005 (frontend activation dialog) can use the error classification system

5. ‚úÖ **Estimate Complexity**
   - Simple fix (< 1 hour) or complex refactor (> 4 hours)? Medium complexity - 3-4 hours
   - Single file or multi-file change? Multi-file (transcription.rs, main.rs, ErrorDialog.tsx - new)

6. ‚úÖ **Choose Approach**
   - What's the best way to solve this? Create error classification enum + parse HTTP status codes + emit events to frontend
   - Are there alternative approaches? Could handle all errors in main.rs hotkey handler, but transcription.rs is better separation of concerns
   - Why is this one best? Error parsing belongs in transcription module, keeps hotkey handler simple

7. ‚úÖ **Identify Risks**
   - What could go wrong? API error format changes could break parsing
   - What could break? Existing error handling tests (if any)
   - What are the edge cases? Network errors (no status code), malformed JSON responses, mixed error types

8. ‚úÖ **Plan Testing**
   - How will I validate this works? Manual testing with mock API responses (401/402/403/500)
   - What tests need to be written? Unit tests for error parsing, integration tests for frontend event emission

### Code Workflow Announcement (Pattern-CODE-001)

**Before starting Step 1 (Implementation), announce OUT LOUD:**

"I am about to start coding for task BUG-004. I have completed:
‚úÖ Pattern-TASK-ANALYSIS-001 (8-step pre-task analysis - see above)
‚úÖ Ready to proceed with Pattern-GIT-001 (Git status check)
‚úÖ Ready to proceed with Pattern-TDD-001 (Write tests FIRST)
‚úÖ Ready to proceed with Pattern-TRACKING-001 (TodoWrite tracking)

I am now proceeding with implementation."

---

## Task Overview

**Name**: Improve error handling for 401/402/403 API responses

**Why**:

Insufficient Error Handling: Desktop app doesn't handle specific API errors properly.

Current Behavior:
- 401 (Invalid license) ‚Üí Generic error, no re-activation prompt
- 402 (Insufficient tokens) ‚Üí Generic error, no upgrade prompt
- 403 (Device not active) ‚Üí Generic error, no activation prompt

Expected Behavior (from documentation):
- 401 ‚Üí Clear error message + prompt for new license key + show activation dialog
- 402 ‚Üí Show token balance + "Upgrade or purchase tokens" button
- 403 ‚Üí Show "Device not active" + activation dialog

Impact: Users see generic errors with no actionable resolution path.
Severity: MEDIUM - Poor UX, but workarounds exist.

**Current State (BROKEN)**:
- File: `products/lumina-desktop/src-tauri/src/main.rs:553-560`
- Issue: Hotkey handler uses generic error string, doesn't inspect status codes
- File: `products/lumina-desktop/src-tauri/src/transcription.rs:214-260`
- Issue: `transcribe_audio()` doesn't parse HTTP status codes or error payloads

**Required State (CORRECT)**:
- File: `products/lumina-desktop/src-tauri/src/transcription.rs:214-260`
- Fix: Parse HTTP status codes (401/402/403/500), classify errors, return structured error enum
- File: `products/lumina-desktop/src-tauri/src/main.rs:553-560`
- Fix: Handle structured errors, emit events to frontend based on error type
- File: `products/lumina-desktop/src/components/ErrorDialog.tsx` (NEW)
- Fix: Create error dialogs with action buttons for each error type

**Impact**: Users get self-service error resolution, reduced support burden

**Severity**: MEDIUM

---

## Context Gathered

### Git Status
- **Branch**: feature/v0.17.2-bug-fixes
- **Status**: Clean (from conversation context)
- **Ready for**: BUG-004 implementation

### Sprint TOML
- **File**: `internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml`
- **Task Entry**: Lines 1192-1286
- **Management**: Use `/sprint-task-lifecycle` skill (see Pattern-TRACKING-001)

### Related Files

1. `products/lumina-desktop/src-tauri/src/main.rs:553-560` - Hotkey handler error handling (MUST UPDATE)
2. `products/lumina-desktop/src-tauri/src/transcription.rs:214-260` - transcribe_audio error parsing (MUST UPDATE)
3. `products/lumina-desktop/src/components/ErrorDialog.tsx` - Error UI with actions (MUST CREATE)
4. `products/lumina-desktop/src-tauri/src/auth.rs` - Reference for API error format (REFERENCE ONLY)

### Current Error Handling Code

**main.rs:553-560** (simplified):
```rust
let transcript = transcription::transcribe_audio(...)
    .await
    .map_err(|e| format!("Transcription failed: {}", e))?;
```

**Problem**: Generic string error, no status code inspection

**transcription.rs:214-260** (needs inspection - read during Step 1)

### API Error Responses (from context)

- **401**: `{ "error": "Invalid license key" }`
- **402**: `{ "error": "Insufficient tokens", "balance_tokens": 100, "required_tokens": 32 }`
- **403**: `{ "error": "Device is not active" }`
- **500**: `{ "error": "Internal server error" }`

### Patterns Referenced
- **Pattern-TASK-ANALYSIS-001**: 8-step pre-task analysis (MANDATORY)
- **Pattern-CODE-001**: Code workflow + announcement (MANDATORY)
- **Pattern-TRACKING-001**: Task tracking + Sprint TOML lifecycle
- **Pattern-GIT-001**: Git workflow integration
- **Pattern-TDD-001**: Test-driven development
- **Pattern-VALIDATION-001**: Pre-flight checklist enforcement
- **Pattern-COMPLETION-001**: Post-completion documentation (Step N-2)

---

## Pre-Flight Checklist

**STOP. Complete Pattern-VALIDATION-001 checklist OUT LOUD:**

‚úÖ Did I read target files first? (Never edit without reading)
‚úÖ Did I verify format/structure? (Read parser code if unsure)
‚úÖ Did I check Sprint TOML format? (SprintLoader.ts:292-333)
‚úÖ Did I validate dependencies? (BUG-002 complete - YES)

**Full Checklist**: Pattern-VALIDATION-001 (4 categories, 15+ questions)

**Automated Validation**: Pre-commit hooks run 8 validators automatically

---

## Implementation Steps (TDD Approach)

**Patterns**: Pattern-TDD-001 (RED ‚Üí GREEN ‚Üí REFACTOR), Pattern-GIT-001 (Git workflow), Pattern-TRACKING-001 (Sprint TOML lifecycle)

**REMINDER**: If you haven't completed Section 0 (Pre-Task Analysis + Code Workflow Announcement), STOP and complete it NOW.

### Step 0: Git Status + Sprint TOML Update (2 min)

**Update Sprint Status**:
```bash
/sprint-task-lifecycle start BUG-004
```

**Fallback** (if skill unavailable): Follow Pattern-TRACKING-001 manual process

**Check Git Status**:
```bash
git status
git branch --show-current
```

**Goal**: Status = "in_progress", on feature/v0.17.2-bug-fixes branch, clean working tree

---

### Step 1: Read Current Error Handling Code (10 min)
**Tool**: Read

**Files to Read**:
1. `products/lumina-desktop/src-tauri/src/transcription.rs:214-260` (transcribe_audio function)
2. `products/lumina-desktop/src-tauri/src/main.rs:553-560` (hotkey handler)
3. `products/lumina-desktop/src-tauri/src/auth.rs` (reference for API error format from BUG-002)

**Goal**: Understand current error handling, identify where to add status code parsing

**What to Look For**:
- How does transcribe_audio() make HTTP requests?
- What HTTP client library is used? (reqwest, ureq, etc.)
- Where does error conversion happen?
- Is there existing error enum or just strings?

---

### Step 2: Design Error Classification System (15 min)
**Tool**: Write (design doc - optional) or just plan in comments

**Goal**: Create structured error enum with classification

**Design Decision**: Create `TranscriptionError` enum with variants:

```rust
#[derive(Debug)]
pub enum TranscriptionError {
    Unauthorized { message: String },          // 401 - Invalid license
    PaymentRequired {                           // 402 - Insufficient tokens
        message: String,
        balance_tokens: u32,
        required_tokens: u32,
    },
    Forbidden { message: String },             // 403 - Device not active
    NotFound { message: String },               // 404 - API endpoint missing
    ServerError { message: String },            // 500 - Temporary failure
    NetworkError { message: String },           // Connection failed
    ParseError { message: String },             // Response parse failed
}
```

**Frontend Event Mapping**:
- `Unauthorized` ‚Üí Emit "show-license-activation"
- `PaymentRequired` ‚Üí Emit "show-token-purchase"
- `Forbidden` ‚Üí Emit "show-device-activation"
- `ServerError` ‚Üí Emit "show-retry-dialog"
- `NetworkError` ‚Üí Emit "show-retry-dialog"

---

### Step 3: Write Tests FIRST - RED Phase (20 min)
**Pattern**: Pattern-TDD-001 (full workflow details in pattern)

**Test File**: `products/lumina-desktop/src-tauri/src/transcription.rs` (add `#[cfg(test)]` module at end)

**Tests to Write**:

1. **test_parse_401_unauthorized**
   - Mock response: 401 status + `{"error": "Invalid license key"}`
   - Assert: Returns `TranscriptionError::Unauthorized`

2. **test_parse_402_payment_required**
   - Mock response: 402 status + `{"error": "Insufficient tokens", "balance_tokens": 100, "required_tokens": 32}`
   - Assert: Returns `TranscriptionError::PaymentRequired` with correct token counts

3. **test_parse_403_forbidden**
   - Mock response: 403 status + `{"error": "Device is not active"}`
   - Assert: Returns `TranscriptionError::Forbidden`

4. **test_parse_500_server_error**
   - Mock response: 500 status + `{"error": "Internal server error"}`
   - Assert: Returns `TranscriptionError::ServerError`

5. **test_network_error**
   - Mock: Connection timeout or DNS failure
   - Assert: Returns `TranscriptionError::NetworkError`

**Expected Result**: Tests FAIL (RED) because `TranscriptionError` enum doesn't exist yet

**Test Framework**: Use `#[cfg(test)]` module with `#[tokio::test]` for async tests

---

### Step 4: Create TranscriptionError Enum (15 min) - GREEN Phase
**Pattern**: Pattern-TDD-001
**Tool**: Edit
**File**: `products/lumina-desktop/src-tauri/src/transcription.rs`

**Goal**: Add error enum definition at top of file (after imports)

**Code to Add**:
```rust
use serde::Deserialize;
use anyhow::{Context, Result};

/// API error response format
#[derive(Debug, Deserialize)]
struct ApiErrorResponse {
    error: String,
    #[serde(default)]
    balance_tokens: Option<u32>,
    #[serde(default)]
    required_tokens: Option<u32>,
}

/// Transcription errors with status code classification
#[derive(Debug)]
pub enum TranscriptionError {
    Unauthorized { message: String },
    PaymentRequired {
        message: String,
        balance_tokens: u32,
        required_tokens: u32,
    },
    Forbidden { message: String },
    NotFound { message: String },
    ServerError { message: String },
    NetworkError { message: String },
    ParseError { message: String },
}

impl std::fmt::Display for TranscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unauthorized { message } => write!(f, "Unauthorized: {}", message),
            Self::PaymentRequired { message, balance_tokens, required_tokens } => {
                write!(f, "Payment Required: {} (balance: {}, required: {})", message, balance_tokens, required_tokens)
            }
            Self::Forbidden { message } => write!(f, "Forbidden: {}", message),
            Self::NotFound { message } => write!(f, "Not Found: {}", message),
            Self::ServerError { message } => write!(f, "Server Error: {}", message),
            Self::NetworkError { message } => write!(f, "Network Error: {}", message),
            Self::ParseError { message } => write!(f, "Parse Error: {}", message),
        }
    }
}

impl std::error::Error for TranscriptionError {}
```

**Location**: Add after imports, before `transcribe_audio()` function

---

### Step 5: Update transcribe_audio() Error Handling (30 min) - GREEN Phase
**Tool**: Edit
**File**: `products/lumina-desktop/src-tauri/src/transcription.rs:214-260`

**Goal**: Parse HTTP status codes, classify errors, return `Result<String, TranscriptionError>`

**Changes to Make**:

1. **Change function signature**:
   ```rust
   pub async fn transcribe_audio(
       audio_path: &str,
       api_url: &str,
       license_key: &str,
   ) -> Result<String, TranscriptionError>
   ```

2. **Add status code inspection after HTTP request**:
   ```rust
   let response = client
       .post(&endpoint)
       .json(&payload)
       .send()
       .await
       .map_err(|e| TranscriptionError::NetworkError {
           message: format!("Connection failed: {}", e),
       })?;

   let status = response.status();

   if !status.is_success() {
       // Parse error response
       let error_body: ApiErrorResponse = response
           .json()
           .await
           .map_err(|e| TranscriptionError::ParseError {
               message: format!("Failed to parse error response: {}", e),
           })?;

       return Err(match status.as_u16() {
           401 => TranscriptionError::Unauthorized {
               message: error_body.error,
           },
           402 => TranscriptionError::PaymentRequired {
               message: error_body.error,
               balance_tokens: error_body.balance_tokens.unwrap_or(0),
               required_tokens: error_body.required_tokens.unwrap_or(0),
           },
           403 => TranscriptionError::Forbidden {
               message: error_body.error,
           },
           404 => TranscriptionError::NotFound {
               message: error_body.error,
           },
           500..=599 => TranscriptionError::ServerError {
               message: error_body.error,
           },
           _ => TranscriptionError::ParseError {
               message: format!("Unexpected status {}: {}", status, error_body.error),
           },
       });
   }

   // Success path - parse transcript
   let transcript_response = response.json().await.map_err(...)?;
   Ok(transcript_response.text)
   ```

**Expected Result**: Tests PASS (GREEN) - error classification works correctly

**Run Tests**:
```bash
cd products/lumina-desktop/src-tauri
cargo test transcription
```

---

### Step 6: Update Hotkey Handler in main.rs (20 min)
**Tool**: Edit
**File**: `products/lumina-desktop/src-tauri/src/main.rs:553-560`

**Goal**: Handle `TranscriptionError` variants, emit events to frontend

**Changes to Make**:

1. **Import TranscriptionError**:
   ```rust
   use crate::transcription::{transcribe_audio, TranscriptionError};
   ```

2. **Replace generic error handling**:
   ```rust
   // OLD (line 553-560):
   let transcript = transcription::transcribe_audio(...)
       .await
       .map_err(|e| format!("Transcription failed: {}", e))?;

   // NEW:
   let transcript = match transcription::transcribe_audio(...).await {
       Ok(text) => text,
       Err(e) => {
           // Emit event to frontend based on error type
           match e {
               TranscriptionError::Unauthorized { message } => {
                   window.emit("show-license-activation", message).ok();
                   return Err(format!("License invalid: {}. Please re-activate your device.", message));
               }
               TranscriptionError::PaymentRequired { message, balance_tokens, required_tokens } => {
                   window.emit("show-token-purchase", serde_json::json!({
                       "message": message,
                       "balance": balance_tokens,
                       "required": required_tokens,
                   })).ok();
                   return Err(format!("Insufficient tokens: {}. You have {} tokens, need {} tokens.",
                       message, balance_tokens, required_tokens));
               }
               TranscriptionError::Forbidden { message } => {
                   window.emit("show-device-activation", message).ok();
                   return Err(format!("Device not active: {}. Please activate your device.", message));
               }
               TranscriptionError::ServerError { message } |
               TranscriptionError::NetworkError { message } => {
                   window.emit("show-retry-dialog", message.clone()).ok();
                   return Err(format!("Temporary error: {}. Please try again.", message));
               }
               _ => {
                   return Err(format!("Transcription failed: {}", e));
               }
           }
       }
   };
   ```

**Note**: Frontend listeners for these events will be implemented in BUG-005 (next task)

---

### Step 7: Create ErrorDialog.tsx Component (30 min)
**Tool**: Write
**File**: `products/lumina-desktop/src/components/ErrorDialog.tsx` (NEW)

**Goal**: Create reusable error dialog component with action buttons

**Component Design**:

```tsx
/**
 * Error Dialog Component (BUG-004)
 *
 * DESIGN DECISION: Reusable error dialog with action buttons
 * WHY: Each error type (401/402/403/500) needs specific user actions
 *
 * Props:
 * - errorType: 'unauthorized' | 'payment-required' | 'forbidden' | 'server-error'
 * - message: Error message from API
 * - tokenBalance?: Token balance (for payment-required)
 * - tokensRequired?: Tokens needed (for payment-required)
 * - onAction: Callback when user clicks action button
 * - onClose: Callback when user closes dialog
 */

import React from 'react';

interface ErrorDialogProps {
  errorType: 'unauthorized' | 'payment-required' | 'forbidden' | 'server-error';
  message: string;
  tokenBalance?: number;
  tokensRequired?: number;
  onAction: () => void;
  onClose: () => void;
}

export const ErrorDialog: React.FC<ErrorDialogProps> = ({
  errorType,
  message,
  tokenBalance,
  tokensRequired,
  onAction,
  onClose,
}) => {
  const getTitle = () => {
    switch (errorType) {
      case 'unauthorized':
        return 'License Invalid';
      case 'payment-required':
        return 'Insufficient Tokens';
      case 'forbidden':
        return 'Device Not Active';
      case 'server-error':
        return 'Server Error';
    }
  };

  const getActionText = () => {
    switch (errorType) {
      case 'unauthorized':
        return 'Re-activate License';
      case 'payment-required':
        return 'Upgrade or Purchase Tokens';
      case 'forbidden':
        return 'Activate Device';
      case 'server-error':
        return 'Retry';
    }
  };

  return (
    <div style={{
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 10000,
    }}>
      <div style={{
        backgroundColor: '#1e1e1e',
        padding: '24px',
        borderRadius: '8px',
        maxWidth: '400px',
        width: '90%',
      }}>
        <h2 style={{ margin: '0 0 16px 0', color: '#ef4444' }}>{getTitle()}</h2>
        <p style={{ margin: '0 0 16px 0', color: '#b0b0b0' }}>{message}</p>

        {errorType === 'payment-required' && tokenBalance !== undefined && tokensRequired !== undefined && (
          <div style={{
            padding: '12px',
            backgroundColor: '#2a2a2a',
            borderRadius: '4px',
            marginBottom: '16px',
          }}>
            <p style={{ margin: 0, fontSize: '14px', color: '#ffffff' }}>
              Current balance: <strong>{tokenBalance} tokens</strong>
            </p>
            <p style={{ margin: '4px 0 0 0', fontSize: '14px', color: '#ffffff' }}>
              Required: <strong>{tokensRequired} tokens</strong>
            </p>
          </div>
        )}

        <div style={{ display: 'flex', gap: '12px' }}>
          <button
            onClick={onAction}
            style={{
              flex: 1,
              padding: '10px',
              backgroundColor: '#3b82f6',
              color: '#ffffff',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              fontWeight: 600,
            }}
          >
            {getActionText()}
          </button>
          <button
            onClick={onClose}
            style={{
              padding: '10px 20px',
              backgroundColor: '#444',
              color: '#ffffff',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            Close
          </button>
        </div>
      </div>
    </div>
  );
};
```

**Note**: This component will be integrated into App.tsx in BUG-005

---

### Step 8: Manual Testing (20 min)
**Tool**: Bash + Manual testing

**Test Cases**:

1. **Test 401 (Unauthorized)**:
   - Temporarily modify license_key in settings.json to invalid key
   - Press voice capture hotkey
   - Expected: Error message + "Re-activate License" prompt

2. **Test 402 (Payment Required)**:
   - Modify API to return 402 (if test endpoint available)
   - Press voice capture hotkey
   - Expected: Token balance display + "Upgrade" prompt

3. **Test 403 (Forbidden)**:
   - Deactivate device from dashboard
   - Press voice capture hotkey
   - Expected: "Device Not Active" + activation prompt

4. **Test 500 (Server Error)**:
   - Temporarily break API endpoint (or use test endpoint)
   - Press voice capture hotkey
   - Expected: "Server Error" + "Retry" button

5. **Test Network Error**:
   - Disconnect internet
   - Press voice capture hotkey
   - Expected: "Connection failed" + "Retry" button

**Manual Test Procedure**:
```bash
# Build desktop app
cd products/lumina-desktop/src-tauri
cargo build

# Run desktop app
cargo run
```

**Expected Result**: All error types trigger appropriate dialogs/events

---

### Step 9: Verify All Tests Pass (5 min)
**Tool**: Bash

```bash
cd products/lumina-desktop/src-tauri
cargo test
cargo check
```

**Expected Result**: All unit tests pass, no compilation errors

---

### Step 10: Update Sprint TOML Completion Notes (5 min) - MANDATORY üõë

**‚ö†Ô∏è CRITICAL REQUIREMENT**: This step is MANDATORY. DO NOT proceed to Step 11 (Commit) until this is complete.

**Pattern**: Pattern-COMPLETION-001

**Why This Step Exists**: Historical audits (BUG-002A, BUG-003, BUG-002) found agents skipped completion documentation. This step MUST be completed BEFORE committing changes. If you skip this, your commit will be considered incomplete.

---

**Update Sprint TOML with completion_notes field:**

Open `internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml` and add the following to your task section (after `completed_date`):

```toml
[tasks.BUG-004]
status = "completed"
completed_date = "2025-01-13"  # Today's date

completion_notes = """
Completed 2025-01-13 by AI agent (tauri-desktop-agent)

Changes Made:
- Created TranscriptionError enum with 7 variants (Unauthorized, PaymentRequired, Forbidden, NotFound, ServerError, NetworkError, ParseError)
- Updated transcribe_audio() to parse HTTP status codes and return structured errors
- Updated hotkey handler in main.rs to emit frontend events based on error type
- Created ErrorDialog.tsx component with action buttons for each error type
- Added 5 unit tests for error classification (401/402/403/500/network)

Technical Details:
- File(s): transcription.rs:214-260 (+80 lines), main.rs:553-560 (+40 lines), ErrorDialog.tsx:0 (+120 lines new file)
- Lines Added/Modified: ~240 lines
- Test Coverage: 5 unit tests (all passing), manual testing completed
- Breaking Change: No (backward compatible error handling)
- Commit: [COMMIT_HASH] (will add after Step 11)

Testing:
- Unit tests: 5 tests (401/402/403/500/network error parsing) - all passing
- Integration tests: N/A (frontend integration in BUG-005)
- Manual testing: Tested 401/402/403/500/network scenarios manually

Impact:
- Unblocks: BUG-005 (frontend integration can use error classification system)
- Fixes: Generic error messages now replaced with actionable error dialogs
- Enables: Self-service error resolution for users (re-activate, upgrade, retry)

Dependencies:
- Blocked by: BUG-002 (license validation flow) - completed
- Related: BUG-005 (frontend integration will wire up event listeners)

Next Steps:
- BUG-005: Integrate ErrorDialog into App.tsx
- BUG-005: Wire up event listeners for show-license-activation, show-token-purchase, show-device-activation
"""
```

---

**Validation (MANDATORY - Run BEFORE proceeding to Step 11):**

```bash
# Check if status is "completed"
grep -A 5 "^\[tasks.BUG-004\]" internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml | grep 'status = "completed"'

# Check if completed_date exists
grep -A 5 "^\[tasks.BUG-004\]" internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml | grep "completed_date"

# Check if completion_notes exists
grep -A 50 "^\[tasks.BUG-004\]" internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml | grep "completion_notes"
```

**Expected Output:**
```
status = "completed"
completed_date = "2025-01-13"
completion_notes = """
```

**‚ùå If ANY command returns empty**: Sprint TOML is NOT updated. Do NOT proceed to Step 11. Fix it NOW.

**‚úÖ If ALL commands return results**: Sprint TOML is updated correctly. Proceed to Step 11.

---

**üõë BLOCKER**: DO NOT proceed to Step 11 (Commit) until ALL validation commands return expected output.

---

### Step 11: Commit Changes (5 min)

**‚ö†Ô∏è PREREQUISITE CHECK**: Did you complete Step 10 (Update Sprint TOML Completion Notes)?

**If NO**: STOP. Go back to Step 10 and complete it NOW.

**If YES**: Verify by running the 3 validation commands from Step 10. All 3 MUST return results.

---

**Pattern**: Pattern-GIT-001 (full commit format + workflow)

```bash
git add products/lumina-desktop/src-tauri/src/transcription.rs
git add products/lumina-desktop/src-tauri/src/main.rs
git add products/lumina-desktop/src/components/ErrorDialog.tsx
git add internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml

# Commit (use HEREDOC for proper formatting)
git commit -m "$(cat <<'EOF'
fix(desktop): Add structured error handling for API responses (BUG-004)

- Create TranscriptionError enum with 7 variants (401/402/403/500/network)
- Parse HTTP status codes in transcribe_audio()
- Emit frontend events based on error type (show-license-activation, show-token-purchase, show-device-activation)
- Create ErrorDialog component with action buttons
- Add 5 unit tests for error classification

Unblocks BUG-005 (frontend integration).

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

**After Commit**: Get commit hash and add it to completion_notes (optional but recommended):
```bash
git log -1 --format=%h
# Copy hash and update completion_notes "Commit: {hash}" field
```

---

### Step 12: Update Sprint Status to Completed (2 min)
**Pattern**: Pattern-TRACKING-001

```bash
/sprint-task-lifecycle complete BUG-004
```

**Fallback** (if skill unavailable): Follow Pattern-TRACKING-001 manual process

**Validation**: Verify status = "completed" and completed_date added

**‚ö†Ô∏è v2.0 ENFORCEMENT**: If `/sprint-task-lifecycle complete` returns error about missing completion_notes, go back to Step 10 and complete it NOW.

---

## Acceptance Criteria

- [ ] Pre-Task Analysis completed (Pattern-TASK-ANALYSIS-001)
- [ ] Code Workflow Announcement made (Pattern-CODE-001)
- [ ] TranscriptionError enum created with 7 variants
- [ ] transcribe_audio() parses HTTP status codes (401/402/403/500)
- [ ] Hotkey handler emits frontend events based on error type
- [ ] ErrorDialog.tsx component created with action buttons
- [ ] 5 unit tests pass (401/402/403/500/network error parsing)
- [ ] Manual testing completed (all error types trigger appropriate dialogs)
- [ ] Sprint TOML completion_notes added (Step 10 - Pattern-COMPLETION-001) üõë MANDATORY
- [ ] Sprint TOML validation commands pass (Step 10 - all 3 commands return results)
- [ ] All tests passing (cargo test)
- [ ] Sprint TOML updated to "completed" (Pattern-TRACKING-001)
- [ ] Changes committed (Pattern-GIT-001)
- [ ] Ready for BUG-005 (frontend integration)

---

## Error Handling

### Issue 1: reqwest Error Parsing

**Problem**: HTTP client returns generic error, status code not accessible

**Cause**: Error occurred before response received (DNS, connection timeout)

**Solution**: Wrap in `NetworkError` variant:
```rust
.map_err(|e| TranscriptionError::NetworkError {
    message: format!("Connection failed: {}", e),
})?
```

### Issue 2: API Returns Malformed JSON

**Problem**: Error response doesn't match `ApiErrorResponse` schema

**Cause**: API changed error format or returned HTML error page

**Solution**: Fallback to `ParseError` variant:
```rust
let error_body: ApiErrorResponse = response
    .json()
    .await
    .map_err(|e| TranscriptionError::ParseError {
        message: format!("Failed to parse error response: {}", e),
    })?;
```

### Issue 3: Status Code Not in Expected Range

**Problem**: API returns 418 (I'm a teapot) or other unexpected status

**Cause**: API misconfiguration or proxy error

**Solution**: Use wildcard match arm:
```rust
_ => TranscriptionError::ParseError {
    message: format!("Unexpected status {}: {}", status, error_body.error),
}
```

### Issue 4: Frontend Event Emission Fails

**Problem**: `window.emit()` returns error

**Cause**: Window handle invalid or event name typo

**Solution**: Use `.ok()` to ignore emit errors (don't block transcription on UI issues):
```rust
window.emit("show-license-activation", message).ok(); // Ignore emit errors
```

### Issue 5: Tests Fail to Compile

**Problem**: `TranscriptionError` doesn't implement expected traits

**Cause**: Missing `std::fmt::Display` or `std::error::Error` implementation

**Solution**: Add trait implementations (already included in Step 4)

---

## Rollback Plan

**If tests fail** (Step 3-5):
```bash
git checkout -- products/lumina-desktop/src-tauri/src/transcription.rs
# Review auth.rs error handling, update tests, retry
```

**If compilation errors** (Step 6):
```bash
cd products/lumina-desktop/src-tauri
cargo check --message-format=short
# Fix errors one file at a time
```

**Emergency Rollback**:
```bash
git stash  # Save work
git reset --hard HEAD  # Reset
git stash pop  # Restore if needed
```

---

## Time Estimate

- Pre-Task Analysis (Pattern-TASK-ANALYSIS-001): 5-10 min
- Step 0 (Git + Sprint): 2 min
- Step 1 (Read current code): 10 min
- Step 2 (Design error system): 15 min
- Step 3 (Tests - RED): 20 min
- Step 4 (Create error enum - GREEN): 15 min
- Step 5 (Update transcribe_audio - GREEN): 30 min
- Step 6 (Update hotkey handler): 20 min
- Step 7 (Create ErrorDialog): 30 min
- Step 8 (Manual testing): 20 min
- Step 9 (Verify tests): 5 min
- Step 10 (Sprint TOML Completion Notes): 5 min üõë MANDATORY
- Step 11 (Commit): 5 min
- Step 12 (Sprint Complete): 2 min

**Total**: 3-4 hours (as estimated)

---

## Dependencies

**Blocks**: BUG-005 (frontend integration)

**Blocked By**: BUG-002 (license validation flow - COMPLETED)

---

## Success Impact

After BUG-004 complete:

‚úÖ 401 errors show "License invalid/revoked" + activation dialog
‚úÖ 402 errors show token balance + upgrade/purchase options
‚úÖ 403 errors show "Device not active" + activation dialog
‚úÖ 500 errors show "Server error" + retry button
‚úÖ Network errors show "Connection failed" + retry button
‚úÖ Users have clear resolution paths for all error types
‚úÖ Reduced support burden (self-service error recovery)
‚úÖ ErrorDialog component ready for BUG-005 integration

---

## Notes

### Design Decisions

**Why enum instead of error codes?**
- Type-safe error handling at compile time
- Pattern matching forces all error cases to be handled
- Easier to add new error types without breaking existing code

**Why emit events instead of direct dialog calls?**
- Separation of concerns (backend doesn't know about UI)
- Frontend can batch errors or queue dialogs
- Easier to test backend without UI dependencies

**Why separate ErrorDialog component?**
- Reusable across different error scenarios
- Consistent error UX
- Single place to update error styling

### Frontend Integration (BUG-005)

This task creates the error classification system. BUG-005 will:
1. Wire up event listeners in App.tsx
2. Show ErrorDialog when events received
3. Implement action button handlers (re-activate, upgrade, retry)

---

**This enhanced prompt follows template v1.4.3 (breadcrumb-based with mandatory pre-task analysis + completion notes in workflow). All universal protocols are in patterns/skills for token efficiency.**

**Pattern References**:
- Pattern-TASK-ANALYSIS-001: 8-step pre-task analysis (MANDATORY)
- Pattern-CODE-001: Code workflow + announcement (MANDATORY)
- Pattern-COMPLETION-001: Post-completion documentation (MANDATORY - Step 10)
- Pattern-TRACKING-001: Sprint TOML lifecycle
- Pattern-GIT-001: Git workflow + commit format
- Pattern-TDD-001: Test-driven development
- Pattern-VALIDATION-001: Pre-flight checklist

**Skill References**:
- sprint-task-lifecycle: Automated Sprint TOML updates (v2.0 with completion_notes validation)

**Token Savings**: ~2,100-2,400 tokens (54%+ reduction from v1.0, maintains enforcement)

---

**IMPORTANT**: Completion notes documentation (formerly Section 12) is now **Step 10** in the implementation workflow. This ensures agents complete documentation BEFORE committing changes, not after. See Step 10 for full instructions.
