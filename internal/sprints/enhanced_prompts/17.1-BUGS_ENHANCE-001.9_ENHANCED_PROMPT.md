# ENHANCE-001.9: Progressive Loading UI (Real-time Enhancement Progress)

**Sprint:** 17.1-BUGS
**Task ID:** ENHANCE-001.9
**Agent:** ui-agent
**Estimated Time:** 2-3 hours
**Dependencies:** ENHANCE-001.1
**Template Version:** MVP-003-PromptEnhancer-TaskTemplate-v1.4.3

---

## Step 0: Pre-Task Analysis (MANDATORY - Run Pattern-TASK-ANALYSIS-001)

**CRITICAL: You MUST complete this 8-step analysis OUT LOUD before writing ANY code.**

### 1. UNDERSTAND the Task

**Task Goal:**
Display real-time progress during enhancement with step-by-step updates: "Gathering files...", "Analyzing git history...", "Calling AI service...", "Formatting output...". Shows user what's happening at each stage, reduces perceived wait time, provides transparency, and allows cancellation at any stage.

**Why This Task Exists:**
**Problem - Enhancement is opaque:**

Current experience:
- User clicks Enhance → Sees generic "Enhancing with AI..." notification
- User doesn't know what step is currently happening
- User doesn't know how long it will take
- User doesn't know if the system is stuck or working
- 2-3 second wait feels much longer without visible progress

**User Need:** "Show me what's happening during enhancement."

**Psychological impact research:**
- Visible progress reduces **perceived wait time by 30-40%**
- Step-by-step updates build user trust (system is working, not frozen)
- Cancellation option provides user control (exit if taking too long)
- Estimated time helps set expectations (reduces anxiety)

**Solution:**
Real-time progress indicator showing: current step name, step status (✓ complete, ⏳ in progress, ✗ error), elapsed time, and [Cancel] button. Updates in real-time as each step completes.

**Current vs. Desired State:**
- **CURRENT:** Single "Enhancing with AI..." notification, no progress visibility, no cancellation, opaque process
- **DESIRED:** Real-time progress indicator with step updates, elapsed time, cancellation option, transparency

### 2. CHECK for Existing Solutions

**Search Strategy:**
```bash
# Search for existing progress tracking
grep -r "progress" vscode-lumina/src/
grep -r "ProgressStream" vscode-lumina/src/

# Check if VS Code progress API is used
grep -r "withProgress" vscode-lumina/src/commands/voicePanel.ts

# Search for event emitter patterns
grep -r "EventEmitter" vscode-lumina/src/
```

**Expected Findings:**
- VS Code provides `vscode.window.withProgress()` API (built-in progress indicator)
- No existing ProgressStream class (need to create)
- No existing step-by-step tracking (new feature)

### 3. IDENTIFY Required Changes

**Files to Create:**
1. `vscode-lumina/src/services/ProgressStream.ts` (~150 lines)
   - Event emitter for progress events
   - Event types: step_start, step_complete, step_error
   - Timer for elapsed time tracking

**Files to Read (for context):**
1. `vscode-lumina/src/services/AIEnhancementService.ts` - Where to emit progress events
2. `vscode-lumina/src/commands/voicePanel.ts` - Where to display progress UI

**Files to Modify:**
1. `vscode-lumina/src/services/AIEnhancementService.ts` - Add progress event emissions
2. `vscode-lumina/src/commands/voicePanel.ts` - Replace generic notification with progress UI
3. Context builders (BugReportContextBuilder, etc.) - Emit progress events

### 4. ASSESS Impact & Risk

**Impact Assessment:**
- **Scope:** LOW - Additive feature, progress tracking layer
- **Blast Radius:** LOW - Only affects UI feedback during enhancement
- **Performance:** LOW - Progress UI update < 16ms (60 FPS)
- **Breaking Changes:** NONE - Replaces generic notification with detailed progress

**Risk Factors:**
- ⚠️ **Performance Risk:** Frequent UI updates could cause lag
- ⚠️ **Timing Risk:** Progress events might arrive out of order
- ⚠️ **Cancellation Risk:** Cancel during AI call could leave resources hanging

**Mitigation Strategies:**
- Throttle UI updates to 16ms (60 FPS, imperceptible lag)
- Use sequence numbers for event ordering
- Implement proper cleanup for cancellation (abort AI request, stop watchers)
- Test cancellation at each step to ensure clean abort

### 5. VERIFY Dependencies & Blockers

**Dependencies:**
- ✅ **ENHANCE-001.1:** AIEnhancementService exists (integration point)
- ✅ **voicePanel.ts:** Webview/notification system exists
- ✅ **VS Code API:** vscode.window.withProgress() available

**Potential Blockers:**
- ❌ **AI cancellation unknown:** Can we abort VS Code LM API call mid-request?
- ❌ **Context builder timing unknown:** How long does each step actually take?

**Blocker Resolution:**
- Test AI cancellation with CancellationTokenSource (VS Code pattern)
- Add timing instrumentation to measure actual step durations
- Use estimated durations based on measurements

### 6. PLAN with Git Workflow (Pattern-GIT-001)

**Current Branch:** feature/v0.17.2-bug-fixes
**Git Status:** Clean (from gitStatus snapshot)

**Workflow Steps:**
1. ✅ Verify branch: `git status` (already on feature branch)
2. ✅ Read AIEnhancementService to understand enhancement flow
3. ✅ Write tests FIRST (TDD RED phase)
4. ✅ Create ProgressStream class (GREEN phase)
5. ✅ Add progress events to AIEnhancementService (GREEN phase)
6. ✅ Add progress UI to voicePanel (GREEN phase)
7. ✅ Test manually with real enhancements (manual verification)
8. ✅ Optimize UI update throttling (REFACTOR phase)
9. ✅ Commit: "feat(ENHANCE-001.9): Implement progressive loading UI"
10. ✅ Validation: Test cancellation, verify elapsed time accuracy

**Commit Message Template:**
```
feat(ENHANCE-001.9): Implement progressive loading UI with real-time progress

- Add ProgressStream class (event emitter for progress)
- Add progress event types (step_start, step_complete, step_error)
- Emit progress events in AIEnhancementService (6 steps)
- Emit progress events in context builders
- Replace generic notification with progress UI
- Show completed steps with checkmarks (✓)
- Show current step with spinner (⏳)
- Show failed steps with error icon (✗)
- Display elapsed time for current step
- Add [Cancel] button with abort logic
- Throttle UI updates to 16ms (60 FPS, no lag)
- Add unit tests (70% coverage)

Progress steps:
1. Normalized input (0.1s)
2. Gathered workspace context (0.8s)
3. Analyzed git history (1.2s)
4. Found patterns (0.3s)
5. Validated files (0.4s)
6. Generated enhanced prompt (1-2s)

Reduces perceived wait time by 30-40%, builds user trust.

Closes ENHANCE-001.9
```

### 7. CHECK Patterns & SOPs

**Applicable Patterns:**
- ✅ **Pattern-CODE-001:** Code development workflow (announced OUT LOUD)
- ✅ **Pattern-TDD-001:** Tests FIRST (RED → GREEN → REFACTOR)
- ✅ **Pattern-UX-001:** User experience design (transparency reduces perceived wait time)

**Pattern Integration:**
- Progress tracking implements transparency principle (user sees system is working)
- Cancellation implements user control principle (exit if taking too long)

### 8. ESTIMATE Effort & Complexity

**Effort Estimate:** 2-3 hours (from task specification)

**Complexity Breakdown:**
- **ProgressStream Class:** 30 min - Event emitter with timer
- **AIEnhancementService Events:** 45 min - Emit events at each step
- **Context Builder Events:** 30 min - Emit events in builders
- **Progress UI:** 45 min - Display with checkmarks, spinner, elapsed time
- **Cancellation Logic:** 30 min - Cancel button with cleanup
- **Tests:** 60 min - 10 test cases (70% coverage)

**Total:** ~3 hours (matches estimate)

**Confidence Level:** HIGH
- ✅ Event emitter pattern well-understood (Node.js EventEmitter)
- ✅ VS Code withProgress API documented
- ✅ Simple UI updates (text + icons)
- ✅ Cancellation pattern standard (CancellationTokenSource)

---

## Step 1: UNDERSTAND the Enhancement Flow

### Read Foundation Files

**CRITICAL: Read these files BEFORE writing any code.**

```bash
# Read AIEnhancementService to understand enhancement steps
cat vscode-lumina/src/services/AIEnhancementService.ts

# Read voicePanel to understand notification display
cat vscode-lumina/src/commands/voicePanel.ts | grep -A 30 "handleEnhancePrompt"

# Check for VS Code progress API usage
grep -r "withProgress" vscode-lumina/src/
```

### Enhancement Flow (Steps to Track)

**From AIEnhancementService.enhance():**

```typescript
async enhance(context: EnhancementContext): Promise<string> {
    // Step 1: Normalize input (0.1s)
    // - Validate context structure
    // - Set defaults

    // Step 2: Gather workspace context (0.8s)
    // - Detect languages, frameworks
    // - Find relevant files

    // Step 3: Analyze git history (1.2s)
    // - Get recent commits
    // - Parse commit messages

    // Step 4: Find patterns (0.3s)
    // - Search pattern library
    // - Match patterns to context

    // Step 5: Validate files (0.4s)
    // - Check files exist
    // - Validate dependencies

    // Step 6: Generate enhanced prompt (1-2s)
    // - Call VS Code LM API
    // - Format response
    // - Embed metadata

    return enhancedPrompt;
}
```

### Progress UI Design

**Using VS Code withProgress API:**

```typescript
vscode.window.withProgress(
    {
        location: vscode.ProgressLocation.Notification,
        title: "Enhancing Code Analyzer Request",
        cancellable: true
    },
    async (progress, token) => {
        // Report progress updates
        progress.report({ increment: 0, message: "Normalizing input..." });

        // Listen for cancellation
        token.onCancellationRequested(() => {
            // Abort enhancement
        });

        // ... enhancement logic with progress.report() calls ...

        return enhancedPrompt;
    }
);
```

**Progress Display:**
```
⏳ Enhancing Code Analyzer Request...
  ✓ Normalized input (0.1s)
  ✓ Gathered workspace context (0.8s)
  ✓ Analyzed git history (1.2s)
  ✓ Found patterns (0.3s)
  ✓ Validated files (0.4s)
  ⏳ Generating enhanced prompt... (2.1s elapsed)

  [Cancel]
```

---

## Step 2: TDD - Write Tests FIRST (RED Phase)

**CRITICAL: Pattern-TDD-001 requires writing tests BEFORE implementation.**

### Test File 1: ProgressStream

**File:** `vscode-lumina/test/services/ProgressStream.test.ts`

```typescript
import * as assert from 'assert';
import { ProgressStream, ProgressEvent } from '../../src/services/ProgressStream';

describe('ProgressStream', () => {
    let stream: ProgressStream;

    beforeEach(() => {
        stream = new ProgressStream();
    });

    afterEach(() => {
        stream.dispose();
    });

    // TEST 1: Event emission
    describe('Event emission', () => {
        it('should emit step_start event', (done) => {
            stream.on('step_start', (event: ProgressEvent) => {
                assert.strictEqual(event.type, 'step_start');
                assert.strictEqual(event.stepName, 'Normalizing input');
                done();
            });

            stream.emitStepStart('Normalizing input', 1, 6);
        });

        it('should emit step_complete event', (done) => {
            stream.on('step_complete', (event: ProgressEvent) => {
                assert.strictEqual(event.type, 'step_complete');
                assert.strictEqual(event.stepName, 'Normalized input');
                assert.ok(event.duration !== undefined);
                done();
            });

            stream.emitStepStart('Normalizing input', 1, 6);
            setTimeout(() => {
                stream.emitStepComplete('Normalized input');
            }, 100);
        });

        it('should emit step_error event', (done) => {
            stream.on('step_error', (event: ProgressEvent) => {
                assert.strictEqual(event.type, 'step_error');
                assert.strictEqual(event.stepName, 'Gathering workspace');
                assert.ok(event.error);
                done();
            });

            stream.emitStepError('Gathering workspace', new Error('File not found'));
        });
    });

    // TEST 2: Elapsed time tracking
    describe('Elapsed time', () => {
        it('should track elapsed time for current step', async () => {
            stream.emitStepStart('Test step', 1, 1);

            await new Promise(resolve => setTimeout(resolve, 150));

            const elapsed = stream.getElapsedTime('Test step');
            assert.ok(elapsed >= 100 && elapsed <= 200);
        });

        it('should return 0 for completed steps', () => {
            stream.emitStepStart('Test step', 1, 1);
            stream.emitStepComplete('Test step');

            const elapsed = stream.getElapsedTime('Test step');
            assert.strictEqual(elapsed, 0);
        });
    });

    // TEST 3: Step status tracking
    describe('Step status', () => {
        it('should track step as in_progress after start', () => {
            stream.emitStepStart('Test step', 1, 1);

            const status = stream.getStepStatus('Test step');
            assert.strictEqual(status, 'in_progress');
        });

        it('should track step as completed after complete', () => {
            stream.emitStepStart('Test step', 1, 1);
            stream.emitStepComplete('Test step');

            const status = stream.getStepStatus('Test step');
            assert.strictEqual(status, 'completed');
        });

        it('should track step as error after error', () => {
            stream.emitStepStart('Test step', 1, 1);
            stream.emitStepError('Test step', new Error('Test error'));

            const status = stream.getStepStatus('Test step');
            assert.strictEqual(status, 'error');
        });
    });

    // TEST 4: Progress percentage
    describe('Progress percentage', () => {
        it('should calculate progress percentage correctly', () => {
            stream.emitStepStart('Step 1', 1, 6);
            stream.emitStepComplete('Step 1');

            assert.strictEqual(stream.getProgressPercentage(), 16.67); // 1/6 * 100

            stream.emitStepStart('Step 2', 2, 6);
            stream.emitStepComplete('Step 2');

            assert.strictEqual(stream.getProgressPercentage(), 33.33); // 2/6 * 100
        });
    });

    // TEST 5: Cancellation
    describe('Cancellation', () => {
        it('should allow cancellation', () => {
            let cancelled = false;

            stream.onCancel(() => {
                cancelled = true;
            });

            stream.cancel();

            assert.strictEqual(cancelled, true);
        });
    });
});
```

### Test File 2: voicePanel Integration

**File:** `vscode-lumina/test/commands/voicePanel-progress.test.ts`

```typescript
import * as assert from 'assert';
import * as vscode from 'vscode';
import { VoicePanelCommand } from '../../src/commands/voicePanel';

describe('VoicePanelCommand - Progress UI', () => {
    let voicePanel: VoicePanelCommand;

    beforeEach(() => {
        voicePanel = new VoicePanelCommand();
    });

    // TEST 1: Progress UI displays
    describe('Progress display', () => {
        it('should show progress notification during enhancement', async () => {
            let progressShown = false;

            // Mock vscode.window.withProgress
            const originalWithProgress = vscode.window.withProgress;
            vscode.window.withProgress = async (options: any, task: any) => {
                progressShown = true;
                return await task({ report: () => {} }, { isCancellationRequested: false });
            };

            await voicePanel.handleEnhancePrompt('bug', mockFormData);

            assert.strictEqual(progressShown, true);

            // Restore
            vscode.window.withProgress = originalWithProgress;
        });
    });

    // TEST 2: Progress updates
    describe('Progress updates', () => {
        it('should report progress for each step', async () => {
            const reportedSteps: string[] = [];

            vscode.window.withProgress = async (options: any, task: any) => {
                return await task(
                    {
                        report: (value: any) => {
                            reportedSteps.push(value.message);
                        }
                    },
                    { isCancellationRequested: false }
                );
            };

            await voicePanel.handleEnhancePrompt('bug', mockFormData);

            assert.ok(reportedSteps.includes('Normalizing input...'));
            assert.ok(reportedSteps.includes('Gathering workspace context...'));
            assert.ok(reportedSteps.includes('Generating enhanced prompt...'));
        });
    });

    // TEST 3: Cancellation
    describe('Cancellation', () => {
        it('should abort enhancement when cancelled', async () => {
            let enhancementCompleted = false;

            vscode.window.withProgress = async (options: any, task: any) => {
                const token = { isCancellationRequested: false };

                // Simulate cancellation after 100ms
                setTimeout(() => {
                    token.isCancellationRequested = true;
                }, 100);

                return await task({ report: () => {} }, token);
            };

            voicePanel['aiEnhancementService'].enhance = async () => {
                await new Promise(resolve => setTimeout(resolve, 500));
                enhancementCompleted = true;
                return 'Enhanced';
            };

            await voicePanel.handleEnhancePrompt('bug', mockFormData);

            assert.strictEqual(enhancementCompleted, false);
        });
    });

    // TEST 4: Error handling
    describe('Error handling', () => {
        it('should show error icon if step fails', async () => {
            const reportedMessages: string[] = [];

            vscode.window.withProgress = async (options: any, task: any) => {
                return await task(
                    {
                        report: (value: any) => {
                            reportedMessages.push(value.message);
                        }
                    },
                    { isCancellationRequested: false }
                );
            };

            // Simulate error in context building
            voicePanel['buildContext'] = async () => {
                throw new Error('Context building failed');
            };

            try {
                await voicePanel.handleEnhancePrompt('bug', mockFormData);
            } catch (error) {
                // Expected
            }

            // Should have reported error
            assert.ok(reportedMessages.some(m => m.includes('✗') || m.includes('failed')));
        });
    });
});
```

### Run Tests (Expected to FAIL - RED Phase)

```bash
cd vscode-lumina
npm test -- --grep "ProgressStream|Progress UI"
```

**Expected Output:**
```
ProgressStream
  ❌ should emit step_start event
  Error: Cannot find module '../../src/services/ProgressStream'

  ... 9 more failures

VoicePanelCommand - Progress UI
  ❌ should show progress notification during enhancement
  ...

  0 passing (52ms)
  14 failing
```

**Status:** ✅ RED phase complete (tests exist, implementation missing)

---

## Step 3: Implementation - ProgressStream Class (GREEN Phase)

### File: ProgressStream.ts

**File:** `vscode-lumina/src/services/ProgressStream.ts`

```typescript
/**
 * ProgressStream
 *
 * DESIGN DECISION: Real-time progress tracking with event emission
 * WHY: Reduces perceived wait time by 30-40%, builds user trust
 *
 * REASONING CHAIN:
 * 1. User clicks Enhance → Sees generic "Enhancing..." notification
 * 2. 2-3 second wait feels much longer without visible progress
 * 3. User doesn't know if system is working or frozen
 * 4. Psychological research: Visible progress reduces perceived wait time
 * 5. Solution: Emit events at each step (start, complete, error)
 * 6. UI listens to events, updates in real-time
 * 7. User sees: "✓ Gathered files (0.8s)", "⏳ Calling AI... (2.1s elapsed)"
 * 8. Result: User understands what's happening, trusts system is working
 *
 * PATTERN: Pattern-UX-001 (Transparency & User Control)
 * ARCHITECTURE: Event-driven progress tracking
 * RELATED: AIEnhancementService.ts, voicePanel.ts
 */

import { EventEmitter } from 'events';

export type ProgressEventType = 'step_start' | 'step_complete' | 'step_error' | 'cancel';

export interface ProgressEvent {
    type: ProgressEventType;
    stepName: string;
    stepIndex: number;
    totalSteps: number;
    duration?: number;        // Duration in milliseconds (for completed steps)
    error?: Error;            // Error object (for failed steps)
    timestamp: number;        // When event occurred
}

export type StepStatus = 'pending' | 'in_progress' | 'completed' | 'error';

export class ProgressStream extends EventEmitter {
    private steps: Map<string, { status: StepStatus; startTime?: number; duration?: number }> = new Map();
    private completedSteps: number = 0;
    private totalSteps: number = 0;
    private cancelCallback?: () => void;

    /**
     * Emit step_start event
     */
    emitStepStart(stepName: string, stepIndex: number, totalSteps: number): void {
        this.totalSteps = totalSteps;

        this.steps.set(stepName, {
            status: 'in_progress',
            startTime: Date.now()
        });

        this.emit('step_start', {
            type: 'step_start',
            stepName: stepName,
            stepIndex: stepIndex,
            totalSteps: totalSteps,
            timestamp: Date.now()
        } as ProgressEvent);
    }

    /**
     * Emit step_complete event
     */
    emitStepComplete(stepName: string): void {
        const step = this.steps.get(stepName);
        if (!step || step.status !== 'in_progress') {
            console.warn(`[ProgressStream] Cannot complete step ${stepName} (not in progress)`);
            return;
        }

        const duration = Date.now() - (step.startTime || 0);

        this.steps.set(stepName, {
            status: 'completed',
            startTime: step.startTime,
            duration: duration
        });

        this.completedSteps++;

        this.emit('step_complete', {
            type: 'step_complete',
            stepName: stepName,
            stepIndex: this.completedSteps,
            totalSteps: this.totalSteps,
            duration: duration,
            timestamp: Date.now()
        } as ProgressEvent);
    }

    /**
     * Emit step_error event
     */
    emitStepError(stepName: string, error: Error): void {
        const step = this.steps.get(stepName);

        this.steps.set(stepName, {
            status: 'error',
            startTime: step?.startTime,
            duration: step?.startTime ? Date.now() - step.startTime : 0
        });

        this.emit('step_error', {
            type: 'step_error',
            stepName: stepName,
            stepIndex: this.completedSteps,
            totalSteps: this.totalSteps,
            error: error,
            timestamp: Date.now()
        } as ProgressEvent);
    }

    /**
     * Get elapsed time for current step (in milliseconds)
     */
    getElapsedTime(stepName: string): number {
        const step = this.steps.get(stepName);
        if (!step || step.status !== 'in_progress') {
            return 0;
        }

        return Date.now() - (step.startTime || 0);
    }

    /**
     * Get step status
     */
    getStepStatus(stepName: string): StepStatus {
        return this.steps.get(stepName)?.status || 'pending';
    }

    /**
     * Get progress percentage (0-100)
     */
    getProgressPercentage(): number {
        if (this.totalSteps === 0) return 0;
        return Math.round((this.completedSteps / this.totalSteps) * 100 * 100) / 100;
    }

    /**
     * Cancel enhancement
     */
    cancel(): void {
        this.emit('cancel', {
            type: 'cancel',
            stepName: 'Cancelled by user',
            stepIndex: this.completedSteps,
            totalSteps: this.totalSteps,
            timestamp: Date.now()
        } as ProgressEvent);

        if (this.cancelCallback) {
            this.cancelCallback();
        }
    }

    /**
     * Register cancel callback
     */
    onCancel(callback: () => void): void {
        this.cancelCallback = callback;
    }

    /**
     * Dispose (clean up)
     */
    dispose(): void {
        this.removeAllListeners();
        this.steps.clear();
    }
}
```

---

## Step 4: Implementation - AIEnhancementService Integration (GREEN Phase)

**File:** `vscode-lumina/src/services/AIEnhancementService.ts`

**Add progress tracking:**

```typescript
import { ProgressStream } from './ProgressStream';

export class AIEnhancementService {
    private progressStream?: ProgressStream;

    /**
     * Enhance with progress tracking
     */
    async enhance(
        context: EnhancementContext,
        progressStream?: ProgressStream
    ): Promise<string> {
        this.progressStream = progressStream;

        try {
            // Step 1: Normalize input
            this.emitProgress('Normalizing input', 1, 6);
            // ... normalization logic ...
            this.completeProgress('Normalized input');

            // Step 2: Gather workspace context (if not already gathered)
            this.emitProgress('Gathering workspace context', 2, 6);
            // ... workspace gathering logic ...
            this.completeProgress('Gathered workspace context');

            // Step 3: Analyze git history
            this.emitProgress('Analyzing git history', 3, 6);
            // ... git analysis logic ...
            this.completeProgress('Analyzed git history');

            // Step 4: Find patterns
            this.emitProgress('Finding patterns', 4, 6);
            // ... pattern search logic ...
            this.completeProgress('Found patterns');

            // Step 5: Validate files
            this.emitProgress('Validating files', 5, 6);
            // ... validation logic ...
            this.completeProgress('Validated files');

            // Step 6: Generate enhanced prompt
            this.emitProgress('Generating enhanced prompt', 6, 6);
            const enhancedPrompt = await this.callAI(context);
            this.completeProgress('Generated enhanced prompt');

            return enhancedPrompt;

        } catch (error) {
            if (this.progressStream) {
                this.progressStream.emitStepError('Enhancement', error as Error);
            }
            throw error;
        }
    }

    /**
     * Emit progress event
     */
    private emitProgress(stepName: string, stepIndex: number, totalSteps: number): void {
        if (this.progressStream) {
            this.progressStream.emitStepStart(stepName, stepIndex, totalSteps);
        }
    }

    /**
     * Complete progress step
     */
    private completeProgress(stepName: string): void {
        if (this.progressStream) {
            this.progressStream.emitStepComplete(stepName);
        }
    }
}
```

---

## Step 5: Implementation - voicePanel Progress UI (GREEN Phase)

**File:** `vscode-lumina/src/commands/voicePanel.ts`

**Replace generic notification with progress UI:**

```typescript
import { ProgressStream } from '../services/ProgressStream';

/**
 * Handle enhance prompt with progress tracking
 */
async handleEnhancePrompt(buttonType: string, formData: any): Promise<void> {
    return vscode.window.withProgress(
        {
            location: vscode.ProgressLocation.Notification,
            title: `Enhancing ${this.getButtonTypeName(buttonType)} Request`,
            cancellable: true
        },
        async (progress, token) => {
            const progressStream = new ProgressStream();
            let lastUpdate = 0;

            // Listen to progress events
            progressStream.on('step_start', (event) => {
                const now = Date.now();
                // Throttle to 60 FPS (16ms)
                if (now - lastUpdate < 16) return;
                lastUpdate = now;

                progress.report({
                    increment: 0,
                    message: `⏳ ${event.stepName}...`
                });
            });

            progressStream.on('step_complete', (event) => {
                const now = Date.now();
                if (now - lastUpdate < 16) return;
                lastUpdate = now;

                progress.report({
                    increment: (100 / event.totalSteps),
                    message: `✓ ${event.stepName} (${(event.duration! / 1000).toFixed(1)}s)`
                });
            });

            progressStream.on('step_error', (event) => {
                progress.report({
                    increment: 0,
                    message: `✗ ${event.stepName} failed: ${event.error?.message}`
                });
            });

            // Handle cancellation
            token.onCancellationRequested(() => {
                progressStream.cancel();
            });

            try {
                // Build context
                const context = await this.buildContext(buttonType, formData);

                // Check cancellation
                if (token.isCancellationRequested) {
                    vscode.window.showInformationMessage('Enhancement cancelled');
                    return;
                }

                // Show context preview (ENHANCE-001.8)
                const proceed = await this.showContextPreview(context);
                if (!proceed) {
                    return;
                }

                // Enhance with progress tracking
                const enhancedPrompt = await this.aiEnhancementService.enhance(
                    context,
                    progressStream
                );

                // Check cancellation
                if (token.isCancellationRequested) {
                    vscode.window.showInformationMessage('Enhancement cancelled');
                    return;
                }

                // Display result
                this.displayEnhancedPrompt(enhancedPrompt);

                vscode.window.showInformationMessage('Enhancement complete!');

            } catch (error) {
                console.error('[VoicePanel] Enhancement failed:', error);
                vscode.window.showErrorMessage(`Enhancement failed: ${error.message}`);
            } finally {
                progressStream.dispose();
            }
        }
    );
}

private getButtonTypeName(type: string): string {
    const names: Record<string, string> = {
        'task': 'Start This Task',
        'bug': 'Bug Report',
        'feature': 'Feature Request',
        'code_analyzer': 'Code Analyzer',
        'sprint_planner': 'Sprint Planner',
        'general': 'General'
    };
    return names[type] || type;
}
```

---

## Step 6: Validation & Testing

### Run Tests (Expected to PASS - GREEN Phase)

```bash
cd vscode-lumina
npm run compile
npm test -- --grep "ProgressStream|Progress UI"
```

**Expected Output:**
```
ProgressStream
  Event emission
    ✓ should emit step_start event (23ms)
    ✓ should emit step_complete event (112ms)
    ✓ should emit step_error event (18ms)
  Elapsed time
    ✓ should track elapsed time for current step (156ms)
    ✓ should return 0 for completed steps (21ms)
  Step status
    ✓ should track step as in_progress after start (15ms)
    ✓ should track step as completed after complete (17ms)
    ✓ should track step as error after error (19ms)
  Progress percentage
    ✓ should calculate progress percentage correctly (24ms)
  Cancellation
    ✓ should allow cancellation (16ms)

VoicePanelCommand - Progress UI
  Progress display
    ✓ should show progress notification during enhancement (89ms)
  Progress updates
    ✓ should report progress for each step (134ms)
  Cancellation
    ✓ should abort enhancement when cancelled (267ms)
  Error handling
    ✓ should show error icon if step fails (76ms)

14 passing (987ms)
```

**Status:** ✅ GREEN phase complete

---

## Step 7: Manual Testing

### Test Progress UI

1. Launch Extension Development Host (F5)
2. Click ÆtherLight icon → Bug Report button
3. Fill form and click "Enhance"
4. **Verify progress notification appears** (top-right corner)
5. Observe step-by-step updates:

**Expected Progress Display:**
```
⏳ Enhancing Bug Report Request...
  ✓ Normalized input (0.1s)
  ✓ Gathered workspace context (0.8s)
  ✓ Analyzed git history (1.2s)
  ✓ Found patterns (0.3s)
  ✓ Validated files (0.4s)
  ⏳ Generating enhanced prompt... (2.1s elapsed)
```

**Test Cancellation:**
- Start enhancement again
- Click [Cancel] button in notification
- Verify enhancement aborts
- Verify "Enhancement cancelled" message appears

**Test Error Handling:**
- Disconnect network (simulate AI failure)
- Start enhancement
- Verify error step shows with ✗ icon
- Verify error message displayed

---

## Step 8: Documentation & Commit

### Update Task Status

**File:** `internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml`

Mark ENHANCE-001.9 as completed:

```toml
[tasks."ENHANCE-001.9"]
status = "completed"
```

### Commit Changes

```bash
git add vscode-lumina/src/services/ProgressStream.ts
git add vscode-lumina/src/services/AIEnhancementService.ts
git add vscode-lumina/src/commands/voicePanel.ts
git add vscode-lumina/test/services/ProgressStream.test.ts
git add vscode-lumina/test/commands/voicePanel-progress.test.ts
git add internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml

git commit -m "feat(ENHANCE-001.9): Implement progressive loading UI with real-time progress

- Add ProgressStream class (event emitter for progress tracking)
- Add progress event types (step_start, step_complete, step_error, cancel)
- Emit progress events in AIEnhancementService (6 steps)
- Replace generic notification with VS Code withProgress API
- Show completed steps with checkmarks (✓)
- Show current step with spinner (⏳)
- Show failed steps with error icon (✗)
- Display elapsed time for each step
- Add [Cancel] button with abort logic (CancellationToken)
- Throttle UI updates to 16ms (60 FPS, imperceptible lag)
- Add unit tests (70% coverage)

Progress steps tracked:
1. Normalized input (0.1s)
2. Gathered workspace context (0.8s)
3. Analyzed git history (1.2s)
4. Found patterns (0.3s)
5. Validated files (0.4s)
6. Generated enhanced prompt (1-2s)

Benefits:
- Reduces perceived wait time by 30-40%
- Builds user trust (system is working, not frozen)
- Provides transparency (user knows what's happening)
- User control (cancellation at any stage)

Closes ENHANCE-001.9"
```

---

## Success Criteria

After ENHANCE-001.9 complete:

✅ **Users see real-time enhancement progress**
- Progress notification replaces generic "Enhancing..." message

✅ **Each step displayed with status**
- ✓ Completed steps with checkmark and duration
- ⏳ Current step with spinner and elapsed time
- ✗ Failed steps with error icon and message

✅ **Elapsed time shown for current step**
- Updates in real-time (e.g., "2.1s elapsed")

✅ **Can cancel enhancement if taking too long**
- [Cancel] button aborts enhancement cleanly

✅ **Perceived wait time reduced**
- Psychological research: 30-40% reduction with visible progress

✅ **Better user experience**
- Transparency (user sees what's happening)
- Control (can cancel anytime)
- Trust (system is working, not frozen)

---

## Next Steps

After ENHANCE-001.9 is implemented and tests pass:

**All ENHANCE-001 tasks complete! (001.1 through 001.9)**

v3.0 AI Enhancement System is fully implemented:
- ✅ Foundation (IContextBuilder, EnhancementContext, AIEnhancementService)
- ✅ Simple context builders (Bug, Feature, General)
- ✅ Complex context builders (Task, Code Analyzer)
- ✅ Advanced context builder (Sprint Planner with template system)
- ✅ Template evolution (outcome tracking, self-improvement)
- ✅ Metadata passthrough (structured context for terminal AI)
- ✅ Iterative refinement UI (re-enhance with user feedback)
- ✅ Context preview & override UI (transparency and control)
- ✅ Progressive loading UI (real-time progress tracking)

---

## Pattern References

- **Pattern-CODE-001:** Code development workflow
- **Pattern-TDD-001:** Test-driven development (RED → GREEN → REFACTOR)
- **Pattern-UX-001:** User experience design (transparency reduces perceived wait time)
- **Pattern-TASK-ANALYSIS-001:** 8-step pre-task analysis
- **Pattern-GIT-001:** Git workflow integration

---

**Template Version:** MVP-003-PromptEnhancer-TaskTemplate-v1.4.3
**Generated:** 2025-01-13
**For:** ENHANCE-001.9 (Progressive Loading UI - Real-time Enhancement Progress)
