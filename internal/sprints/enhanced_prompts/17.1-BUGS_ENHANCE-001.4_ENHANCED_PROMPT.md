# ENHANCE-001.4: Advanced Context Builder (Sprint Planner with Template System)

**Sprint:** 17.1-BUGS
**Task ID:** ENHANCE-001.4
**Agent:** infrastructure-agent
**Estimated Time:** 4-5 hours
**Dependencies:** ENHANCE-001.3
**Template Version:** MVP-003-PromptEnhancer-TaskTemplate-v1.4.3

---

## Step 0: Pre-Task Analysis (MANDATORY - Run Pattern-TASK-ANALYSIS-001)

**CRITICAL: You MUST complete this 8-step analysis OUT LOUD before writing ANY code.**

### 1. UNDERSTAND the Task

**Task Goal:**
Implement SprintPlannerContextBuilder, the most complex context builder in the v3.0 AI Enhancement System. This builder coordinates 5 systems (sprint, agent, pattern, git, template) to provide comprehensive context for AI sprint planning enhancement.

**Why This Task Exists:**
Sprint Planner enhancement requires orchestrating multiple data sources:
- Existing sprints (to avoid duplication)
- Sprint template system (SPRINT_TEMPLATE.toml with 27 normalized tasks)
- Agent capabilities (expertise areas, test coverage requirements)
- Git branch info (feature/master detection)
- Sprint planning patterns (Pattern-SPRINT-PLAN-001, Pattern-SPRINT-TEMPLATE-001)

This is the most advanced context builder because it must coordinate cross-system data gathering and provide AI with deep awareness of the sprint ecosystem.

**Current vs. Desired State:**
- **CURRENT:** Sprint Planner calls TemplateTaskBuilder + TaskPromptExporter with hardcoded logic
- **DESIRED:** SprintPlannerContextBuilder implements IContextBuilder interface, orchestrates 5-component data gathering, returns normalized EnhancementContext

### 2. CHECK for Existing Solutions

**Search Strategy:**
```bash
# Search for sprint loading logic
grep -r "ACTIVE_SPRINT" vscode-lumina/src/

# Search for template system integration
grep -r "SPRINT_TEMPLATE" vscode-lumina/src/

# Search for agent capabilities loading
grep -r "agent.*expertise" vscode-lumina/src/

# Check if SprintPlannerContextBuilder already exists
find vscode-lumina/src/ -name "*SprintPlanner*"
```

**Expected Findings:**
- SprintManager.ts loads sprint TOML files (reuse this logic)
- TemplateTaskBuilder.ts may have template loading logic (reuse if possible)
- Agent context files in internal/agents/ (need parser for these)

### 3. IDENTIFY Required Changes

**Files to Create:**
1. `vscode-lumina/src/services/enhancement/SprintPlannerContextBuilder.ts` (~350 lines)
   - Implements IContextBuilder interface
   - Orchestrates 5 data gathering components
   - Returns EnhancementContext

**Files to Read (for context):**
1. `vscode-lumina/src/types/IContextBuilder.ts` - Interface contract
2. `vscode-lumina/src/types/EnhancementContext.ts` - Return type structure
3. `vscode-lumina/src/services/SprintManager.ts` - Existing sprint loading logic
4. `vscode-lumina/src/services/TemplateTaskBuilder.ts` - Existing template logic
5. `internal/SPRINT_TEMPLATE.toml` - Template structure to parse
6. `internal/agents/*.md` - Agent context file structure

**Files to Modify:**
1. `vscode-lumina/src/commands/voicePanel.ts` - Add SprintPlannerContextBuilder to universal handler
2. `vscode-lumina/src/types/EnhancementContext.ts` - May need SprintPlannerInput type

### 4. ASSESS Impact & Risk

**Impact Assessment:**
- **Scope:** HIGH - Most complex context builder, coordinates 5 systems
- **Blast Radius:** MEDIUM - Only affects Sprint Planner button enhancement
- **Performance:** HIGH - Must load multiple files (parallel operations critical)
- **Breaking Changes:** LOW - New code, existing sprint planner unchanged

**Risk Factors:**
- ⚠️ **Complexity Risk:** 5-component orchestration, many edge cases
- ⚠️ **Performance Risk:** Loading many files (sprints, agents, patterns) could be slow
- ⚠️ **Parsing Risk:** TOML/Markdown parsing failures could break builder
- ⚠️ **Data Quality Risk:** Missing files, malformed data must not crash builder

**Mitigation Strategies:**
- Use parallel file loading (Promise.all) for performance
- Graceful degradation: if component fails, provide partial context
- Extensive error handling for all file operations
- TDD to catch edge cases early (90% coverage required)

### 5. VERIFY Dependencies & Blockers

**Dependencies:**
- ✅ **ENHANCE-001.3:** TaskContextBuilder, CodeAnalyzerContextBuilder (validates architecture)
- ✅ **IContextBuilder interface:** Defined in ENHANCE-001.1
- ✅ **EnhancementContext type:** Defined in ENHANCE-001.1
- ✅ **SprintManager.ts:** Existing sprint loading logic
- ✅ **SPRINT_TEMPLATE.toml:** Sprint template file exists

**Potential Blockers:**
- ❌ **Agent context files format unknown:** Need to read sample agent file to understand structure
- ❌ **Sprint template parsing not implemented:** May need to write TOML parser for template categories

**Blocker Resolution:**
- Read `internal/agents/developer-agent.md` to understand agent file format
- Read `internal/SPRINT_TEMPLATE.toml` to understand template structure
- Check if SprintManager already parses templates (reuse if possible)

### 6. PLAN with Git Workflow (Pattern-GIT-001)

**Current Branch:** feature/v0.17.2-bug-fixes
**Git Status:** Clean (from gitStatus snapshot)

**Workflow Steps:**
1. ✅ Verify branch: `git status` (already on feature branch)
2. ✅ Write tests FIRST (TDD RED phase)
3. ✅ Implement SprintPlannerContextBuilder (GREEN phase)
4. ✅ Optimize with parallel loading (REFACTOR phase)
5. ✅ Commit: "feat(ENHANCE-001.4): Implement SprintPlannerContextBuilder with 5-component orchestration"
6. ✅ Validation: Run tests, verify integration

**Commit Message Template:**
```
feat(ENHANCE-001.4): Implement SprintPlannerContextBuilder with 5-component orchestration

- Add SprintPlannerContextBuilder implementing IContextBuilder
- Load existing sprints from internal/sprints/ (glob + parse)
- Load sprint template (SPRINT_TEMPLATE.toml) with 4 task categories
- Load agent capabilities from internal/agents/ (expertise + coverage)
- Analyze git branch (feature/master detection)
- Search for sprint planning patterns
- Orchestrate 5 components into EnhancementContext
- Add unit tests (90% coverage)
- Optimize with parallel file loading (< 2 seconds)

Closes ENHANCE-001.4
```

### 7. CHECK Patterns & SOPs

**Applicable Patterns:**
- ✅ **Pattern-CODE-001:** Code development workflow (announced OUT LOUD)
- ✅ **Pattern-TDD-001:** Tests FIRST (RED → GREEN → REFACTOR)
- ✅ **Pattern-SPRINT-PLAN-001:** Sprint planning process (reference for context gathering)
- ✅ **Pattern-SPRINT-TEMPLATE-001:** Sprint template system with 27 normalized tasks

**Pattern Integration:**
- SprintPlannerContextBuilder must load Pattern-SPRINT-PLAN-001 and Pattern-SPRINT-TEMPLATE-001
- Include pattern content in EnhancementContext.metadata.patterns
- AI uses patterns to generate sprint plans with proper task injection

### 8. ESTIMATE Effort & Complexity

**Effort Estimate:** 4-5 hours (from task specification)

**Complexity Breakdown:**
- **Component 1 (Existing Sprints):** 30 min - Glob + parse sprint metadata
- **Component 2 (Sprint Template):** 45 min - Parse SPRINT_TEMPLATE.toml with 4 categories
- **Component 3 (Agent Capabilities):** 45 min - Parse agent context files for expertise
- **Component 4 (Git Branch):** 15 min - Simple git command
- **Component 5 (Pattern Search):** 30 min - Pattern library integration
- **Orchestration:** 45 min - Assemble EnhancementContext
- **Tests:** 90 min - 13 test cases (90% coverage)
- **REFACTOR:** 30 min - Parallel file loading optimization

**Total:** ~4.5 hours (matches estimate)

**Confidence Level:** MEDIUM-HIGH
- ✅ Architecture validated by ENHANCE-001.2, 001.3 (simpler builders work)
- ✅ IContextBuilder interface proven
- ⚠️ Complexity higher than previous builders (5 components vs. 1-2)
- ⚠️ Agent file parsing format unknown (need to read sample)

---

## Step 1: UNDERSTAND the Architecture

### Read Foundation Files

**CRITICAL: Read these files BEFORE writing any code.**

```bash
# Read IContextBuilder interface contract
cat vscode-lumina/src/types/IContextBuilder.ts

# Read EnhancementContext type definition
cat vscode-lumina/src/types/EnhancementContext.ts

# Read existing context builders for pattern reference
cat vscode-lumina/src/services/enhancement/TaskContextBuilder.ts
cat vscode-lumina/src/services/enhancement/CodeAnalyzerContextBuilder.ts

# Read existing sprint loading logic
cat vscode-lumina/src/services/SprintManager.ts

# Read sprint template file
cat internal/SPRINT_TEMPLATE.toml

# Read sample agent context file
cat internal/agents/developer-agent.md
```

### Architecture Overview

**v3.0 Context Builder Pattern:**
```
User clicks "Sprint Planner" button
    ↓
voicePanel.ts: handleEnhancePrompt()
    ↓
Universal Enhancement Handler
    ↓
switch (buttonType) {
    case 'sprint_planner':
        builder = new SprintPlannerContextBuilder()
        break;
}
    ↓
SprintPlannerContextBuilder.build(input)
    ↓
[5 Parallel Components]
    ↓
1. Load Existing Sprints (glob + parse)
2. Load Sprint Template (TOML parser)
3. Load Agent Capabilities (Markdown parser)
4. Analyze Git Branch (git rev-parse)
5. Search Patterns (Pattern-SPRINT-PLAN-001, Pattern-SPRINT-TEMPLATE-001)
    ↓
Assemble EnhancementContext
    ↓
AIEnhancementService.enhance(context)
    ↓
VS Code LM API generates enhanced prompt
    ↓
Display in ÆtherLight panel
```

### SprintPlannerContextBuilder Responsibilities

**Input:** SprintPlannerFormData
```typescript
interface SprintPlannerFormData {
    sprintGoal: string;         // User's sprint objective
    duration: string;           // e.g., "2 weeks", "1 week"
    priorities: string[];       // e.g., ["bug-fixes", "new-features"]
    includeRetro: boolean;      // Include retrospective tasks?
}
```

**Output:** EnhancementContext
```typescript
{
    type: 'sprint_planner',
    template: TemplateTask,     // MVP-003 template structure
    metadata: {
        buttonType: 'sprint_planner',
        confidence: { score: 85, level: 'high' },
        patterns: ['Pattern-SPRINT-PLAN-001', 'Pattern-SPRINT-TEMPLATE-001'],
        agent: 'sprint-planner-agent',
        validation: { filesExist: true, dependenciesMet: true, taskDataCurrent: true }
    },
    workspaceContext: {
        rootPath: string,
        languages: string[],
        frameworks: string[],
        filesFound: [],
        gitCommits: [],
        sops: { claudeMd: string, aetherlightMd: string }
    },
    specificContext: {
        existingSprints: SprintMetadata[],
        sprintTemplate: SprintTemplateData,
        agentCapabilities: AgentCapability[],
        gitBranch: string,
        sprintGoal: string,
        duration: string,
        priorities: string[]
    }
}
```

### 5-Component Data Gathering

#### Component 1: Existing Sprints Loader

**Purpose:** Load all existing sprints to prevent duplication, provide context on sprint history

**Implementation Strategy:**
```typescript
private async loadExistingSprints(): Promise<SprintMetadata[]> {
    // Glob for all ACTIVE_SPRINT_*.toml files in internal/sprints/
    const sprintFiles = glob.sync('internal/sprints/ACTIVE_SPRINT_*.toml');

    // Parse each sprint file in parallel
    const sprints = await Promise.all(
        sprintFiles.map(async (file) => {
            const content = await fs.promises.readFile(file, 'utf-8');
            const parsed = TOML.parse(content);

            return {
                id: path.basename(file, '.toml').replace('ACTIVE_SPRINT_', ''),
                name: parsed.metadata?.name || 'Unknown',
                status: parsed.metadata?.status || 'unknown',
                taskCount: Object.keys(parsed.tasks || {}).length,
                filePath: file
            };
        })
    );

    return sprints;
}
```

**Data Structure:**
```typescript
interface SprintMetadata {
    id: string;           // e.g., "17.1-BUGS"
    name: string;         // e.g., "Bug Fixes & Polish"
    status: string;       // e.g., "active", "completed"
    taskCount: number;    // e.g., 42
    filePath: string;     // Absolute path to TOML file
}
```

#### Component 2: Sprint Template Loader

**Purpose:** Load SPRINT_TEMPLATE.toml with 27 normalized tasks categorized into REQUIRED, SUGGESTED, CONDITIONAL, RETROSPECTIVE

**Implementation Strategy:**
```typescript
private async loadSprintTemplate(): Promise<SprintTemplateData> {
    const templatePath = 'internal/SPRINT_TEMPLATE.toml';
    const content = await fs.promises.readFile(templatePath, 'utf-8');
    const parsed = TOML.parse(content);

    // Extract 4 task categories
    const required = this.extractTemplateTasks(parsed, 'required');
    const suggested = this.extractTemplateTasks(parsed, 'suggested');
    const conditional = this.extractTemplateTasks(parsed, 'conditional');
    const retrospective = this.extractTemplateTasks(parsed, 'retrospective');

    return {
        required: required,      // 14 tasks
        suggested: suggested,    // 4 tasks
        conditional: conditional, // 8 tasks
        retrospective: retrospective, // 2 tasks
        totalTasks: required.length + suggested.length + conditional.length + retrospective.length
    };
}

private extractTemplateTasks(parsed: any, category: string): TemplateTask[] {
    // Extract tasks from parsed TOML based on category
    // REQUIRED: documentation, tests, validation, etc.
    // SUGGESTED: performance, security, compatibility
    // CONDITIONAL: publishing tasks (if releasing), UX tasks (if UI changes)
    // RETROSPECTIVE: sprint retro, pattern extraction

    const tasks = parsed.template?.[category] || {};
    return Object.values(tasks).map((task: any) => ({
        id: task.id,
        name: task.name,
        category: category,
        description: task.description,
        agent: task.agent,
        estimatedTime: task.estimated_time
    }));
}
```

**Data Structure:**
```typescript
interface SprintTemplateData {
    required: TemplateTask[];        // 14 tasks (MUST inject)
    suggested: TemplateTask[];       // 4 tasks (can skip with justification)
    conditional: TemplateTask[];     // 0-8 tasks (inject if conditions met)
    retrospective: TemplateTask[];   // 2 tasks (MUST inject at end)
    totalTasks: number;              // 19-27 tasks
}

interface TemplateTask {
    id: string;
    name: string;
    category: 'required' | 'suggested' | 'conditional' | 'retrospective';
    description: string;
    agent: string;
    estimatedTime: string;
}
```

#### Component 3: Agent Capabilities Loader

**Purpose:** Load all agent context files, extract expertise areas and test coverage requirements

**Implementation Strategy:**
```typescript
private async loadAgentCapabilities(): Promise<AgentCapability[]> {
    const agentFiles = glob.sync('internal/agents/*.md');

    const agents = await Promise.all(
        agentFiles.map(async (file) => {
            const content = await fs.promises.readFile(file, 'utf-8');

            // Parse Markdown frontmatter or structured sections
            const name = this.extractAgentName(content);
            const expertise = this.extractExpertise(content);
            const testCoverage = this.extractTestCoverage(content);

            return {
                name: name,
                expertise: expertise,
                testCoverage: testCoverage,
                filePath: file
            };
        })
    );

    return agents;
}

private extractExpertise(content: string): string[] {
    // Search for "Expertise:" or "Responsibilities:" section
    // Extract bullet points or comma-separated list
    // Example: ["TypeScript", "Node.js", "VS Code API", "Testing"]
    const expertiseMatch = content.match(/(?:Expertise|Responsibilities):\s*\n((?:[-*]\s*.+\n?)+)/i);
    if (expertiseMatch) {
        return expertiseMatch[1]
            .split('\n')
            .map(line => line.replace(/^[-*]\s*/, '').trim())
            .filter(Boolean);
    }
    return [];
}

private extractTestCoverage(content: string): number {
    // Search for test coverage requirement
    // Example: "Test Coverage: 90%", "Coverage: 85%"
    const coverageMatch = content.match(/(?:Test\s+)?Coverage:\s*(\d+)%/i);
    return coverageMatch ? parseInt(coverageMatch[1]) : 80; // Default 80%
}
```

**Data Structure:**
```typescript
interface AgentCapability {
    name: string;               // e.g., "developer-agent"
    expertise: string[];        // e.g., ["TypeScript", "Node.js", "Testing"]
    testCoverage: number;       // e.g., 90 (percentage)
    filePath: string;           // Absolute path to agent file
}
```

#### Component 4: Git Branch Analyzer

**Purpose:** Get current branch name, detect if on feature branch or master

**Implementation Strategy:**
```typescript
private async analyzeGitBranch(): Promise<GitBranchInfo> {
    try {
        // Get current branch name
        const branchResult = await exec('git rev-parse --abbrev-ref HEAD');
        const branch = branchResult.stdout.trim();

        // Detect branch type
        const isFeatureBranch = branch.startsWith('feature/') || branch.startsWith('feat/');
        const isMainBranch = ['master', 'main'].includes(branch);

        return {
            name: branch,
            isFeature: isFeatureBranch,
            isMain: isMainBranch,
            type: isFeatureBranch ? 'feature' : isMainBranch ? 'main' : 'other'
        };
    } catch (error) {
        // Git command failed (no git, detached HEAD, etc.)
        console.warn('[SprintPlannerContextBuilder] Git branch analysis failed:', error);
        return {
            name: 'unknown',
            isFeature: false,
            isMain: false,
            type: 'other'
        };
    }
}
```

**Data Structure:**
```typescript
interface GitBranchInfo {
    name: string;               // e.g., "feature/v0.17.2-bug-fixes"
    isFeature: boolean;         // true if feature/ or feat/ prefix
    isMain: boolean;            // true if master or main
    type: 'feature' | 'main' | 'other';
}
```

#### Component 5: Pattern Search

**Purpose:** Find sprint planning patterns (Pattern-SPRINT-PLAN-001, Pattern-SPRINT-TEMPLATE-001)

**Implementation Strategy:**
```typescript
private async searchSprintPatterns(): Promise<string[]> {
    const patternIds = [
        'Pattern-SPRINT-PLAN-001',
        'Pattern-SPRINT-TEMPLATE-001',
        'Pattern-GIT-001',
        'Pattern-TASK-ANALYSIS-001'
    ];

    // If PatternLibrary service exists, use it
    if (this.patternLibrary) {
        const patterns = await this.patternLibrary.findPatterns(patternIds);
        return patterns.map(p => p.id);
    }

    // Otherwise, return pattern IDs (AI will look them up)
    return patternIds;
}
```

**Data Structure:**
```typescript
type PatternList = string[];  // e.g., ["Pattern-SPRINT-PLAN-001", "Pattern-SPRINT-TEMPLATE-001"]
```

---

## Step 2: TDD - Write Tests FIRST (RED Phase)

**CRITICAL: Pattern-TDD-001 requires writing tests BEFORE implementation.**

### Test File Structure

**File:** `vscode-lumina/test/services/enhancement/SprintPlannerContextBuilder.test.ts`

```typescript
import * as assert from 'assert';
import { SprintPlannerContextBuilder } from '../../../src/services/enhancement/SprintPlannerContextBuilder';
import { EnhancementContext } from '../../../src/types/EnhancementContext';

describe('SprintPlannerContextBuilder', () => {
    let builder: SprintPlannerContextBuilder;

    beforeEach(() => {
        builder = new SprintPlannerContextBuilder();
    });

    // TEST 1: Basic interface contract
    describe('IContextBuilder contract', () => {
        it('should implement build() method returning EnhancementContext', async () => {
            const input = {
                sprintGoal: 'Implement AI enhancement system',
                duration: '2 weeks',
                priorities: ['new-features'],
                includeRetro: true
            };

            const context = await builder.build(input);

            assert.strictEqual(context.type, 'sprint_planner');
            assert.ok(context.template);
            assert.ok(context.metadata);
            assert.ok(context.workspaceContext);
            assert.ok(context.specificContext);
        });
    });

    // TEST 2-3: Component 1 - Existing Sprints
    describe('Existing sprints loading', () => {
        it('should load all ACTIVE_SPRINT_*.toml files', async () => {
            const input = { sprintGoal: 'Test', duration: '1 week', priorities: [], includeRetro: false };
            const context = await builder.build(input);

            const sprints = context.specificContext.existingSprints;
            assert.ok(Array.isArray(sprints));
            // Should find at least ACTIVE_SPRINT_17.1_BUGS.toml
            assert.ok(sprints.length > 0);
        });

        it('should parse sprint metadata correctly', async () => {
            const input = { sprintGoal: 'Test', duration: '1 week', priorities: [], includeRetro: false };
            const context = await builder.build(input);

            const sprint = context.specificContext.existingSprints[0];
            assert.ok(sprint.id);           // e.g., "17.1-BUGS"
            assert.ok(sprint.name);         // e.g., "Bug Fixes & Polish"
            assert.ok(sprint.status);       // e.g., "active"
            assert.ok(sprint.taskCount);    // e.g., 42
            assert.ok(sprint.filePath);     // Absolute path
        });
    });

    // TEST 4-8: Component 2 - Sprint Template
    describe('Sprint template loading', () => {
        it('should load SPRINT_TEMPLATE.toml successfully', async () => {
            const input = { sprintGoal: 'Test', duration: '1 week', priorities: [], includeRetro: false };
            const context = await builder.build(input);

            const template = context.specificContext.sprintTemplate;
            assert.ok(template);
            assert.ok(template.required);
            assert.ok(template.suggested);
            assert.ok(template.conditional);
            assert.ok(template.retrospective);
        });

        it('should extract REQUIRED tasks (14 tasks)', async () => {
            const input = { sprintGoal: 'Test', duration: '1 week', priorities: [], includeRetro: false };
            const context = await builder.build(input);

            const required = context.specificContext.sprintTemplate.required;
            assert.strictEqual(required.length, 14);

            // Verify structure of first task
            assert.ok(required[0].id);
            assert.ok(required[0].name);
            assert.strictEqual(required[0].category, 'required');
        });

        it('should extract SUGGESTED tasks (4 tasks)', async () => {
            const input = { sprintGoal: 'Test', duration: '1 week', priorities: [], includeRetro: false };
            const context = await builder.build(input);

            const suggested = context.specificContext.sprintTemplate.suggested;
            assert.strictEqual(suggested.length, 4);
            assert.strictEqual(suggested[0].category, 'suggested');
        });

        it('should extract CONDITIONAL tasks (8 tasks)', async () => {
            const input = { sprintGoal: 'Test', duration: '1 week', priorities: [], includeRetro: false };
            const context = await builder.build(input);

            const conditional = context.specificContext.sprintTemplate.conditional;
            assert.strictEqual(conditional.length, 8);
            assert.strictEqual(conditional[0].category, 'conditional');
        });

        it('should extract RETROSPECTIVE tasks (2 tasks)', async () => {
            const input = { sprintGoal: 'Test', duration: '1 week', priorities: [], includeRetro: false };
            const context = await builder.build(input);

            const retrospective = context.specificContext.sprintTemplate.retrospective;
            assert.strictEqual(retrospective.length, 2);
            assert.strictEqual(retrospective[0].category, 'retrospective');
        });
    });

    // TEST 9-11: Component 3 - Agent Capabilities
    describe('Agent capabilities loading', () => {
        it('should load all agent context files', async () => {
            const input = { sprintGoal: 'Test', duration: '1 week', priorities: [], includeRetro: false };
            const context = await builder.build(input);

            const agents = context.specificContext.agentCapabilities;
            assert.ok(Array.isArray(agents));
            assert.ok(agents.length > 0);  // Should find at least developer-agent
        });

        it('should extract agent expertise areas', async () => {
            const input = { sprintGoal: 'Test', duration: '1 week', priorities: [], includeRetro: false };
            const context = await builder.build(input);

            const agent = context.specificContext.agentCapabilities.find(a => a.name.includes('developer'));
            assert.ok(agent);
            assert.ok(Array.isArray(agent.expertise));
            assert.ok(agent.expertise.length > 0);
        });

        it('should extract test coverage requirements', async () => {
            const input = { sprintGoal: 'Test', duration: '1 week', priorities: [], includeRetro: false };
            const context = await builder.build(input);

            const agent = context.specificContext.agentCapabilities[0];
            assert.ok(typeof agent.testCoverage === 'number');
            assert.ok(agent.testCoverage >= 70 && agent.testCoverage <= 100);
        });
    });

    // TEST 12: Component 4 - Git Branch
    describe('Git branch analysis', () => {
        it('should get current git branch name', async () => {
            const input = { sprintGoal: 'Test', duration: '1 week', priorities: [], includeRetro: false };
            const context = await builder.build(input);

            const branch = context.specificContext.gitBranch;
            assert.ok(typeof branch === 'string');
            assert.ok(branch.length > 0);
            // Should detect feature/v0.17.2-bug-fixes
            assert.ok(branch === 'feature/v0.17.2-bug-fixes' || branch.includes('feature'));
        });
    });

    // TEST 13: Component 5 - Pattern Search
    describe('Pattern search', () => {
        it('should find sprint planning patterns', async () => {
            const input = { sprintGoal: 'Test', duration: '1 week', priorities: [], includeRetro: false };
            const context = await builder.build(input);

            const patterns = context.metadata.patterns;
            assert.ok(Array.isArray(patterns));
            assert.ok(patterns.includes('Pattern-SPRINT-PLAN-001'));
            assert.ok(patterns.includes('Pattern-SPRINT-TEMPLATE-001'));
        });
    });

    // TEST 14: EnhancementContext Assembly
    describe('EnhancementContext assembly', () => {
        it('should assemble complete EnhancementContext with all 5 components', async () => {
            const input = {
                sprintGoal: 'Implement AI enhancement system',
                duration: '2 weeks',
                priorities: ['new-features', 'bug-fixes'],
                includeRetro: true
            };

            const context = await builder.build(input);

            // Verify type
            assert.strictEqual(context.type, 'sprint_planner');

            // Verify metadata
            assert.strictEqual(context.metadata.buttonType, 'sprint_planner');
            assert.ok(context.metadata.confidence.score >= 70);
            assert.strictEqual(context.metadata.agent, 'sprint-planner-agent');

            // Verify specificContext has all 5 components
            assert.ok(context.specificContext.existingSprints);
            assert.ok(context.specificContext.sprintTemplate);
            assert.ok(context.specificContext.agentCapabilities);
            assert.ok(context.specificContext.gitBranch);
            assert.ok(context.metadata.patterns.length >= 2);

            // Verify user input passed through
            assert.strictEqual(context.specificContext.sprintGoal, 'Implement AI enhancement system');
            assert.strictEqual(context.specificContext.duration, '2 weeks');
            assert.deepStrictEqual(context.specificContext.priorities, ['new-features', 'bug-fixes']);
        });
    });

    // TEST 15-17: Error Handling
    describe('Error handling', () => {
        it('should handle no existing sprints gracefully (first sprint)', async () => {
            // TODO: Mock fs.glob to return empty array
            // Verify: existingSprints = [], does not crash
        });

        it('should handle missing SPRINT_TEMPLATE.toml (use defaults)', async () => {
            // TODO: Mock fs.readFile to throw ENOENT
            // Verify: sprintTemplate has empty arrays, does not crash
        });

        it('should handle git command failures (provide basic context)', async () => {
            // TODO: Mock exec to throw error
            // Verify: gitBranch = 'unknown', does not crash
        });
    });

    // TEST 18: Performance
    describe('Performance', () => {
        it('should build context in < 2 seconds', async () => {
            const input = { sprintGoal: 'Test', duration: '1 week', priorities: [], includeRetro: false };

            const startTime = Date.now();
            await builder.build(input);
            const duration = Date.now() - startTime;

            assert.ok(duration < 2000, `Context building took ${duration}ms (expected < 2000ms)`);
        });
    });
});
```

### Run Tests (Expected to FAIL - RED Phase)

```bash
cd vscode-lumina
npm test -- --grep "SprintPlannerContextBuilder"
```

**Expected Output:**
```
SprintPlannerContextBuilder
  ❌ should implement build() method returning EnhancementContext
  Error: Cannot find module '../../../src/services/enhancement/SprintPlannerContextBuilder'

  ... 17 more failures

  0 passing (12ms)
  18 failing
```

**Status:** ✅ RED phase complete (tests exist, implementation missing)

---

## Step 3: Implementation - SprintPlannerContextBuilder (GREEN Phase)

### File Structure

**File:** `vscode-lumina/src/services/enhancement/SprintPlannerContextBuilder.ts`

```typescript
/**
 * SprintPlannerContextBuilder
 *
 * DESIGN DECISION: Most complex context builder - orchestrates 5 systems
 * WHY: Sprint planning requires comprehensive context from multiple sources
 *
 * REASONING CHAIN:
 * 1. Sprint Planner enhancement needs to know existing sprints (avoid duplication)
 * 2. Must inject 27 normalized tasks from SPRINT_TEMPLATE.toml (Pattern-SPRINT-TEMPLATE-001)
 * 3. Must assign agents based on expertise (not random)
 * 4. Must respect test coverage requirements per agent
 * 5. Must detect git branch (feature vs. main affects sprint scope)
 * 6. Must find sprint planning patterns (Pattern-SPRINT-PLAN-001)
 * 7. Result: Orchestrate 5 components into single EnhancementContext
 *
 * PATTERN: Pattern-ORCHESTRATION-001 (Multi-Source Data Orchestration)
 * ARCHITECTURE: v3.0 Context Builder Pattern
 * RELATED: IContextBuilder.ts, EnhancementContext.ts, SprintManager.ts
 *
 * PERFORMANCE:
 * - Parallel file loading (Promise.all for 5 components)
 * - Target: < 2 seconds for complete context building
 * - Graceful degradation: if component fails, provide partial context
 */

import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';
import * as TOML from '@iarna/toml';
import { promisify } from 'util';
import { exec as execCallback } from 'child_process';
import { IContextBuilder } from '../../types/IContextBuilder';
import { EnhancementContext, EnhancementType } from '../../types/EnhancementContext';
import { TemplateTask } from '../TemplateTaskBuilder';

const exec = promisify(execCallback);
const glob = require('glob'); // TODO: Use built-in glob when Node.js 18+ available

// ============================================================================
// Type Definitions
// ============================================================================

interface SprintPlannerInput {
    sprintGoal: string;         // User's sprint objective
    duration: string;           // e.g., "2 weeks", "1 week"
    priorities: string[];       // e.g., ["bug-fixes", "new-features"]
    includeRetro: boolean;      // Include retrospective tasks?
}

interface SprintMetadata {
    id: string;           // e.g., "17.1-BUGS"
    name: string;         // e.g., "Bug Fixes & Polish"
    status: string;       // e.g., "active", "completed"
    taskCount: number;    // Number of tasks in sprint
    filePath: string;     // Absolute path to TOML file
}

interface SprintTemplateData {
    required: TemplateTask[];        // 14 tasks (MUST inject)
    suggested: TemplateTask[];       // 4 tasks (can skip with justification)
    conditional: TemplateTask[];     // 0-8 tasks (inject if conditions met)
    retrospective: TemplateTask[];   // 2 tasks (MUST inject at end)
    totalTasks: number;              // 19-27 tasks
}

interface AgentCapability {
    name: string;               // e.g., "developer-agent"
    expertise: string[];        // e.g., ["TypeScript", "Node.js", "Testing"]
    testCoverage: number;       // e.g., 90 (percentage)
    filePath: string;           // Absolute path to agent file
}

interface GitBranchInfo {
    name: string;               // e.g., "feature/v0.17.2-bug-fixes"
    isFeature: boolean;         // true if feature/ or feat/ prefix
    isMain: boolean;            // true if master or main
    type: 'feature' | 'main' | 'other';
}

// ============================================================================
// SprintPlannerContextBuilder Implementation
// ============================================================================

export class SprintPlannerContextBuilder implements IContextBuilder {
    private workspaceRoot: string;

    constructor() {
        this.workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || process.cwd();
    }

    /**
     * Build comprehensive sprint planning context
     *
     * Orchestrates 5 parallel components:
     * 1. Load existing sprints (prevent duplication)
     * 2. Load sprint template (27 normalized tasks)
     * 3. Load agent capabilities (expertise + test coverage)
     * 4. Analyze git branch (feature vs. main)
     * 5. Search sprint planning patterns
     *
     * Performance: < 2 seconds via Promise.all
     * Error handling: Graceful degradation (partial context on failure)
     */
    async build(input: SprintPlannerInput): Promise<EnhancementContext> {
        try {
            // Parallel component loading for performance
            const [
                existingSprints,
                sprintTemplate,
                agentCapabilities,
                gitBranch,
                patterns
            ] = await Promise.all([
                this.loadExistingSprints(),
                this.loadSprintTemplate(),
                this.loadAgentCapabilities(),
                this.analyzeGitBranch(),
                this.searchSprintPatterns()
            ]);

            // Calculate confidence based on data quality
            const confidence = this.calculateConfidence(
                existingSprints,
                sprintTemplate,
                agentCapabilities
            );

            // Assemble EnhancementContext
            return {
                type: 'sprint_planner' as EnhancementType,
                template: this.buildTemplate(input),
                metadata: {
                    buttonType: 'sprint_planner',
                    confidence: confidence,
                    patterns: patterns,
                    agent: 'sprint-planner-agent',
                    validation: {
                        filesExist: true,           // No files to validate for sprint planning
                        dependenciesMet: true,      // No dependencies
                        taskDataCurrent: true       // Data just gathered
                    }
                },
                workspaceContext: await this.buildWorkspaceContext(),
                specificContext: {
                    // Component 1: Existing sprints
                    existingSprints: existingSprints,

                    // Component 2: Sprint template
                    sprintTemplate: sprintTemplate,

                    // Component 3: Agent capabilities
                    agentCapabilities: agentCapabilities,

                    // Component 4: Git branch
                    gitBranch: gitBranch.name,
                    gitBranchType: gitBranch.type,

                    // User input
                    sprintGoal: input.sprintGoal,
                    duration: input.duration,
                    priorities: input.priorities,
                    includeRetro: input.includeRetro
                }
            };

        } catch (error) {
            console.error('[SprintPlannerContextBuilder] Context building failed:', error);

            // Fallback: minimal context
            return this.buildMinimalContext(input);
        }
    }

    // ========================================================================
    // Component 1: Existing Sprints Loader
    // ========================================================================

    private async loadExistingSprints(): Promise<SprintMetadata[]> {
        try {
            const sprintsDir = path.join(this.workspaceRoot, 'internal', 'sprints');
            const pattern = path.join(sprintsDir, 'ACTIVE_SPRINT_*.toml');
            const sprintFiles = glob.sync(pattern);

            if (sprintFiles.length === 0) {
                console.log('[SprintPlannerContextBuilder] No existing sprints found (first sprint)');
                return [];
            }

            // Parse each sprint file in parallel
            const sprints = await Promise.all(
                sprintFiles.map(async (file: string) => {
                    try {
                        const content = await fs.promises.readFile(file, 'utf-8');
                        const parsed = TOML.parse(content) as any;

                        return {
                            id: path.basename(file, '.toml').replace('ACTIVE_SPRINT_', ''),
                            name: parsed.metadata?.name || 'Unknown Sprint',
                            status: parsed.metadata?.status || 'unknown',
                            taskCount: Object.keys(parsed.tasks || {}).length,
                            filePath: file
                        };
                    } catch (error) {
                        console.warn(`[SprintPlannerContextBuilder] Failed to parse sprint ${file}:`, error);
                        return null;
                    }
                })
            );

            // Filter out failed parses
            return sprints.filter((s): s is SprintMetadata => s !== null);

        } catch (error) {
            console.warn('[SprintPlannerContextBuilder] Failed to load existing sprints:', error);
            return [];
        }
    }

    // ========================================================================
    // Component 2: Sprint Template Loader
    // ========================================================================

    private async loadSprintTemplate(): Promise<SprintTemplateData> {
        try {
            const templatePath = path.join(this.workspaceRoot, 'internal', 'SPRINT_TEMPLATE.toml');
            const content = await fs.promises.readFile(templatePath, 'utf-8');
            const parsed = TOML.parse(content) as any;

            // Extract 4 task categories
            const required = this.extractTemplateTasks(parsed, 'required');
            const suggested = this.extractTemplateTasks(parsed, 'suggested');
            const conditional = this.extractTemplateTasks(parsed, 'conditional');
            const retrospective = this.extractTemplateTasks(parsed, 'retrospective');

            return {
                required: required,
                suggested: suggested,
                conditional: conditional,
                retrospective: retrospective,
                totalTasks: required.length + suggested.length + conditional.length + retrospective.length
            };

        } catch (error) {
            console.warn('[SprintPlannerContextBuilder] Failed to load sprint template:', error);

            // Fallback: empty template
            return {
                required: [],
                suggested: [],
                conditional: [],
                retrospective: [],
                totalTasks: 0
            };
        }
    }

    private extractTemplateTasks(parsed: any, category: string): TemplateTask[] {
        try {
            const tasks = parsed.template?.[category] || {};

            return Object.entries(tasks).map(([key, task]: [string, any]) => ({
                id: task.id || key,
                name: task.name || 'Unnamed Task',
                category: category,
                description: task.description || '',
                agent: task.agent || 'developer-agent',
                estimatedTime: task.estimated_time || '1 hour',
                phase: task.phase || category,
                patterns: task.patterns || [],
                files_to_modify: task.files_to_modify || []
            }));

        } catch (error) {
            console.warn(`[SprintPlannerContextBuilder] Failed to extract ${category} tasks:`, error);
            return [];
        }
    }

    // ========================================================================
    // Component 3: Agent Capabilities Loader
    // ========================================================================

    private async loadAgentCapabilities(): Promise<AgentCapability[]> {
        try {
            const agentsDir = path.join(this.workspaceRoot, 'internal', 'agents');
            const pattern = path.join(agentsDir, '*.md');
            const agentFiles = glob.sync(pattern);

            if (agentFiles.length === 0) {
                console.warn('[SprintPlannerContextBuilder] No agent context files found');
                return [];
            }

            // Parse each agent file in parallel
            const agents = await Promise.all(
                agentFiles.map(async (file: string) => {
                    try {
                        const content = await fs.promises.readFile(file, 'utf-8');

                        return {
                            name: this.extractAgentName(file, content),
                            expertise: this.extractExpertise(content),
                            testCoverage: this.extractTestCoverage(content),
                            filePath: file
                        };
                    } catch (error) {
                        console.warn(`[SprintPlannerContextBuilder] Failed to parse agent ${file}:`, error);
                        return null;
                    }
                })
            );

            // Filter out failed parses
            return agents.filter((a): a is AgentCapability => a !== null);

        } catch (error) {
            console.warn('[SprintPlannerContextBuilder] Failed to load agent capabilities:', error);
            return [];
        }
    }

    private extractAgentName(filePath: string, content: string): string {
        // Try to extract from filename first
        const basename = path.basename(filePath, '.md');

        // Try to extract from Markdown header
        const headerMatch = content.match(/^#\s+(.+)$/m);
        if (headerMatch) {
            return headerMatch[1].trim();
        }

        return basename;
    }

    private extractExpertise(content: string): string[] {
        // Search for "Expertise:" or "Responsibilities:" section
        const expertiseMatch = content.match(/(?:Expertise|Responsibilities):\s*\n((?:[-*]\s*.+\n?)+)/i);
        if (expertiseMatch) {
            return expertiseMatch[1]
                .split('\n')
                .map(line => line.replace(/^[-*]\s*/, '').trim())
                .filter(Boolean);
        }

        // Fallback: search for bullet points in first 20 lines
        const lines = content.split('\n').slice(0, 20);
        const bullets = lines.filter(line => /^[-*]\s+/.test(line.trim()));
        if (bullets.length > 0) {
            return bullets.map(line => line.replace(/^[-*]\s*/, '').trim());
        }

        return [];
    }

    private extractTestCoverage(content: string): number {
        // Search for test coverage requirement
        const coverageMatch = content.match(/(?:Test\s+)?Coverage:\s*(\d+)%/i);
        if (coverageMatch) {
            return parseInt(coverageMatch[1]);
        }

        // Default based on agent type
        if (content.toLowerCase().includes('infrastructure')) return 90;
        if (content.toLowerCase().includes('api')) return 85;
        if (content.toLowerCase().includes('ui')) return 70;

        return 80; // Default
    }

    // ========================================================================
    // Component 4: Git Branch Analyzer
    // ========================================================================

    private async analyzeGitBranch(): Promise<GitBranchInfo> {
        try {
            const result = await exec('git rev-parse --abbrev-ref HEAD', {
                cwd: this.workspaceRoot
            });
            const branch = result.stdout.trim();

            const isFeature = branch.startsWith('feature/') || branch.startsWith('feat/');
            const isMain = ['master', 'main'].includes(branch);

            return {
                name: branch,
                isFeature: isFeature,
                isMain: isMain,
                type: isFeature ? 'feature' : isMain ? 'main' : 'other'
            };

        } catch (error) {
            console.warn('[SprintPlannerContextBuilder] Git branch analysis failed:', error);

            return {
                name: 'unknown',
                isFeature: false,
                isMain: false,
                type: 'other'
            };
        }
    }

    // ========================================================================
    // Component 5: Pattern Search
    // ========================================================================

    private async searchSprintPatterns(): Promise<string[]> {
        // Sprint planning patterns (hardcoded for now)
        return [
            'Pattern-SPRINT-PLAN-001',
            'Pattern-SPRINT-TEMPLATE-001',
            'Pattern-GIT-001',
            'Pattern-TASK-ANALYSIS-001',
            'Pattern-CODE-001',
            'Pattern-TDD-001'
        ];

        // TODO: Integrate with PatternLibrary service for dynamic pattern search
    }

    // ========================================================================
    // Helper Methods
    // ========================================================================

    private calculateConfidence(
        sprints: SprintMetadata[],
        template: SprintTemplateData,
        agents: AgentCapability[]
    ): { score: number; level: 'high' | 'medium' | 'low' } {
        let score = 50; // Base score

        // Bonus for existing sprints (context from history)
        if (sprints.length > 0) score += 15;

        // Bonus for template loaded (normalized task injection)
        if (template.totalTasks >= 19) score += 20;

        // Bonus for agent capabilities (smart agent assignment)
        if (agents.length >= 5) score += 15;

        // Cap at 100
        score = Math.min(score, 100);

        const level = score >= 70 ? 'high' : score >= 40 ? 'medium' : 'low';

        return { score, level };
    }

    private buildTemplate(input: SprintPlannerInput): TemplateTask {
        return {
            id: 'SPRINT_PLAN',
            name: 'Sprint Planning',
            description: input.sprintGoal,
            phase: 'sprint-planning',
            agent: 'sprint-planner-agent',
            approach: 'Create comprehensive sprint plan with normalized task injection',
            patterns: ['Pattern-SPRINT-PLAN-001', 'Pattern-SPRINT-TEMPLATE-001'],
            validation_steps: [
                'Sprint TOML file created with metadata',
                'All 19-27 normalized tasks injected',
                'Agents assigned based on expertise',
                'Test coverage requirements per agent',
                'Retrospective tasks included at end'
            ],
            files_to_modify: [],
            dependencies: []
        };
    }

    private async buildWorkspaceContext(): Promise<any> {
        // TODO: Implement full workspace context gathering
        // For now, return minimal context
        return {
            rootPath: this.workspaceRoot,
            languages: ['TypeScript', 'JavaScript'],
            frameworks: ['VS Code Extension', 'Node.js'],
            filesFound: [],
            gitCommits: [],
            sops: {
                claudeMd: await this.findSOP('CLAUDE.md'),
                aetherlightMd: await this.findSOP('.vscode/aetherlight.md')
            }
        };
    }

    private async findSOP(relativePath: string): Promise<string | undefined> {
        try {
            const sopPath = path.join(this.workspaceRoot, relativePath);
            const content = await fs.promises.readFile(sopPath, 'utf-8');
            return content;
        } catch {
            return undefined;
        }
    }

    private buildMinimalContext(input: SprintPlannerInput): EnhancementContext {
        // Fallback context when orchestration fails
        return {
            type: 'sprint_planner' as EnhancementType,
            template: this.buildTemplate(input),
            metadata: {
                buttonType: 'sprint_planner',
                confidence: { score: 30, level: 'low' },
                patterns: ['Pattern-SPRINT-PLAN-001'],
                agent: 'sprint-planner-agent',
                validation: {
                    filesExist: true,
                    dependenciesMet: true,
                    taskDataCurrent: false  // Data gathering failed
                }
            },
            workspaceContext: {
                rootPath: this.workspaceRoot,
                languages: [],
                frameworks: [],
                filesFound: [],
                gitCommits: [],
                sops: {}
            },
            specificContext: {
                existingSprints: [],
                sprintTemplate: { required: [], suggested: [], conditional: [], retrospective: [], totalTasks: 0 },
                agentCapabilities: [],
                gitBranch: 'unknown',
                sprintGoal: input.sprintGoal,
                duration: input.duration,
                priorities: input.priorities
            }
        };
    }
}
```

### Run Tests (Expected to PASS - GREEN Phase)

```bash
cd vscode-lumina
npm run compile
npm test -- --grep "SprintPlannerContextBuilder"
```

**Expected Output:**
```
SprintPlannerContextBuilder
  IContextBuilder contract
    ✓ should implement build() method returning EnhancementContext (245ms)
  Existing sprints loading
    ✓ should load all ACTIVE_SPRINT_*.toml files (89ms)
    ✓ should parse sprint metadata correctly (67ms)
  Sprint template loading
    ✓ should load SPRINT_TEMPLATE.toml successfully (112ms)
    ✓ should extract REQUIRED tasks (14 tasks) (98ms)
    ✓ should extract SUGGESTED tasks (4 tasks) (87ms)
    ✓ should extract CONDITIONAL tasks (8 tasks) (91ms)
    ✓ should extract RETROSPECTIVE tasks (2 tasks) (85ms)
  Agent capabilities loading
    ✓ should load all agent context files (134ms)
    ✓ should extract agent expertise areas (76ms)
    ✓ should extract test coverage requirements (69ms)
  Git branch analysis
    ✓ should get current git branch name (45ms)
  Pattern search
    ✓ should find sprint planning patterns (12ms)
  EnhancementContext assembly
    ✓ should assemble complete EnhancementContext with all 5 components (287ms)
  Performance
    ✓ should build context in < 2 seconds (1542ms)

15 passing (1.6s)
```

**Status:** ✅ GREEN phase complete (tests pass, implementation working)

---

## Step 4: Integration with Universal Handler

### Modify voicePanel.ts

**File:** `vscode-lumina/src/commands/voicePanel.ts`

**Location:** Inside `handleEnhancePrompt()` method, add SprintPlannerContextBuilder to switch statement

```typescript
// Around line 450-550 (inside handleEnhancePrompt method)

import { SprintPlannerContextBuilder } from '../services/enhancement/SprintPlannerContextBuilder';

// ...

async handleEnhancePrompt(buttonType: string, formData: any): Promise<void> {
    try {
        // ... existing code ...

        // Create appropriate context builder based on button type
        let builder: IContextBuilder;

        switch (buttonType) {
            case 'task':
                builder = new TaskContextBuilder();
                break;

            case 'bug':
                builder = new BugReportContextBuilder();
                break;

            case 'feature':
                builder = new FeatureRequestContextBuilder();
                break;

            case 'code_analyzer':
                builder = new CodeAnalyzerContextBuilder();
                break;

            case 'sprint_planner':
                builder = new SprintPlannerContextBuilder();
                break;

            case 'general':
                builder = new GeneralContextBuilder();
                break;

            default:
                throw new Error(`Unknown button type: ${buttonType}`);
        }

        // Build context
        const context = await builder.build(formData);

        // Enhance with AI
        const enhancedPrompt = await this.aiEnhancementService.enhance(context);

        // Display in panel
        this.displayEnhancedPrompt(enhancedPrompt);

    } catch (error) {
        console.error('[ÆtherLight] Enhancement failed:', error);
        vscode.window.showErrorMessage(`Enhancement failed: ${error.message}`);
    }
}
```

### Test Integration

**Manual Test:**
1. Launch Extension Development Host (F5)
2. Click ÆtherLight icon → Sprint Planner button
3. Fill form:
   - Sprint Goal: "Implement v3.0 AI enhancement system"
   - Duration: "2 weeks"
   - Priorities: ["new-features"]
   - Include Retro: ✓
4. Click "Enhance"
5. Verify enhanced prompt displays with:
   - Existing sprints listed
   - Sprint template (27 tasks) mentioned
   - Agent capabilities listed
   - Git branch detected
   - Sprint planning patterns included

---

## Step 5: REFACTOR Phase - Performance Optimization

### Optimization Strategy

**Current Performance:** ~1.5 seconds (GREEN phase baseline)

**Target Performance:** < 2 seconds (within target)

**Optimization Opportunities:**
1. ✅ **Parallel file loading:** Already implemented (Promise.all)
2. ✅ **Graceful degradation:** Already implemented (try-catch per component)
3. ⚠️ **Caching:** Could cache sprint template, agent files (rarely change)
4. ⚠️ **Lazy loading:** Could defer pattern search until needed

**Decision:** Current performance meets target. No refactoring needed unless profiling shows bottlenecks.

### Optional Caching Enhancement

**If performance becomes an issue in production:**

```typescript
export class SprintPlannerContextBuilder implements IContextBuilder {
    private static sprintTemplateCache: SprintTemplateData | null = null;
    private static agentCapabilitiesCache: AgentCapability[] | null = null;

    private async loadSprintTemplate(): Promise<SprintTemplateData> {
        // Check cache first
        if (SprintPlannerContextBuilder.sprintTemplateCache) {
            return SprintPlannerContextBuilder.sprintTemplateCache;
        }

        // Load and cache
        const template = await this._loadSprintTemplateUncached();
        SprintPlannerContextBuilder.sprintTemplateCache = template;
        return template;
    }

    // Similar for agent capabilities
}
```

**Trade-off:** Stale cache if template/agents change. Use FileSystemWatcher to invalidate cache on file changes.

---

## Step 6: Validation & Testing

### Validation Checklist

✅ **ENHANCE-001.4 Deliverables:**
- [x] SprintPlannerContextBuilder with 5-component orchestration
- [x] Existing sprint loader (glob + parse)
- [x] Sprint template loader (SPRINT_TEMPLATE.toml parser)
- [x] Agent capabilities loader (agent context file parser)
- [x] Git branch analyzer
- [x] Pattern search integration
- [x] Complete EnhancementContext assembly
- [x] Unit tests (90% coverage)

✅ **Validation Criteria:**
- [x] Loads all existing sprints correctly
- [x] Parses sprint template with all 4 task categories
- [x] Loads all agent capabilities
- [x] Gets current git branch
- [x] Finds sprint planning patterns
- [x] Assembles complete EnhancementContext
- [x] Integration with universal handler works
- [x] Tests pass (90% coverage)

✅ **Performance Target:**
- [x] Context building < 2 seconds (1.5s measured)

✅ **Error Handling:**
- [x] Handle no existing sprints (first sprint creation)
- [x] Handle missing SPRINT_TEMPLATE.toml (use defaults)
- [x] Handle malformed agent context files (skip agent, warn user)
- [x] Handle git command failures (provide basic context)
- [x] Handle pattern library errors (skip patterns, don't fail)
- [x] Provide minimal context if enrichment fails
- [x] Log errors with component info for debugging

### Test Coverage Report

```bash
cd vscode-lumina
npm run test:coverage -- --grep "SprintPlannerContextBuilder"
```

**Expected Coverage:**
```
File                                     | % Stmts | % Branch | % Funcs | % Lines
-----------------------------------------|---------|----------|---------|--------
SprintPlannerContextBuilder.ts           |   92.3  |   87.5   |   100   |   91.7
```

**Status:** ✅ 90%+ coverage achieved

---

## Step 7: Documentation & Commit

### Update Task Status

**File:** `internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml`

Mark ENHANCE-001.4 as completed:

```toml
[tasks."ENHANCE-001.4"]
status = "completed"
```

### Commit Changes

```bash
# Stage changes
git add vscode-lumina/src/services/enhancement/SprintPlannerContextBuilder.ts
git add vscode-lumina/test/services/enhancement/SprintPlannerContextBuilder.test.ts
git add vscode-lumina/src/commands/voicePanel.ts
git add internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml

# Commit
git commit -m "feat(ENHANCE-001.4): Implement SprintPlannerContextBuilder with 5-component orchestration

- Add SprintPlannerContextBuilder implementing IContextBuilder
- Load existing sprints from internal/sprints/ (glob + parse)
- Load sprint template (SPRINT_TEMPLATE.toml) with 4 task categories
- Load agent capabilities from internal/agents/ (expertise + coverage)
- Analyze git branch (feature/master detection)
- Search for sprint planning patterns
- Orchestrate 5 components into EnhancementContext
- Add unit tests (92% coverage)
- Optimize with parallel file loading (1.5s < 2s target)
- Integrate with universal handler in voicePanel.ts

Closes ENHANCE-001.4"
```

---

## Success Criteria

After ENHANCE-001.4 complete:

✅ **Sprint Planner enhancement includes ALL existing sprints**
- AI knows about sprint history, prevents duplication

✅ **AI knows about 27 normalized template tasks**
- AI injects REQUIRED tasks (14), SUGGESTED tasks (4), CONDITIONAL tasks (0-8), RETROSPECTIVE tasks (2)

✅ **AI assigns agents based on expertise (not random)**
- Agent capabilities loaded, AI matches tasks to expertise areas

✅ **AI respects test coverage requirements per agent**
- Infrastructure: 90%, API: 85%, UI: 70%

✅ **AI prevents duplicate sprint IDs**
- Existing sprint IDs extracted, AI avoids conflicts

✅ **AI follows git branching conventions**
- Git branch detected (feature vs. main), AI suggests appropriate sprint scope

✅ **Users get comprehensive sprint plans with proper task injection**
- Enhanced prompts include all 5 components, AI generates complete sprint TOML

---

## Next Steps

After ENHANCE-001.4 is implemented and tests pass:

1. **ENHANCE-001.5:** Template Evolution System (outcome tracking, self-improvement)
2. **ENHANCE-001.6:** Metadata Passthrough (HTML comment embedding)
3. **ENHANCE-001.7:** Iterative Refinement UI (chat-style prompt refinement)
4. **ENHANCE-001.8:** Context Preview Modal (show context before enhancement)
5. **ENHANCE-001.9:** Progressive Loading UI (streaming enhancement display)

---

## Pattern References

- **Pattern-CODE-001:** Code development workflow
- **Pattern-TDD-001:** Test-driven development (RED → GREEN → REFACTOR)
- **Pattern-SPRINT-PLAN-001:** Sprint planning process
- **Pattern-SPRINT-TEMPLATE-001:** Sprint template system with 27 normalized tasks
- **Pattern-TASK-ANALYSIS-001:** 8-step pre-task analysis
- **Pattern-GIT-001:** Git workflow integration

---

**Template Version:** MVP-003-PromptEnhancer-TaskTemplate-v1.4.3
**Generated:** 2025-01-13
**For:** ENHANCE-001.4 (Advanced Context Builder - Sprint Planner with Template System)
