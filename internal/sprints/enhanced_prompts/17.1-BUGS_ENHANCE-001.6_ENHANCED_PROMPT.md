# ENHANCE-001.6: Metadata Passthrough System (Structured Context in Enhanced Prompts)

**Sprint:** 17.1-BUGS
**Task ID:** ENHANCE-001.6
**Agent:** infrastructure-agent
**Estimated Time:** 2-3 hours
**Dependencies:** ENHANCE-001.1
**Template Version:** MVP-003-PromptEnhancer-TaskTemplate-v1.4.3

---

## Step 0: Pre-Task Analysis (MANDATORY - Run Pattern-TASK-ANALYSIS-001)

**CRITICAL: You MUST complete this 8-step analysis OUT LOUD before writing ANY code.**

### 1. UNDERSTAND the Task

**Task Goal:**
Embed structured metadata as HTML comments in enhanced prompts so terminal AI agents can parse gathered context and avoid redundant analysis. This is CRITICAL for AI agent effectiveness.

**Why This Task Exists:**
**Problem from AI agent's perspective:**

When users send enhanced prompts to terminal AI, the AI receives plain text with no context about:
- Which button triggered this (Code Analyzer? Bug Report? Task?)
- What context was already gathered (workspace analysis, git commits, patterns)
- What confidence level it had (92%? 65%?)
- Whether files were already validated
- Whether user edited the prompt after enhancement

**Impact on AI Agent:**
- AI must re-analyze context (duplicate work)
- AI can't trust validation (files already checked, but AI doesn't know)
- AI can't understand intent (button type unclear)
- AI must re-ask questions (confidence level unknown)

**Solution:**
Embed structured metadata as HTML comment at top of enhanced prompt. AI parses metadata once and uses it to skip redundant work, trust validation results, and understand intent.

**Current vs. Desired State:**
- **CURRENT:** Enhanced prompts are plain markdown, no metadata
- **DESIRED:** Enhanced prompts include parseable metadata comment with button type, confidence, context summary, validation results

### 2. CHECK for Existing Solutions

**Search Strategy:**
```bash
# Search for existing metadata embedding
grep -r "metadata" vscode-lumina/src/services/AIEnhancementService.ts

# Search for HTML comment usage
grep -r "<!--" vscode-lumina/src/

# Check if embedMetadata() method exists (mentioned in AIEnhancementService.ts:268)
cat vscode-lumina/src/services/AIEnhancementService.ts | grep -A 20 "embedMetadata"
```

**Expected Findings:**
- AIEnhancementService.ts already has `embedMetadata()` method (lines 268-280)
- Method embeds metadata as HTML comment
- **This task may already be PARTIALLY implemented!**

**CRITICAL:** Read AIEnhancementService.ts carefully to see what's already there before implementing.

### 3. IDENTIFY Required Changes

**Files to Read (CRITICAL - check if already implemented):**
1. `vscode-lumina/src/services/AIEnhancementService.ts` - Check embedMetadata() method
2. `vscode-lumina/src/types/EnhancementContext.ts` - See what metadata is available

**Files to Modify (if not already implemented):**
1. `vscode-lumina/src/services/AIEnhancementService.ts` - Enhance embedMetadata() with complete schema

**Files to Create (if schema not defined):**
1. `vscode-lumina/src/types/EnhancementMetadata.ts` - Complete metadata schema definition

**Expected Work:**
- If embedMetadata() exists but incomplete → Enhance it with full schema
- If embedMetadata() doesn't exist → Implement from scratch
- Add unit tests for metadata formatting

### 4. ASSESS Impact & Risk

**Impact Assessment:**
- **Scope:** LOW - Single method modification, additive feature
- **Blast Radius:** LOW - Only affects enhanced prompt format (terminal AI benefits, no breaking changes)
- **Performance:** NEGLIGIBLE - Metadata formatting < 10ms
- **Breaking Changes:** NONE - Metadata in HTML comment is invisible to users

**Risk Factors:**
- ⚠️ **JSON Formatting Risk:** Invalid JSON breaks metadata parsing
- ⚠️ **Prompt Length Risk:** Large metadata could make prompts too long
- ⚠️ **Security Risk:** Metadata could leak sensitive workspace info

**Mitigation Strategies:**
- Validate JSON before embedding (JSON.stringify with error handling)
- Compress metadata if > 2KB (omit non-critical fields)
- Sanitize workspace paths (use relative paths, not absolute)
- Don't include sensitive data (API keys, credentials)

### 5. VERIFY Dependencies & Blockers

**Dependencies:**
- ✅ **ENHANCE-001.1:** EnhancementContext type defined
- ✅ **AIEnhancementService:** Exists, integration point clear
- ✅ **embedMetadata() method:** May already exist (lines 268-280)

**Potential Blockers:**
- ❌ **Metadata schema undefined:** What fields should be included?
- ❌ **Terminal AI parsing unknown:** How will AI parse metadata?

**Blocker Resolution:**
- Define explicit metadata schema based on EnhancementContext
- Document parsing instructions for terminal AI in metadata comment

### 6. PLAN with Git Workflow (Pattern-GIT-001)

**Current Branch:** feature/v0.17.2-bug-fixes
**Git Status:** Clean (from gitStatus snapshot)

**Workflow Steps:**
1. ✅ Verify branch: `git status` (already on feature branch)
2. ✅ Read AIEnhancementService.ts to check existing implementation
3. ✅ Write tests FIRST (TDD RED phase)
4. ✅ Implement/enhance embedMetadata() (GREEN phase)
5. ✅ Test with real enhancement (manual verification)
6. ✅ Optimize metadata size (REFACTOR phase)
7. ✅ Commit: "feat(ENHANCE-001.6): Implement metadata passthrough system"
8. ✅ Validation: Verify metadata appears in enhanced prompts

**Commit Message Template:**
```
feat(ENHANCE-001.6): Implement metadata passthrough system

- Define complete metadata schema (EnhancementMetadata)
- Enhance embedMetadata() method in AIEnhancementService
- Include button type, confidence, context summary, validation
- Format as HTML comment (invisible in terminal)
- Add JSON validation and error handling
- Add metadata compression for large contexts
- Sanitize workspace paths (relative, not absolute)
- Add unit tests (90% coverage)
- Metadata formatting overhead < 10ms

Terminal AI can now parse metadata to skip redundant analysis.

Closes ENHANCE-001.6
```

### 7. CHECK Patterns & SOPs

**Applicable Patterns:**
- ✅ **Pattern-CODE-001:** Code development workflow (announced OUT LOUD)
- ✅ **Pattern-TDD-001:** Tests FIRST (RED → GREEN → REFACTOR)

**Pattern Integration:**
- Metadata passthrough enables AI agents to work more efficiently
- Terminal AI can parse AETHERLIGHT_ENHANCEMENT_METADATA marker

### 8. ESTIMATE Effort & Complexity

**Effort Estimate:** 2-3 hours (from task specification)

**Complexity Breakdown:**
- **Read existing code:** 15 min - Check if embedMetadata() exists
- **Define schema:** 30 min - Complete metadata schema design
- **Enhance method:** 45 min - Implement full metadata formatting
- **Tests:** 60 min - 8 test cases (90% coverage)
- **Manual testing:** 20 min - Verify with real enhancements
- **REFACTOR:** 20 min - Optimize size, sanitize paths

**Total:** ~3 hours (matches estimate)

**Confidence Level:** HIGH
- ✅ Method already exists (embedMetadata() in AIEnhancementService.ts)
- ✅ EnhancementContext provides all needed data
- ✅ HTML comment format well-understood
- ✅ Simple JSON formatting task

---

## Step 1: UNDERSTAND the Existing Implementation

### Read Foundation Files

**CRITICAL: Read these files BEFORE writing any code.**

```bash
# Read AIEnhancementService (check embedMetadata method)
cat vscode-lumina/src/services/AIEnhancementService.ts

# Read EnhancementContext type (see available metadata)
cat vscode-lumina/src/types/EnhancementContext.ts
```

### Existing Implementation Analysis

**From AIEnhancementService.ts (lines 268-280):**

```typescript
/**
 * Embed metadata in HTML comment
 *
 * PURPOSE: Terminal AI can parse metadata to skip redundant analysis
 *
 * Format:
 * <!--
 * AETHERLIGHT_ENHANCEMENT_METADATA
 * {JSON metadata}
 * -->
 * Enhanced prompt text...
 */
private embedMetadata(prompt: string, context: EnhancementContext): string {
    const metadata = {
        filesAnalyzed: context.workspaceContext.filesFound.map(f => f.path),
        gitCommitsReviewed: context.workspaceContext.gitCommits.length,
        confidence: context.metadata.confidence,
        patterns: context.metadata.patterns,
        agent: context.metadata.agent,
        validation: context.metadata.validation
    };

    const metadataComment = `<!--\nAETHERLIGHT_ENHANCEMENT_METADATA\n${JSON.stringify(metadata, null, 2)}\n-->\n\n`;
    return metadataComment + prompt;
}
```

**Status:** ✅ **PARTIALLY IMPLEMENTED**

**What's Missing:**
- ❌ No metadata schema version
- ❌ No button type (enhancementType)
- ❌ No timestamp
- ❌ No template version
- ❌ No context summary (workspace languages, frameworks)
- ❌ No git commit details (just count, not metadata)
- ❌ No error handling for JSON.stringify
- ❌ No size optimization
- ❌ No path sanitization

**What This Task Must Do:**
1. Define complete metadata schema (EnhancementMetadata interface)
2. Enhance embedMetadata() to include all fields
3. Add error handling (JSON formatting failures)
4. Add size optimization (compress if > 2KB)
5. Sanitize workspace paths (relative, not absolute)
6. Add unit tests

---

## Step 2: Define Complete Metadata Schema

### Metadata Schema Interface

**File:** `vscode-lumina/src/types/EnhancementMetadata.ts` (new file)

```typescript
/**
 * EnhancementMetadata
 *
 * DESIGN DECISION: Complete metadata schema for terminal AI passthrough
 * WHY: Terminal AI needs structured context to skip redundant analysis
 *
 * REASONING CHAIN:
 * 1. AI receives enhanced prompt as plain text
 * 2. AI doesn't know what button triggered it
 * 3. AI doesn't know what context was gathered
 * 4. AI must re-analyze everything (duplicate work)
 * 5. Solution: Embed metadata as parseable HTML comment
 * 6. AI parses AETHERLIGHT_ENHANCEMENT_METADATA marker
 * 7. AI uses metadata to understand intent, trust validation, skip analysis
 * 8. Result: 50%+ faster AI responses, more accurate context
 *
 * PATTERN: Pattern-METADATA-PASSTHROUGH-001 (Context Preservation)
 * ARCHITECTURE: v3.0 AI Enhancement System
 * RELATED: EnhancementContext.ts, AIEnhancementService.ts
 *
 * METADATA FORMAT:
 * <!--
 * AETHERLIGHT_ENHANCEMENT_METADATA
 * {
 *   "version": "1.0",
 *   "enhancementType": "bug",
 *   "buttonType": "Bug Report",
 *   ...
 * }
 * -->
 */

/**
 * Complete metadata schema for terminal AI passthrough
 *
 * This metadata is embedded in enhanced prompts as HTML comment.
 * Terminal AI can parse it to understand context and skip redundant work.
 */
export interface EnhancementMetadata {
    /**
     * Metadata schema version (for future compatibility)
     */
    version: string;  // "1.0"

    /**
     * Enhancement type (discriminator)
     * Maps to EnhancementContext.type
     */
    enhancementType: 'task' | 'bug' | 'feature' | 'code_analyzer' | 'sprint_planner' | 'general';

    /**
     * Human-readable button name
     */
    buttonType: string;  // "Bug Report", "Code Analyzer", "Start This Task", etc.

    /**
     * Timestamp when enhancement occurred
     */
    timestamp: string;  // ISO 8601 format

    /**
     * Template version used
     */
    templateVersion: string;  // "MVP-003 v1.4.3"

    /**
     * Confidence score and level
     */
    confidence: {
        score: number;      // 0-100
        level: 'high' | 'medium' | 'low';
    };

    /**
     * Context gathered summary
     */
    contextGathered: {
        /**
         * Workspace context summary
         */
        workspace: {
            rootPath: string;           // Relative path (sanitized)
            languages: string[];        // ["TypeScript", "JavaScript"]
            frameworks: string[];       // ["VS Code Extension", "Node.js"]
            filesAnalyzed: number;      // Count, not full list (size optimization)
            directoryCount?: number;    // Number of directories
        };

        /**
         * Git context summary
         */
        git?: {
            commitsAnalyzed: number;    // Count
            daysBack: number;           // How far back commits were analyzed
            branch?: string;            // Current branch name
            hasUncommittedChanges?: boolean;
        };

        /**
         * Files found (with relevance scores)
         * Limited to top 10 for size optimization
         */
        filesFound: Array<{
            path: string;               // Relative path
            relevance: number;          // 0-100
            reason: string;             // Why this file is relevant
        }>;

        /**
         * Patterns identified
         */
        patterns: string[];             // ["Pattern-CODE-001", "Pattern-TDD-001"]

        /**
         * SOPs available
         */
        sops: {
            claudeMd: boolean;          // CLAUDE.md found?
            aetherlightMd: boolean;     // aetherlight.md found?
        };
    };

    /**
     * Validation results
     * AI can trust these checks were already performed
     */
    validation: {
        filesExist: boolean;            // Do referenced files exist?
        dependenciesMet: boolean;       // Are task dependencies satisfied?
        taskDataCurrent: boolean;       // Is task data up-to-date?
    };

    /**
     * Agent assigned
     */
    agent: string;  // "developer-agent", "infrastructure-agent", etc.

    /**
     * User-specific context (button-specific data)
     * Type varies by enhancement type
     */
    specificContext?: {
        [key: string]: any;
    };
}

/**
 * Metadata formatter options
 */
export interface MetadataFormatterOptions {
    /**
     * Maximum metadata size in bytes
     * If exceeded, compress by omitting non-critical fields
     */
    maxSize?: number;  // Default: 2048 (2KB)

    /**
     * Whether to pretty-print JSON
     */
    prettyPrint?: boolean;  // Default: true

    /**
     * Whether to sanitize paths (convert absolute → relative)
     */
    sanitizePaths?: boolean;  // Default: true

    /**
     * Whether to include specificContext (can be large)
     */
    includeSpecificContext?: boolean;  // Default: false
}
```

---

## Step 3: TDD - Write Tests FIRST (RED Phase)

**CRITICAL: Pattern-TDD-001 requires writing tests BEFORE implementation.**

### Test File

**File:** `vscode-lumina/test/services/AIEnhancementService-metadata.test.ts`

```typescript
import * as assert from 'assert';
import { AIEnhancementService } from '../../src/services/AIEnhancementService';
import { EnhancementContext } from '../../src/types/EnhancementContext';
import { EnhancementMetadata } from '../../src/types/EnhancementMetadata';

describe('AIEnhancementService - Metadata Passthrough', () => {
    let service: AIEnhancementService;

    beforeEach(() => {
        service = new AIEnhancementService();
    });

    // TEST 1: Metadata embedding
    describe('Metadata embedding', () => {
        it('should embed metadata as HTML comment at top of prompt', () => {
            const mockContext: EnhancementContext = {
                type: 'bug',
                template: { id: 'BUG-001', name: 'Fix auth bug', /* ... */ },
                metadata: {
                    buttonType: 'bug',
                    confidence: { score: 85, level: 'high' },
                    patterns: ['Pattern-CODE-001'],
                    agent: 'developer-agent',
                    validation: { filesExist: true, dependenciesMet: true, taskDataCurrent: true }
                },
                workspaceContext: {
                    rootPath: '/workspace',
                    languages: ['TypeScript'],
                    frameworks: ['VS Code Extension'],
                    filesFound: [],
                    gitCommits: [],
                    sops: { claudeMd: 'content', aetherlightMd: undefined }
                },
                specificContext: {}
            };

            const prompt = 'Fix authentication bug in src/auth.ts';
            const result = service['embedMetadata'](prompt, mockContext);

            // Verify HTML comment exists at top
            assert.ok(result.startsWith('<!--'));
            assert.ok(result.includes('AETHERLIGHT_ENHANCEMENT_METADATA'));
            assert.ok(result.includes('-->'));

            // Verify original prompt follows metadata
            assert.ok(result.includes(prompt));
        });
    });

    // TEST 2: Metadata schema completeness
    describe('Metadata schema', () => {
        it('should include all required metadata fields', () => {
            const mockContext: EnhancementContext = { /* ... */ };
            const result = service['embedMetadata']('Test', mockContext);

            // Extract metadata JSON
            const metadataMatch = result.match(/<!--\s*AETHERLIGHT_ENHANCEMENT_METADATA\s*\n([\s\S]+?)\n-->/);
            assert.ok(metadataMatch, 'Metadata comment not found');

            const metadata = JSON.parse(metadataMatch[1]) as EnhancementMetadata;

            // Verify required fields
            assert.strictEqual(metadata.version, '1.0');
            assert.strictEqual(metadata.enhancementType, 'bug');
            assert.ok(metadata.buttonType);
            assert.ok(metadata.timestamp);
            assert.ok(metadata.templateVersion);
            assert.ok(metadata.confidence);
            assert.ok(metadata.contextGathered);
            assert.ok(metadata.validation);
            assert.ok(metadata.agent);
        });

        it('should include workspace context summary', () => {
            const mockContext: EnhancementContext = { /* ... */ };
            const result = service['embedMetadata']('Test', mockContext);

            const metadata = extractMetadata(result);

            assert.ok(metadata.contextGathered.workspace);
            assert.ok(metadata.contextGathered.workspace.languages.length > 0);
            assert.ok(metadata.contextGathered.workspace.frameworks.length > 0);
            assert.ok(typeof metadata.contextGathered.workspace.filesAnalyzed === 'number');
        });

        it('should include git context summary if available', () => {
            const mockContext: EnhancementContext = {
                // ... with git commits
                workspaceContext: {
                    gitCommits: [
                        { hash: 'abc123', message: 'fix: auth', date: '2025-01-13' },
                        { hash: 'def456', message: 'test: add tests', date: '2025-01-12' }
                    ],
                    // ...
                }
            };

            const result = service['embedMetadata']('Test', mockContext);
            const metadata = extractMetadata(result);

            assert.ok(metadata.contextGathered.git);
            assert.strictEqual(metadata.contextGathered.git.commitsAnalyzed, 2);
            assert.ok(metadata.contextGathered.git.daysBack);
        });
    });

    // TEST 3: JSON validity
    describe('JSON validity', () => {
        it('should produce valid parseable JSON', () => {
            const mockContext: EnhancementContext = { /* ... */ };
            const result = service['embedMetadata']('Test', mockContext);

            // Extract metadata JSON
            const metadataMatch = result.match(/<!--\s*AETHERLIGHT_ENHANCEMENT_METADATA\s*\n([\s\S]+?)\n-->/);
            assert.ok(metadataMatch);

            // Verify JSON is valid (should not throw)
            const metadata = JSON.parse(metadataMatch[1]);
            assert.ok(metadata);
        });

        it('should handle JSON formatting errors gracefully', () => {
            const mockContext: EnhancementContext = {
                // ... with circular reference (would break JSON.stringify)
                specificContext: { circular: null }
            };
            mockContext.specificContext.circular = mockContext.specificContext;

            // Should not throw, should fallback to minimal metadata
            const result = service['embedMetadata']('Test', mockContext);
            assert.ok(result.includes('Test'));
        });
    });

    // TEST 4: Size optimization
    describe('Size optimization', () => {
        it('should compress metadata if > 2KB', () => {
            const mockContext: EnhancementContext = {
                // ... with large context (100+ files)
                workspaceContext: {
                    filesFound: Array(100).fill(null).map((_, i) => ({
                        path: `src/file${i}.ts`,
                        relevance: 90,
                        reason: 'Relevant file'
                    })),
                    // ...
                }
            };

            const result = service['embedMetadata']('Test', mockContext);
            const metadata = extractMetadata(result);

            // Should limit filesFound to top 10
            assert.ok(metadata.contextGathered.filesFound.length <= 10);
        });

        it('should omit specificContext if includeSpecificContext=false', () => {
            const mockContext: EnhancementContext = {
                specificContext: { largeData: 'x'.repeat(10000) },
                // ...
            };

            const result = service['embedMetadata']('Test', mockContext, {
                includeSpecificContext: false
            });

            const metadata = extractMetadata(result);
            assert.strictEqual(metadata.specificContext, undefined);
        });
    });

    // TEST 5: Path sanitization
    describe('Path sanitization', () => {
        it('should convert absolute paths to relative', () => {
            const mockContext: EnhancementContext = {
                workspaceContext: {
                    rootPath: '/Users/Brett/Dropbox/Ferret9 Global/lumina-clean',
                    filesFound: [
                        { path: '/Users/Brett/Dropbox/Ferret9 Global/lumina-clean/src/auth.ts', relevance: 95, reason: 'Auth' }
                    ],
                    // ...
                }
            };

            const result = service['embedMetadata']('Test', mockContext, {
                sanitizePaths: true
            });

            const metadata = extractMetadata(result);

            // rootPath should be sanitized
            assert.ok(!metadata.contextGathered.workspace.rootPath.includes('/Users/'));
            assert.ok(!metadata.contextGathered.workspace.rootPath.includes('Brett'));

            // File paths should be relative
            assert.strictEqual(metadata.contextGathered.filesFound[0].path, 'src/auth.ts');
        });
    });

    // TEST 6: HTML comment format
    describe('HTML comment format', () => {
        it('should not display in terminal (invisible)', () => {
            const mockContext: EnhancementContext = { /* ... */ };
            const result = service['embedMetadata']('Test prompt', mockContext);

            // HTML comment should be at top
            assert.ok(result.startsWith('<!--'));

            // Prompt should follow with blank line separator
            const parts = result.split('-->');
            assert.strictEqual(parts.length, 2);
            assert.ok(parts[1].trim().startsWith('Test prompt'));
        });
    });

    // TEST 7: Performance
    describe('Performance', () => {
        it('should format metadata in < 10ms', () => {
            const mockContext: EnhancementContext = { /* ... */ };

            const startTime = Date.now();
            service['embedMetadata']('Test', mockContext);
            const duration = Date.now() - startTime;

            assert.ok(duration < 10, `Metadata formatting took ${duration}ms (expected < 10ms)`);
        });
    });

    // TEST 8: Integration with enhance()
    describe('Integration with enhance()', () => {
        it('should include metadata in all enhanced prompts', async () => {
            const mockContext: EnhancementContext = { /* ... */ };

            const enhancedPrompt = await service.enhance(mockContext);

            // Verify metadata present
            assert.ok(enhancedPrompt.includes('AETHERLIGHT_ENHANCEMENT_METADATA'));
        });
    });
});

// Helper function
function extractMetadata(prompt: string): EnhancementMetadata {
    const metadataMatch = prompt.match(/<!--\s*AETHERLIGHT_ENHANCEMENT_METADATA\s*\n([\s\S]+?)\n-->/);
    if (!metadataMatch) {
        throw new Error('Metadata not found in prompt');
    }
    return JSON.parse(metadataMatch[1]);
}
```

### Run Tests (Expected to FAIL - RED Phase)

```bash
cd vscode-lumina
npm test -- --grep "Metadata Passthrough"
```

**Expected Output:**
```
AIEnhancementService - Metadata Passthrough
  ❌ should embed metadata as HTML comment at top of prompt
  AssertionError: Metadata missing required field 'version'

  ❌ should include all required metadata fields
  AssertionError: Expected 'version' but got undefined

  ... 6 more failures

  0 passing (35ms)
  8 failing
```

**Status:** ✅ RED phase complete (tests exist, implementation incomplete)

---

## Step 4: Implementation - Enhance embedMetadata() (GREEN Phase)

### File Modifications

**File:** `vscode-lumina/src/services/AIEnhancementService.ts`

**Replace the existing `embedMetadata()` method (lines 268-280) with enhanced version:**

```typescript
import { EnhancementMetadata, MetadataFormatterOptions } from '../types/EnhancementMetadata';
import * as path from 'path';

/**
 * Embed metadata in HTML comment
 *
 * PURPOSE: Terminal AI can parse metadata to skip redundant analysis
 *
 * ENHANCED VERSION (v1.0):
 * - Complete metadata schema (version, timestamp, template, context summary)
 * - Size optimization (compress if > 2KB)
 * - Path sanitization (relative paths, not absolute)
 * - Error handling (JSON formatting failures)
 *
 * Format:
 * <!--
 * AETHERLIGHT_ENHANCEMENT_METADATA
 * {
 *   "version": "1.0",
 *   "enhancementType": "bug",
 *   "buttonType": "Bug Report",
 *   "timestamp": "2025-01-13T10:30:00Z",
 *   "confidence": {"score": 85, "level": "high"},
 *   "contextGathered": {...},
 *   "validation": {...}
 * }
 * -->
 * Enhanced prompt text...
 *
 * @param prompt - Generated prompt text
 * @param context - Enhancement context
 * @param options - Formatter options (size limits, sanitization)
 * @returns Prompt with embedded metadata
 */
private embedMetadata(
    prompt: string,
    context: EnhancementContext,
    options?: MetadataFormatterOptions
): string {
    try {
        // Default options
        const opts: MetadataFormatterOptions = {
            maxSize: options?.maxSize || 2048,
            prettyPrint: options?.prettyPrint !== false,
            sanitizePaths: options?.sanitizePaths !== false,
            includeSpecificContext: options?.includeSpecificContext || false
        };

        // Build complete metadata
        const metadata: EnhancementMetadata = {
            version: '1.0',
            enhancementType: context.type,
            buttonType: this.getButtonTypeName(context.type),
            timestamp: new Date().toISOString(),
            templateVersion: 'MVP-003 v1.4.3',
            confidence: context.metadata.confidence,
            contextGathered: {
                workspace: {
                    rootPath: opts.sanitizePaths
                        ? this.sanitizePath(context.workspaceContext.rootPath)
                        : context.workspaceContext.rootPath,
                    languages: context.workspaceContext.languages,
                    frameworks: context.workspaceContext.frameworks,
                    filesAnalyzed: context.workspaceContext.filesFound.length,
                    directoryCount: this.estimateDirectoryCount(context.workspaceContext.rootPath)
                },
                git: context.workspaceContext.gitCommits.length > 0 ? {
                    commitsAnalyzed: context.workspaceContext.gitCommits.length,
                    daysBack: this.calculateDaysBack(context.workspaceContext.gitCommits),
                    branch: this.getCurrentBranch(),
                    hasUncommittedChanges: false  // TODO: Implement git status check
                } : undefined,
                filesFound: this.compressFilesFound(
                    context.workspaceContext.filesFound,
                    opts.sanitizePaths
                ),
                patterns: context.metadata.patterns,
                sops: {
                    claudeMd: !!context.workspaceContext.sops.claudeMd,
                    aetherlightMd: !!context.workspaceContext.sops.aetherlightMd
                }
            },
            validation: context.metadata.validation,
            agent: context.metadata.agent,
            specificContext: opts.includeSpecificContext ? context.specificContext : undefined
        };

        // Format as JSON
        let metadataJson = opts.prettyPrint
            ? JSON.stringify(metadata, null, 2)
            : JSON.stringify(metadata);

        // Size check: compress if needed
        if (metadataJson.length > opts.maxSize) {
            console.log(`[AIEnhancementService] Metadata too large (${metadataJson.length} bytes), compressing`);
            metadata.contextGathered.filesFound = metadata.contextGathered.filesFound.slice(0, 5);
            metadata.specificContext = undefined;
            metadataJson = JSON.stringify(metadata, null, 2);
        }

        // Format as HTML comment
        const metadataComment = `<!--\nAETHERLIGHT_ENHANCEMENT_METADATA\n${metadataJson}\n-->\n\n`;
        return metadataComment + prompt;

    } catch (error) {
        // Fallback: if metadata fails, return prompt without metadata
        console.error('[AIEnhancementService] Metadata embedding failed:', error);
        return prompt;
    }
}

/**
 * Get human-readable button type name
 */
private getButtonTypeName(type: string): string {
    const names: Record<string, string> = {
        'task': 'Start This Task',
        'bug': 'Bug Report',
        'feature': 'Feature Request',
        'code_analyzer': 'Code Analyzer',
        'sprint_planner': 'Sprint Planner',
        'general': 'General Enhancement'
    };
    return names[type] || type;
}

/**
 * Sanitize workspace path (convert absolute → relative)
 */
private sanitizePath(absolutePath: string): string {
    // Remove username from path
    let sanitized = absolutePath.replace(/\/Users\/[^\/]+\//, '/Users/<user>/');
    sanitized = sanitized.replace(/C:\\Users\\[^\\]+\\/, 'C:\\Users\\<user>\\');

    // Convert to relative if possible
    const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
    if (workspaceRoot && absolutePath.startsWith(workspaceRoot)) {
        return path.relative(workspaceRoot, absolutePath) || '.';
    }

    return sanitized;
}

/**
 * Compress filesFound list (top 10 by relevance)
 */
private compressFilesFound(
    files: Array<{ path: string; relevance: number; reason: string }>,
    sanitize: boolean
): Array<{ path: string; relevance: number; reason: string }> {
    // Sort by relevance (descending)
    const sorted = [...files].sort((a, b) => b.relevance - a.relevance);

    // Take top 10
    const top10 = sorted.slice(0, 10);

    // Sanitize paths if requested
    return top10.map(file => ({
        path: sanitize ? this.sanitizePath(file.path) : file.path,
        relevance: file.relevance,
        reason: file.reason
    }));
}

/**
 * Calculate how many days back git commits were analyzed
 */
private calculateDaysBack(commits: Array<{ hash: string; message: string; date: string }>): number {
    if (commits.length === 0) return 0;

    const oldest = commits[commits.length - 1].date;
    const oldestDate = new Date(oldest);
    const now = new Date();
    const diffMs = now.getTime() - oldestDate.getTime();
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

    return diffDays;
}

/**
 * Get current git branch
 */
private getCurrentBranch(): string | undefined {
    try {
        const { execSync } = require('child_process');
        const branch = execSync('git rev-parse --abbrev-ref HEAD', {
            encoding: 'utf-8'
        }).trim();
        return branch;
    } catch {
        return undefined;
    }
}

/**
 * Estimate directory count (approximate)
 */
private estimateDirectoryCount(rootPath: string): number {
    // Simple heuristic: count subdirectories in workspace root
    try {
        const fs = require('fs');
        const entries = fs.readdirSync(rootPath, { withFileTypes: true });
        return entries.filter((e: any) => e.isDirectory()).length;
    } catch {
        return 0;
    }
}
```

---

## Step 5: Validation & Testing

### Run Tests (Expected to PASS - GREEN Phase)

```bash
cd vscode-lumina
npm run compile
npm test -- --grep "Metadata Passthrough"
```

**Expected Output:**
```
AIEnhancementService - Metadata Passthrough
  Metadata embedding
    ✓ should embed metadata as HTML comment at top of prompt (23ms)
  Metadata schema
    ✓ should include all required metadata fields (34ms)
    ✓ should include workspace context summary (28ms)
    ✓ should include git context summary if available (31ms)
  JSON validity
    ✓ should produce valid parseable JSON (19ms)
    ✓ should handle JSON formatting errors gracefully (22ms)
  Size optimization
    ✓ should compress metadata if > 2KB (45ms)
    ✓ should omit specificContext if includeSpecificContext=false (18ms)
  Path sanitization
    ✓ should convert absolute paths to relative (27ms)
  HTML comment format
    ✓ should not display in terminal (invisible) (15ms)
  Performance
    ✓ should format metadata in < 10ms (7ms)
  Integration with enhance()
    ✓ should include metadata in all enhanced prompts (89ms)

12 passing (358ms)
```

**Status:** ✅ GREEN phase complete

---

## Step 6: Manual Testing

### Test with Real Enhancement

1. Launch Extension Development Host (F5)
2. Click ÆtherLight icon → Bug Report button
3. Fill form:
   - Bug Description: "Authentication fails on first login"
   - Severity: High
   - Steps to Reproduce: "1. Launch app 2. Click login 3. Error appears"
4. Click "Enhance"
5. Verify enhanced prompt starts with metadata comment:

```html
<!--
AETHERLIGHT_ENHANCEMENT_METADATA
{
  "version": "1.0",
  "enhancementType": "bug",
  "buttonType": "Bug Report",
  "timestamp": "2025-01-13T15:45:00Z",
  "templateVersion": "MVP-003 v1.4.3",
  "confidence": {
    "score": 78,
    "level": "high"
  },
  "contextGathered": {
    "workspace": {
      "rootPath": ".",
      "languages": ["TypeScript", "JavaScript"],
      "frameworks": ["VS Code Extension"],
      "filesAnalyzed": 5,
      "directoryCount": 12
    },
    "git": {
      "commitsAnalyzed": 8,
      "daysBack": 7,
      "branch": "feature/v0.17.2-bug-fixes"
    },
    "filesFound": [
      {
        "path": "src/auth.ts",
        "relevance": 95,
        "reason": "Authentication logic"
      }
    ],
    "patterns": ["Pattern-CODE-001", "Pattern-TDD-001"],
    "sops": {
      "claudeMd": true,
      "aetherlightMd": true
    }
  },
  "validation": {
    "filesExist": true,
    "dependenciesMet": true,
    "taskDataCurrent": true
  },
  "agent": "developer-agent"
}
-->

# Fix Authentication Bug

[Enhanced prompt content...]
```

6. Copy prompt to terminal AI
7. Ask AI: "Can you see the enhancement metadata?"
8. Verify AI confirms it can parse metadata

---

## Step 7: Documentation & Commit

### Update Task Status

**File:** `internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml`

Mark ENHANCE-001.6 as completed:

```toml
[tasks."ENHANCE-001.6"]
status = "completed"
```

### Commit Changes

```bash
git add vscode-lumina/src/types/EnhancementMetadata.ts
git add vscode-lumina/src/services/AIEnhancementService.ts
git add vscode-lumina/test/services/AIEnhancementService-metadata.test.ts
git add internal/sprints/ACTIVE_SPRINT_17.1_BUGS.toml

git commit -m "feat(ENHANCE-001.6): Implement complete metadata passthrough system

- Add EnhancementMetadata interface (complete schema definition)
- Enhance embedMetadata() in AIEnhancementService
- Include: version, timestamp, button type, template version
- Include: workspace summary, git summary, files found, patterns
- Include: validation results, agent assignment
- Add size optimization (compress if > 2KB, limit files to top 10)
- Add path sanitization (convert absolute → relative)
- Add error handling (JSON formatting failures)
- Add unit tests (90% coverage)
- Metadata formatting overhead < 10ms

Terminal AI can now parse AETHERLIGHT_ENHANCEMENT_METADATA to:
- Understand button type (intent clear)
- Trust validation results (files already checked)
- Skip redundant analysis (context already gathered)
- Use confidence level (skip questions if high)

Closes ENHANCE-001.6"
```

---

## Success Criteria

After ENHANCE-001.6 complete:

✅ **AI agent receives structured metadata with every enhanced prompt**
- HTML comment with AETHERLIGHT_ENHANCEMENT_METADATA marker

✅ **AI knows button type (intent clear)**
- enhancementType + buttonType fields

✅ **AI knows confidence level (skip questions if high)**
- confidence.score + confidence.level

✅ **AI knows context gathered (no re-analysis)**
- workspace summary, git summary, files found, patterns

✅ **AI knows validation results (trust file list)**
- validation.filesExist, validation.dependenciesMet, validation.taskDataCurrent

✅ **AI responses are more accurate and efficient**
- 50%+ faster responses (skip redundant analysis)

✅ **No duplicate context gathering**
- AI parses metadata once, uses throughout conversation

---

## Terminal AI Usage Instructions

**For Terminal AI (Claude, ChatGPT, etc.):**

When you receive an enhanced prompt from ÆtherLight, look for the metadata comment at the top:

```html
<!--
AETHERLIGHT_ENHANCEMENT_METADATA
{JSON metadata}
-->
```

Parse the metadata to understand:

1. **Button Type:** Which enhancement button triggered this (task, bug, feature, code_analyzer, sprint_planner, general)
2. **Confidence Level:** How confident the context gathering was (high 70%+, medium 40-70%, low <40%)
3. **Context Gathered:** What analysis was already performed (workspace, git, files, patterns)
4. **Validation Results:** Which checks were already performed (trust these)
5. **Agent Assignment:** Which agent should handle this (developer, infrastructure, ui, etc.)

**Benefits:**
- Skip redundant analysis (workspace already analyzed)
- Trust validation results (files already checked to exist)
- Understand intent from button type (bug fix vs. feature vs. analysis)
- Adjust response based on confidence level (ask clarifying questions if low)

---

## Next Steps

After ENHANCE-001.6 is implemented and tests pass:

1. **ENHANCE-001.7:** Iterative Refinement UI (re-enhance with user feedback)
2. **ENHANCE-001.8:** Context Preview Modal (show context before enhancement)
3. **ENHANCE-001.9:** Progressive Loading UI (streaming enhancement display)

---

## Pattern References

- **Pattern-CODE-001:** Code development workflow
- **Pattern-TDD-001:** Test-driven development (RED → GREEN → REFACTOR)
- **Pattern-METADATA-PASSTHROUGH-001:** Context preservation for AI agents (THIS TASK!)
- **Pattern-TASK-ANALYSIS-001:** 8-step pre-task analysis
- **Pattern-GIT-001:** Git workflow integration

---

**Template Version:** MVP-003-PromptEnhancer-TaskTemplate-v1.4.3
**Generated:** 2025-01-13
**For:** ENHANCE-001.6 (Metadata Passthrough System - Structured Context in Enhanced Prompts)
